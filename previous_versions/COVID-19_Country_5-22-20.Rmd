---
title: "Accounting for Global COVID-19 Diffusion Patterns, January-April 2020"
output: html_document
---

authors: "Sameer Nair-Desai, Rashad Ahmed, Weining Xin"
date: "5/22/2020"
output: 
  html_document: default
  pdf_document: default
  word_document: default
---

*If you do not wish to run the code, please see the final output (graphs and datasets) provided in the Github repository. Make sure to check the relevant README files for the contents of the folder.*

Installing the relevant packages.
install.packages("sf")
install.packages("readr")
install.packages("tmap") 
install.packages("leaflet") 
install.packages("mapview") 
install.packages("ggplot2")
install.packages("tidyverse")
install.packages("rlang")
install.packages("reshape")
install.packages("rgdal")
install.packages("lubridate")
install.packages("plotly")
install.packages("patchwork")
install.packages("ggforce")
install.packages("gridExtra")
install.packages("htmltools")
install.packages("data.table")
install.packages("webshot")
webshot::install_phantomjs()
install.packages("runner")
install.packages("zoo")
install.packages("devtools")
devtools::install_version("latticeExtra", version="0.6-28")
install.packages("Hmisc")
install.packages("DataCombine")
install.packages("fastDummies")
install.packages("heatmaply")
install.packages("glmnet")
install.packages("caret")
install.packages("summarytools")
install.packages("remote")
remotes::install_github('rapporter/pander')
install.packages("mlbench")
install.packages("psych")
install.packages("lmtest")
install.packages("quantmod")
install.packages("corrplot")
install.packages("fBasics")
install.packages("stargazer")
install.packages("tseries")
install.packages("vars")
install.packages("gghighlight")

```{r libraries}
# Setting our initial libraries. In subsequent rounds of analysis, we will be integrating new libraries (we do not do so here to avoid conflicts between packages).
library(sf)
library(readr)
library(mapview)
library(ggplot2)
library(tidyverse)
library(rlang)
library(reshape)
library(rgdal)
library(lubridate)
library(plotly)
library(patchwork)
library(ggforce)
library(gridExtra)
library(htmltools)
library(data.table)
library(webshot)
library(coronavirus)
library(runner)
library(zoo)
library(DataCombine)
library(fastDummies)
library(car)
library(heatmaply)
library(htmlwidgets)
library(summarytools)
library(glmnet)
library(caret)
library(mlbench)
library(psych)
library(plm)
library(lmtest)
library(quantmod)
library(leaflet)
library(corrplot)
library(fBasics)
library(stargazer)
library(tseries)
library(vars)
library(dplyr)
library(gghighlight)
# I don't want scientific notation for my values, so I specify this below.
options(scipen = 999)
```


## CLEANING - Note that initial confirmed cases and deaths are recorded as cumulative sums in the Hopkins dataset. We will generate new (daily and weekly) case and death data.
```{r cleaning}
# Import and quickly cleaning our data. We will call the import our initial confirmed data (Wide). 
Initial_Confirmed_Wide <- read_csv("COVID-19_Final/data/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv")
```

# Creating our Temporary and World data files.
```{r creation}
# Our data is in wide format. Here, I translate it to long format.
Confirmed_Long <- pivot_longer(Initial_Confirmed_Wide, cols = c(5:102), names_to = "Dates", values_to = "Confirmed_Cases")

# Now, I rename my column for country in the long dataset.
Confirmed_Long$COUNTRY <- Confirmed_Long$`Country/Region`

# I can also convert the dates into a more usable string format with lubridate.
Confirmed_Long$Date <- mdy(Confirmed_Long$Dates, quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"),
  truncated = 0)
order(Confirmed_Long$Date)

# Now, I repeat these steps for the deceased data. 
Initial_Deceased_Wide <- read_csv("COVID-19_Final/data/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv")

# We continue with the reshape.
Deceased_Long <- pivot_longer(Initial_Deceased_Wide, cols = c(5:102), names_to = "Dates", values_to = "Deceased")
require(reshape)
Deceased_Long$COUNTRY <- Deceased_Long$`Country/Region`
Deceased_Long$Date <- mdy(Deceased_Long$Dates, quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"),
  truncated = 0)
order(Deceased_Long$Date)

# I then merge the cleaned deceased and confirmed datasets.
Merged_Data <- cbind(Confirmed_Long, Deceased_Long)
colnames(Merged_Data)

# I only keep the variables we are interested in.
myvars <- c("COUNTRY", "Province/State", "Lat", "Long", "Dates", "Confirmed_Cases", "Date", "Deceased")

# I rename this file as our temporary data.
Temporary_Data_Country <- Merged_Data[myvars]

# We might also want a dataset with the total number of global confirmed cases and deaths per day.
World_Data <- Temporary_Data_Country %>% group_by(Date) %>%
summarise(country='World', Global_Confirmed_Cases = sum(Confirmed_Cases, na.rm=T),
Global_Deceased = sum(Deceased, na.rm=T))
World_Data$Death_Rate <- ((World_Data$Global_Deceased/World_Data$Global_Confirmed_Cases) * 100)
```

# Collapsing and calculating relevant variables in the temporary data.
```{r calculations}
# Here, I subset the data so as to properly collapse by country.
myvarstemporary <- c("COUNTRY", "Date", "Confirmed_Cases", "Deceased")

Temporary_Data_Country <- Temporary_Data_Country[myvarstemporary]

Temporary_Data_Country <- Temporary_Data_Country %>%
  group_by(COUNTRY, Date) %>%
  summarise(Total_Cases_Country = sum(Confirmed_Cases), Total_Deceased_Country = sum(Deceased))

# I next want to calculate the increase in deaths and confirmed cases per day.

Temporary_Data_Country %>%
  arrange(COUNTRY, Date)

number <- nrow(Temporary_Data_Country)
First_Day <- min(Temporary_Data_Country$Date)

Temporary_Data_Country$New_Confirmed_Country <- ifelse(Temporary_Data_Country$Date == First_Day, NA, Temporary_Data_Country$Total_Cases_Country - dplyr::lag(Temporary_Data_Country$Total_Cases_Country, number=1))

Temporary_Data_Country$New_Total_Deceased_Country <- ifelse(Temporary_Data_Country$Date == First_Day, NA, Temporary_Data_Country$Total_Deceased_Country - dplyr::lag(Temporary_Data_Country$Total_Deceased_Country, number=1))

# There are a few values for which we have negative new deaths and new cases. Intuitively, this shouldn't make sense. This is actually a problem which steps from the COVID data. For example, Iceland has some weird values in the initial dataframe. Although deaths should represent cumulative sums, if we observe the data from 3/15 - 4/05, we note that the number of recorded deaths drops from 5 to 0, then increases back to six as the month progresses. This is a well-documented problem which stems from the original Github data: https://github.com/CSSEGISandData/COVID-19/issues/2379; https://github.com/CSSEGISandData/COVID-19/issues/2165. We can either exclude data points which show a decrease in cumulative deaths (which I haven't done here); or wait for the data to be updated. Because we only drop a few observations from the analysis, I choose to exclude them, and proceed as normal. Note that when we take global sums, this will affect our cumulative totals (as we have excluded observations for certain nations on certain days).

Temporary_Data_Country <- Temporary_Data_Country[which(Temporary_Data_Country$New_Confirmed_Country >= 0),]
Temporary_Data_Country <- Temporary_Data_Country[which(Temporary_Data_Country$New_Total_Deceased_Country >= 0),]

# Now, I calculate the total mortality rate per capita, new mortality rate per capita, death rate per capita, and confirmed cases per capita (using data from the United Nations on global demographics for the merge). 

UN_Population <- read_csv("COVID-19_Final/data/UN_Population_Data.csv")

UN_Population$COUNTRY <- UN_Population$Location

UN_Population[25, "COUNTRY"] <- "Bolivia"
UN_Population[30, "COUNTRY"] <- "Brunei"
UN_Population[43, "COUNTRY"] <- "Taiwan*"
UN_Population[46, "COUNTRY"] <- "Congo (Brazzaville)"
UN_Population[54, "COUNTRY"] <-"Cote d'Ivoire"
UN_Population[56, "COUNTRY"] <- "Congo (Kinshasa)"
UN_Population[98, "COUNTRY"] <- "Iran"
UN_Population[112, "COUNTRY"] <- "Laos"
UN_Population[138, "COUNTRY"] <- "Burma"
UN_Population[162, "COUNTRY"] <- "Korea, South"
UN_Population[163, "COUNTRY"] <- "Moldova"
UN_Population[165, "COUNTRY"] <- "Russia"
UN_Population[196, "COUNTRY"] <- "Syria"
UN_Population[212, "COUNTRY"] <- "Tanzania"
UN_Population[213, "COUNTRY"] <- "US"
UN_Population[217, "COUNTRY"] <- "Venezuela"
UN_Population[218, "COUNTRY"] <- "Vietnam"

# I subset the file to only include the nations in our final data.
UN_Population <- subset(UN_Population, is.element(UN_Population$COUNTRY, Temporary_Data_Country$COUNTRY))

# Lastly, I join the two dataframes. Note, we lose some observations using inner join (Western Sahara, West Bank and Gaza, MS Zaandam, Kosovo, Diamond Princess, and the Central African Republic.). However, we are not interested in these nations for the purposes of our sample.
Temporary_Data_Country <- inner_join(Temporary_Data_Country, UN_Population)

# This allows me to calculate our variable of interest: the mortality rate per capita (for both total deaths, and new deaths).
Temporary_Data_Country$Total_Mortality_Rate_Per_Capita = (Temporary_Data_Country$Total_Deceased_Country / Temporary_Data_Country$Population)

Temporary_Data_Country$New_Mortality_Rate_Per_Capita = (Temporary_Data_Country$New_Total_Deceased_Country / Temporary_Data_Country$Population)

# We might also be interested in cases per capita.
Temporary_Data_Country$Total_Cases_Country_Per_Capita = (Temporary_Data_Country$Total_Cases_Country / Temporary_Data_Country$Population)

# Lastly, I want to create a rolling average of the total and new mortality rates per capita, new confirmed cases, and new deaths. This is a bit complicated, so bear with me.

# First, I order the data by country and date.
Temporary_Data_Country <- Temporary_Data_Country[order(Temporary_Data_Country$COUNTRY, Temporary_Data_Country$Date),]

# I then construct a seven-day rolling average of confirmed cases, deaths, and both types of mortality rates by country.
Temporary_Data_Country <- Temporary_Data_Country %>%
  group_by(COUNTRY) %>%
  mutate(rolling_average_confirmed = frollmean(New_Confirmed_Country, 7))
Temporary_Data_Country <- Temporary_Data_Country %>%
  group_by(COUNTRY) %>%
  mutate(rolling_average_deceased= frollmean(New_Total_Deceased_Country, 7))
Temporary_Data_Country <- Temporary_Data_Country %>%
  group_by(COUNTRY) %>%
  mutate(total_rolling_average_mortality = frollmean(Total_Mortality_Rate_Per_Capita, 7))
Temporary_Data_Country <- Temporary_Data_Country %>%
  group_by(COUNTRY) %>%
  mutate(new_rolling_average_mortality = frollmean(New_Mortality_Rate_Per_Capita, 7))

# The seven-day rolling average works well, but the algorithm only gives an output after the first week (as we need seven prior values for the sake of our calculation). Ideally, we would want these missing values to have their own rolling averages (i.e. a rolling average of two days for the second date in our dataset; or a rolling average of five days for the fifth date). To do this, I first create a new dataframe with our missing values from the initial seven-day rolling average.
Missing_Mean_Confirmed <- Temporary_Data_Country[which(is.na(Temporary_Data_Country$rolling_average_confirmed)), ]
Missing_Mean_Total_Deceased_Country <- Temporary_Data_Country[which(is.na(Temporary_Data_Country$rolling_average_deceased)), ]
Missing_Mean_Total_Mortality <- Temporary_Data_Country[which(is.na(Temporary_Data_Country$total_rolling_average_mortality)), ]
Missing_Mean_New_Mortality <- Temporary_Data_Country[which(is.na(Temporary_Data_Country$new_rolling_average_mortality)), ]

# Next, I calculate a "new" rolling average for each of our nations, using the roll apply function. The syntax is complicated; but essentially this command allows the user the freedom to vary rolling averages by different "windows" of dates (i.e. three-day average vs. six-day average).
Missing_Mean_Confirmed <- Missing_Mean_Confirmed %>% 
  group_by(COUNTRY) %>%
  mutate(rolling_average_confirmed2 = rollapply(New_Confirmed_Country, 6, mean, na.rm = TRUE, fill = NA, align = 'right', partial=TRUE))
Missing_Mean_Total_Deceased_Country <- Missing_Mean_Total_Deceased_Country %>% 
  group_by(COUNTRY) %>%
  mutate(rolling_average_deceased2 = rollapply(New_Total_Deceased_Country, 6, mean, na.rm = TRUE, fill = NA, align = 'right', partial=TRUE))
Missing_Mean_Total_Mortality <- Missing_Mean_Total_Mortality %>% 
  group_by(COUNTRY) %>%
  mutate(total_rolling_average_mortality2 = rollapply(Total_Mortality_Rate_Per_Capita, 6, mean, na.rm = TRUE, fill = NA, align = 'right', partial=TRUE))
Missing_Mean_New_Mortality <- Missing_Mean_New_Mortality %>% 
  group_by(COUNTRY) %>%
  mutate(new_rolling_average_mortality2 = rollapply(New_Mortality_Rate_Per_Capita, 6, mean, na.rm = TRUE, fill = NA, align = 'right', partial=TRUE))

# We now want to merge this data back to our temporary file.
Temporary_Data_Country <- merge(Temporary_Data_Country, Missing_Mean_Confirmed, by = c("COUNTRY", "Date"), all=TRUE)
Temporary_Data_Country <- merge(Temporary_Data_Country, Missing_Mean_Total_Deceased_Country, by = c("COUNTRY", "Date"), all=TRUE)
Temporary_Data_Country <- merge(Temporary_Data_Country, Missing_Mean_Total_Mortality, by = c("COUNTRY", "Date"), all=TRUE)
Temporary_Data_Country <- merge(Temporary_Data_Country, Missing_Mean_New_Mortality, by = c("COUNTRY", "Date"), all=TRUE)

# Lastly, we can replace the missing values in our temporary file (for the confirmed rolling averages prior to one week) with the newly calculated "partial" rolling averages. We then replace all missing values with zero (the only missing values which remain are for our first day, when naturally no new cases will be recorded, or, in the case of our rolling average for the mortality rate, for dates in which we don't yet have a recorded case).
Temporary_Data_Country$rolling_average_confirmed.x[is.na(Temporary_Data_Country$rolling_average_confirmed.x)] <- Temporary_Data_Country$rolling_average_confirmed2[is.na(Temporary_Data_Country$rolling_average_confirmed.x)]
Temporary_Data_Country$rolling_average_confirmed.x[is.na(Temporary_Data_Country$rolling_average_confirmed.x)] <- 0
Temporary_Data_Country$rolling_average_confirmed <- Temporary_Data_Country$rolling_average_confirmed.x
Temporary_Data_Country$rolling_average_deceased.x[is.na(Temporary_Data_Country$rolling_average_deceased.x)] <- Temporary_Data_Country$rolling_average_deceased2[is.na(Temporary_Data_Country$rolling_average_deceased.x)]
Temporary_Data_Country$rolling_average_deceased.x[is.na(Temporary_Data_Country$rolling_average_deceased.x)] <- 0
Temporary_Data_Country$rolling_average_deceased <- Temporary_Data_Country$rolling_average_deceased.x
Temporary_Data_Country$total_rolling_average_mortality.x[is.na(Temporary_Data_Country$total_rolling_average_mortality.x)] <- Temporary_Data_Country$total_rolling_average_mortality2[is.na(Temporary_Data_Country$total_rolling_average_mortality.x)]
Temporary_Data_Country$total_rolling_average_mortality.x[is.na(Temporary_Data_Country$total_rolling_average_mortality.x)] <- 0
Temporary_Data_Country$total_rolling_average_mortality <- Temporary_Data_Country$total_rolling_average_mortality.x
Temporary_Data_Country$new_rolling_average_mortality.x[is.na(Temporary_Data_Country$new_rolling_average_mortality.x)] <- Temporary_Data_Country$new_rolling_average_mortality2[is.na(Temporary_Data_Country$new_rolling_average_mortality.x)]
Temporary_Data_Country$new_rolling_average_mortality.x[is.na(Temporary_Data_Country$new_rolling_average_mortality.x)] <- 0
Temporary_Data_Country$new_rolling_average_mortality <- Temporary_Data_Country$new_rolling_average_mortality.x

# I only keep columns we care about (which are not repetitive).
Temporary_Data_Country$Total_Cases_Country <- Temporary_Data_Country$Total_Cases_Country.x
Temporary_Data_Country$Total_Deceased_Country <- Temporary_Data_Country$Total_Deceased_Country.x
Temporary_Data_Country$New_Confirmed_Country <- Temporary_Data_Country$New_Confirmed_Country.x
Temporary_Data_Country$New_Total_Deceased_Country <- Temporary_Data_Country$New_Total_Deceased_Country.x
Temporary_Data_Country$Death_Rate <- Temporary_Data_Country$Death_Rate.x
Temporary_Data_Country$Total_Mortality_Rate_Per_Capita <- Temporary_Data_Country$Total_Mortality_Rate_Per_Capita.x
Temporary_Data_Country$New_Mortality_Rate_Per_Capita <- Temporary_Data_Country$New_Mortality_Rate_Per_Capita.x
Temporary_Data_Country$Location <- Temporary_Data_Country$Location.x
Temporary_Data_Country$Population <- Temporary_Data_Country$Population.x
Temporary_Data_Country$Total_Cases_Country_Per_Capita <- Temporary_Data_Country$Total_Cases_Country_Per_Capita.x
Temporary_Data_Country$rolling_average_confirmed <- Temporary_Data_Country$rolling_average_confirmed.x
Temporary_Data_Country$rolling_average_deceased <- Temporary_Data_Country$rolling_average_deceased.x
Temporary_Data_Country$total_rolling_average_mortality <- Temporary_Data_Country$total_rolling_average_mortality.x
Temporary_Data_Country$new_rolling_average_mortality <- Temporary_Data_Country$new_rolling_average_mortality.x

colnames(Temporary_Data_Country)
myvarstemp <- c("COUNTRY", "Date", "Total_Cases_Country", "Total_Deceased_Country", "New_Confirmed_Country", "New_Total_Deceased_Country", "Population", "Total_Mortality_Rate_Per_Capita", "New_Mortality_Rate_Per_Capita", "Total_Cases_Country_Per_Capita", "rolling_average_confirmed", "rolling_average_deceased", "total_rolling_average_mortality", "new_rolling_average_mortality")
Temporary_Data_Country <- Temporary_Data_Country[myvarstemp]

colnames(Temporary_Data_Country)
```

# Here, I add coordinates for each nation in the dataset.
```{r coordinates}
# When we collapse the COVID data to the country level, we lose our coordinate data. I now merge a dataset on global coordinates by country from: https://developers.google.com/public-data/docs/canonical/countries_csv. Note that I edited country names to match the data in the CSV itself. 

Country_Coordinates <- read.csv("COVID-19_Final/data/Country_Coordinates.csv")

Country_Coordinates$COUNTRY <- Country_Coordinates$Country

Country_Coordinates$latitude <- Country_Coordinates$Latitude 
Country_Coordinates$longitude <- Country_Coordinates$Longitude 

colnames(Country_Coordinates)
myvarscoords <- c("COUNTRY", "latitude", "longitude")
Country_Coordinates <- Country_Coordinates[myvarscoords]

# Lastly, I merge the two dataframes.
Temporary_Data_Country <- merge(Temporary_Data_Country, Country_Coordinates, by = c("COUNTRY"), all=TRUE)

```

# Labelling and saving our temporary data.
```{r labelling}
# I load the following two libraries in order to label our variables.
library(lattice)
library(Hmisc)

label(Temporary_Data_Country$Total_Cases_Country) <- "Cumulative Sum of Confirmed Cases by Country (John Hopkins)"
label(Temporary_Data_Country$Total_Deceased_Country) <- "Cumulative Sum of Deaths by Country (John Hopkins)"
label(Temporary_Data_Country$New_Confirmed_Country) <- "Daily Increase in Confirmed Cases (John Hopkins)"
label(Temporary_Data_Country$New_Total_Deceased_Country) <- "Daily Increase in Deaths (John Hopkins)"
label(Temporary_Data_Country$Total_Mortality_Rate_Per_Capita) <- "Total Deaths by Population (Total_Deceased_Country/Population)"
label(Temporary_Data_Country$New_Mortality_Rate_Per_Capita) <- "New Deaths by Population (New_Total_Deceased_Country/Population)"
label(Temporary_Data_Country$Total_Cases_Country_Per_Capita) <- "Total Cases by Population (Total_Cases_Country/Population)"
label(Temporary_Data_Country$rolling_average_confirmed) <- "Seven Day Rolling Average of New Confirmed Cases by Country (with the exception of Days 1-7)"
label(Temporary_Data_Country$rolling_average_deceased) <- "Seven Day Rolling Average of New Deaths by Country (with the exception of Days 1-7)"
label(Temporary_Data_Country$total_rolling_average_mortality) <- "Seven Day Rolling Average of Total Case Mortality Rate by Country (with the exception of Days 1-7)"
label(Temporary_Data_Country$new_rolling_average_mortality) <- "Seven Day Rolling Average of New Case Mortality Rate by Country (with the exception of Days 1-7)"

# This represents the "Temporary_Data_Country.csv" file saved in the data folder. I recommend you load in the CSV directly to ensure there are no discrepancies between the edits made in the Cloud, as opposed to my own R Project. I do this below.

# Removing the Cloud version of the Temporary Data.
remove(Temporary_Data_Country)

# Importing the Temporary Data from the data folder. 
Temporary_Data_Country <- read_csv("COVID-19_Final/data/Temporary_Data_Country.csv")
```

# Merging our government data and temporary data to create a final dataframe.
```{r final data}
# Now, I want to merge our temporary data with the Oxford dataset on global policy responses. Please see a description of the variables here: https://www.bsg.ox.ac.uk/sites/default/files/2020-04/BSG-WP-2020-032-v5.0_0.pdf. 
# The source is: Hale, Thomas, Anna Petherick, Toby Phillips, Samuel Webster. “Variation in Government Responses to COVID-19” Version 5.0. Blavatnik School of Government Working Paper. April 28, 2020. Available: www.bsg.ox.ac.uk/covidtracker.
# See https://www.bsg.ox.ac.uk/sites/default/files/Calculation%20and%20presentation%20of%20the%20Stringency%20Index.pdf for information on how the stringency index was calculated.

# 
Government_Responses <- read_csv("COVID-19_Final/data/Government_Responses.csv")

# First, I convert the date to a proper format.
Government_Responses$Date <- ymd(Government_Responses$Date, quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"),
  truncated = 0)
order(Government_Responses$Date)

# Then, I correct country and variable names.

Government_Responses$COUNTRY <- Government_Responses$CountryName
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Cape Verde", "Cabo Verde", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Congo", "Congo (Brazzaville)", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Democratic Republic of Congo", "Congo (Kinshasa)", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Myanmar", "Burma", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Czech Republic", "Czechia", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Swaziland", "Eswatini", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Krygz Republic", "Kyrgyzstan", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "South Korea", "Korea, South", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Macedonia", "North Macedonia", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Slovak Republic", "Slovakia", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Macedonia", "North Macedonia", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Taiwan", "Taiwan*", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Timor", "Timor-Leste", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "United States", "US", Government_Responses$COUNTRY)

colnames(Government_Responses)

Government_Responses$C1_School.closing <- Government_Responses$`C1_School closing`
Government_Responses$C2_Workplace.closing <- Government_Responses$`C2_Workplace closing`
Government_Responses$C3_Cancel.public.events <- Government_Responses$`C3_Cancel public events`
Government_Responses$C4_Restrictions.on.gatherings <- Government_Responses$`C4_Restrictions on gatherings`
Government_Responses$C5_Close.public.transport <- Government_Responses$`C5_Close public transport`
Government_Responses$C6_Stay.at.home.requirements <- Government_Responses$`C6_Stay at home requirements`
Government_Responses$C7_Restrictions.on.internal.movement <- Government_Responses$`C7_Restrictions on internal movement`
Government_Responses$C8_International.travel.controls <- Government_Responses$`C8_International travel controls`
Government_Responses$E1_Income.support <- Government_Responses$`E1_Income support`
Government_Responses$E2_Debt.contract.relief <- Government_Responses$`E2_Debt/contract relief`
Government_Responses$E3_Fiscal.measures <- Government_Responses$`E3_Fiscal measures`
Government_Responses$E4_International.support <- Government_Responses$`E4_International support`
Government_Responses$H1_Public.information.campaigns <- Government_Responses$`H1_Public information campaigns`
Government_Responses$H2_Testing.policy <- Government_Responses$`H2_Testing policy`
Government_Responses$H3_Contact.tracing <- Government_Responses$`H3_Contact tracing`
Government_Responses$H4_Emergency.investment.in.healthcare <- Government_Responses$`H4_Emergency investment in healthcare`
Government_Responses$H5_Investment.in.vaccines <- Government_Responses$`H5_Investment in vaccines`

# I now subset the data. PLEASE NOTE the observations change in this merge. Oxford began collecting data before Hopkins started tracking cases and deaths. For simplicity, I use the merged data from before to visualize the confirmed cases and deaths (as these dates are filtered correctly).
Government_Responses <- subset(Government_Responses, is.element(Government_Responses$COUNTRY, Temporary_Data_Country$COUNTRY))

# Note that we have two sets of variables for confirmed cases and deaths. The first, I label "Oxford_Cases" and "Oxford_Deaths". The second (from John Hopkins) I label "Total_Cases_Country" and "Total_Deceased_Country". At a later date, we might want to cross-reference these values. Note that Oxford does not provide calculations for province/state; however it is highly likely they used the (same) John Hopkins data.
Government_Responses$Oxford_Cases <- Government_Responses$ConfirmedCases
Government_Responses$Oxford_Deaths <- Government_Responses$ConfirmedDeaths

# Once more, I only keep the variables we are interested in. I elect not to keep the notes... these can be re-added if preferred. E4_International.support also has almost no values above 0, so it is dropped. 

colnames(Government_Responses)
myvarsgovernment <- c("COUNTRY", "Date", "C1_School.closing", "C1_Flag", "C2_Workplace.closing", "C2_Flag", "C3_Cancel.public.events", "C3_Flag", "C4_Restrictions.on.gatherings", "C4_Flag", "C5_Close.public.transport", "C5_Flag", "C6_Stay.at.home.requirements", "C6_Flag", "C7_Restrictions.on.internal.movement", "C7_Flag", "C8_International.travel.controls", "E1_Income.support", "E1_Flag", "E2_Debt.contract.relief", "E3_Fiscal.measures", "H1_Public.information.campaigns", "H1_Flag", "H2_Testing.policy", "H3_Contact.tracing", "H4_Emergency.investment.in.healthcare", "H5_Investment.in.vaccines", "M1_Wildcard", "StringencyIndex", "LegacyStringencyIndex", "Oxford_Cases", "Oxford_Deaths")

Government_Responses <- Government_Responses[myvarsgovernment]

# I then merge our data.
Final_Data_Country <- merge(Temporary_Data_Country, Government_Responses, by = c("COUNTRY", "Date"), all=TRUE)

# Next, I specify a set of lagged government response variables for use in our regression later (one-week, two-week, and three-week lags). First, I filter the data and create a lag function for each week (these functions are also used for generating the lags in our testing data).

Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

# This chunk of code is quite extensive. In our regressions, we use the "lag" function to generate lags for our key variables, rather than using the generated lagged variables below. I simply include them in order to visualize the dataframe with lags incorporated (as the lag function will simply lag existing variables in analysis; not generate new ones to explore). Using this function also allows us to observe which nations do not have enough observations to generate specified lags.

# One Week
Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C1_School.closing", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_School_Closing_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_School_Closing_One_Week <- as.factor(Final_Data_Country$Lagged_School_Closing_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C1_Flag", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_School_Closing_General_One_Week", keepInvalid = TRUE, reminder = FALSE)
  
Final_Data_Country$Lagged_School_Closing_General_One_Week <- as.factor(Final_Data_Country$Lagged_School_Closing_General_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C2_Workplace.closing", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Workplace_Closing_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Workplace_Closing_One_Week <- as.factor(Final_Data_Country$Lagged_Workplace_Closing_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C2_Flag", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Workplace_Closing_General_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Workplace_Closing_General_One_Week <- as.factor(Final_Data_Country$Lagged_Workplace_Closing_General_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C3_Cancel.public.events", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Events_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Public_Events_One_Week <- as.factor(Final_Data_Country$Lagged_Public_Events_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C3_Flag", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Events_General_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Public_Events_General_One_Week <- as.factor(Final_Data_Country$Lagged_Public_Events_General_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C4_Restrictions.on.gatherings", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Gatherings_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Gatherings_One_Week <- as.factor(Final_Data_Country$Lagged_Gatherings_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C4_Flag", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Gatherings_General_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Gatherings_General_One_Week <- as.factor(Final_Data_Country$Lagged_Gatherings_General_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C5_Close.public.transport", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Transport_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Public_Transport_One_Week <- as.factor(Final_Data_Country$Lagged_Public_Transport_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C5_Flag", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Transport_General_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Public_Transport_General_One_Week <- as.factor(Final_Data_Country$Lagged_Public_Transport_General_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C6_Stay.at.home.requirements", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Lockdown_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Lockdown_One_Week <- as.factor(Final_Data_Country$Lagged_Lockdown_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C6_Flag", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Lockdown_General_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Lockdown_General_One_Week <- as.factor(Final_Data_Country$Lagged_Lockdown_General_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C7_Restrictions.on.internal.movement", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Internal_Movement_One_Week", keepInvalid =   
  TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Internal_Movement_One_Week <- as.factor(Final_Data_Country$Lagged_Internal_Movement_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C7_Flag",slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Internal_Movement_General_One_Week", keepInvalid = TRUE, reminder =  FALSE)

Final_Data_Country$Lagged_Internal_Movement_General_One_Week <- as.factor(Final_Data_Country$Lagged_Internal_Movement_General_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C8_International.travel.controls", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_International_Travel_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_International_Travel_One_Week <- as.factor(Final_Data_Country$Lagged_International_Travel_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "E1_Income.support", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Income_Support_One_Week", keepInvalid =   
  TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Income_Support_One_Week <- as.factor(Final_Data_Country$Lagged_Income_Support_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "E1_Flag",slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Income_Support_General_One_Week", keepInvalid = TRUE, reminder =  FALSE)

Final_Data_Country$Lagged_Income_Support_General_One_Week <- as.factor(Final_Data_Country$Lagged_Income_Support_General_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "E2_Debt.contract.relief", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Debt_Relief_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Debt_Relief_One_Week <- as.factor(Final_Data_Country$Lagged_Debt_Relief_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "E3_Fiscal.measures", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Fiscal_Measures_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "H1_Public.information.campaigns", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Campaign_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Campaign_One_Week <- as.factor(Final_Data_Country$Lagged_Campaign_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "H1_Flag", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Campaign_General_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Campaign_General_One_Week <- as.factor(Final_Data_Country$Lagged_Campaign_General_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "H2_Testing.policy", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Testing_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Testing_One_Week <- as.factor(Final_Data_Country$Lagged_Testing_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "H3_Contact.tracing", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Tracing_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Tracing_One_Week <- as.factor(Final_Data_Country$Lagged_Tracing_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "H4_Emergency.investment.in.healthcare", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Health_Care_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "H5_Investment.in.vaccines", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Health_Care_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "StringencyIndex", TimeVar = "Date", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Stringency_Index_One_Week", keepInvalid 
  = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "LegacyStringencyIndex", TimeVar = "Date", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Legacy_Stringency_Index_One_Week", keepInvalid 
  = TRUE, reminder = FALSE)
  
# Two Weeks
Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C1_School.closing", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_School_Closing_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_School_Closing_Two_Weeks <- as.factor(Final_Data_Country$Lagged_School_Closing_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C1_Flag", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_School_Closing_General_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)
  
Final_Data_Country$Lagged_School_Closing_General_Two_Weeks <- as.factor(Final_Data_Country$Lagged_School_Closing_General_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C2_Workplace.closing", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Workplace_Closing_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Workplace_Closing_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Workplace_Closing_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C2_Flag", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Workplace_Closing_General_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Workplace_Closing_General_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Workplace_Closing_General_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C3_Cancel.public.events", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Events_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Public_Events_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Public_Events_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C3_Flag", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Events_General_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Public_Events_General_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Public_Events_General_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C4_Restrictions.on.gatherings", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Gatherings_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Gatherings_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Gatherings_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C4_Flag", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Gatherings_General_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Gatherings_General_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Gatherings_General_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C5_Close.public.transport", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Transport_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Public_Transport_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Public_Transport_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C5_Flag", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Transport_General_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Public_Transport_General_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Public_Transport_General_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C6_Stay.at.home.requirements", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Lockdown_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Lockdown_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Lockdown_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C6_Flag", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Lockdown_General_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Lockdown_General_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Lockdown_General_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C7_Restrictions.on.internal.movement", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Internal_Movement_Two_Weeks", keepInvalid =   
  TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Internal_Movement_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Internal_Movement_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C7_Flag",slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Internal_Movement_General_Two_Weeks", keepInvalid = TRUE, reminder =  FALSE)

Final_Data_Country$Lagged_Internal_Movement_General_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Internal_Movement_General_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C8_International.travel.controls", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_International_Travel_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_International_Travel_Two_Weeks <- as.factor(Final_Data_Country$Lagged_International_Travel_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "E1_Income.support", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Income_Support_Two_Weeks", keepInvalid =   
  TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Income_Support_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Income_Support_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "E1_Flag",slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Income_Support_General_Two_Weeks", keepInvalid = TRUE, reminder =  FALSE)

Final_Data_Country$Lagged_Income_Support_General_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Income_Support_General_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "E2_Debt.contract.relief", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Debt_Relief_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Debt_Relief_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Debt_Relief_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "E3_Fiscal.measures", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Fiscal_Measures_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "H1_Public.information.campaigns", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Campaign_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Campaign_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Campaign_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "H1_Flag", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Campaign_General_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Campaign_General_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Campaign_General_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "H2_Testing.policy", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Testing_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Testing_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Testing_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "H3_Contact.tracing", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Tracing_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Tracing_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Tracing_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "H4_Emergency.investment.in.healthcare", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Health_Care_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "H5_Investment.in.vaccines", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Health_Care_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "StringencyIndex", TimeVar = "Date", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Stringency_Index_Two_Weeks", keepInvalid 
  = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "LegacyStringencyIndex", TimeVar = "Date", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Legacy_Stringency_Index_Two_Weeks", keepInvalid 
  = TRUE, reminder = FALSE)

# Three Weeks
Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C1_School.closing", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_School_Closing_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_School_Closing_Three_Weeks <- as.factor(Final_Data_Country$Lagged_School_Closing_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C1_Flag", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_School_Closing_General_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)
  
Final_Data_Country$Lagged_School_Closing_General_Three_Weeks <- as.factor(Final_Data_Country$Lagged_School_Closing_General_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C2_Workplace.closing", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Workplace_Closing_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Workplace_Closing_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Workplace_Closing_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C2_Flag", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Workplace_Closing_General_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Workplace_Closing_General_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Workplace_Closing_General_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C3_Cancel.public.events", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Events_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Public_Events_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Public_Events_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C3_Flag", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Events_General_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Public_Events_General_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Public_Events_General_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C4_Restrictions.on.gatherings", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Gatherings_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Gatherings_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Gatherings_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C4_Flag", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Gatherings_General_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Gatherings_General_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Gatherings_General_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C5_Close.public.transport", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Transport_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Public_Transport_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Public_Transport_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C5_Flag", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Transport_General_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Public_Transport_General_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Public_Transport_General_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C6_Stay.at.home.requirements", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Lockdown_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Lockdown_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Lockdown_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C6_Flag", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Lockdown_General_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Lockdown_General_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Lockdown_General_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C7_Restrictions.on.internal.movement", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Internal_Movement_Three_Weeks", keepInvalid =   
  TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Internal_Movement_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Internal_Movement_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C7_Flag",slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Internal_Movement_General_Three_Weeks", keepInvalid = TRUE, reminder =  FALSE)

Final_Data_Country$Lagged_Internal_Movement_General_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Internal_Movement_General_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "C8_International.travel.controls", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_International_Travel_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_International_Travel_Three_Weeks <- as.factor(Final_Data_Country$Lagged_International_Travel_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "E1_Income.support", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Income_Support_Three_Weeks", keepInvalid =   
  TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Income_Support_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Income_Support_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "E1_Flag",slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Income_Support_General_Three_Weeks", keepInvalid = TRUE, reminder =  FALSE)

Final_Data_Country$Lagged_Income_Support_General_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Income_Support_General_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "E2_Debt.contract.relief", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Debt_Relief_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Debt_Relief_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Debt_Relief_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "E3_Fiscal.measures", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Fiscal_Measures_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "H1_Public.information.campaigns", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Campaign_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Campaign_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Campaign_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "H1_Flag", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Campaign_General_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Campaign_General_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Campaign_General_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "H2_Testing.policy", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Testing_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Testing_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Testing_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "H3_Contact.tracing", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Tracing_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Tracing_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Tracing_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "H4_Emergency.investment.in.healthcare", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Health_Care_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "H5_Investment.in.vaccines", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Health_Care_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "StringencyIndex", TimeVar = "Date", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Stringency_Index_Three_Weeks", keepInvalid 
  = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "LegacyStringencyIndex", TimeVar = "Date", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Legacy_Stringency_Index_Three_Weeks", keepInvalid 
  = TRUE, reminder = FALSE)
```

# Here, I add coordinates for each nation in the dataset.
```{r coordinates 2}
Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

# I am using the same Google coordinate data from: https://developers.google.com/public-data/docs/canonical/countries_csv. Note that I edited country names to match the data in the CSV itself (I only kept coordinates for nations in our dataframe). 
Country_Coordinates <- read.csv("COVID-19_Final/data/Country_Coordinates.csv")

Country_Coordinates$COUNTRY <- Country_Coordinates$Country

colnames(Country_Coordinates)
myvarscoords <- c("COUNTRY", "Latitude", "Longitude")
Country_Coordinates <- Country_Coordinates[myvarscoords]

# I subset the file to only include the nations in our final data.
Country_Coordinates <- subset(Country_Coordinates, is.element(Country_Coordinates$COUNTRY, Final_Data_Country$COUNTRY))

# Lastly, I merge the two dataframes.
Final_Data_Country <- merge(Final_Data_Country, Country_Coordinates, by = c("COUNTRY"), all=TRUE)

```

# Now, I add socioeconomic controls from the World Development Indicators.

```{r controls}
Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

# First, I add the proportion of the national population above 65 from: https://data.worldbank.org/indicator/SP.POP.65UP.TO.ZS. 
pop65yo <- read_csv("COVID-19_Final/data/pop65yo.csv")

pop65yo$COUNTRY <- pop65yo$country
pop65yo$prop65 <- pop65yo$value

# Next, I correct the country names.
pop65yo[19, "COUNTRY"] <- "Bahamas"
pop65yo[26, "COUNTRY"] <- "Brunei"
pop65yo[37, "COUNTRY"] <- "Congo (Kinshasa)"
pop65yo[38, "COUNTRY"] <- "Congo (Brazzaville)"
pop65yo[46, "COUNTRY"] <- "Czechia"
pop65yo[53, "COUNTRY"] <- "Egypt"
pop65yo[66, "COUNTRY"] <- "Gambia"
pop65yo[82, "COUNTRY"] <- "Iran"
pop65yo[95, "COUNTRY"] <- "Korea, South"
pop65yo[92, "COUNTRY"] <- "Kyrgyzstan"
pop65yo[97, "COUNTRY"] <- "Laos"
pop65yo[101, "COUNTRY"] <- "Saint Lucia"
pop65yo[116, "COUNTRY"] <- "Burma"
pop65yo[148, "COUNTRY"] <- "Russia"
pop65yo[162, "COUNTRY"] <- "Slovakia"
pop65yo[167, "COUNTRY"] <- "Syria"
pop65yo[182, "COUNTRY"] <- "US"
pop65yo[184, "COUNTRY"] <- "Saint Vincent and the Grenadines"
pop65yo[185, "COUNTRY"] <- "Venezuela"
pop65yo[186, "COUNTRY"] <- "Virgin Islands"
pop65yo[190, "COUNTRY"] <- "Yemen"
pop65yo[5, "COUNTRY"] <- "United Arab Emirates"
pop65yo[62, "COUNTRY"] <- "United Kingdom"
pop65yo[132, "COUNTRY"] <- "New Zealand"
pop65yo[150, "COUNTRY"] <- "Saudi Arabia"
pop65yo[191, "COUNTRY"] <- "South Africa"

pop65yo <- subset(pop65yo, is.element(pop65yo$COUNTRY, Final_Data_Country$COUNTRY))

# I only keep the columns I care about.
colnames(pop65yo)
myvarspop65yo <- c("prop65", "COUNTRY")

pop65yo <- pop65yo[myvarspop65yo]

pop65yo <- pop65yo[order(pop65yo$COUNTRY, pop65yo$prop65),]

Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

Final_Data_Country <- merge(Final_Data_Country, pop65yo, by = c("COUNTRY"), all=TRUE)

Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

# Now, I add another world development indicator for the proportion of the population which is urban: https://data.worldbank.org/indicator/SP.URB.TOTL.in.zs. 
urbanpp <- read_csv("COVID-19_Final/data/urbanpp.csv")

# Next, I correct the country names.
urbanpp[21, "COUNTRY"] <- "Bahamas"
urbanpp[29, "COUNTRY"] <- "Brunei"
urbanpp[40, "COUNTRY"] <- "Congo (Kinshasa)"
urbanpp[41, "COUNTRY"] <- "Congo (Brazzaville)"
urbanpp[50, "COUNTRY"] <- "Czechia"
urbanpp[58, "COUNTRY"] <- "Egypt"
urbanpp[73, "COUNTRY"] <- "Gambia"
urbanpp[91, "COUNTRY"] <- "Iran"
urbanpp[105, "COUNTRY"] <- "Korea, South"
urbanpp[101, "COUNTRY"] <- "Kyrgyzstan"
urbanpp[107, "COUNTRY"] <- "Laos"
urbanpp[111, "COUNTRY"] <- "Saint Lucia"
urbanpp[129, "COUNTRY"] <- "Burma"
urbanpp[164, "COUNTRY"] <- "Russia"
urbanpp[179, "COUNTRY"] <- "Slovakia"
urbanpp[185, "COUNTRY"] <- "Syria"
urbanpp[202, "COUNTRY"] <- "US"
urbanpp[204, "COUNTRY"] <- "Saint Vincent and the Grenadines"
urbanpp[205, "COUNTRY"] <- "Venezuela"
urbanpp[206, "COUNTRY"] <- "Virgin Islands"
urbanpp[211, "COUNTRY"] <- "Yemen"
urbanpp[6, "COUNTRY"] <- "United Arab Emirates"
urbanpp[68, "COUNTRY"] <- "United Kingdom"
urbanpp[147, "COUNTRY"] <- "New Zealand"
urbanpp[166, "COUNTRY"] <- "Saudi Arabia"
urbanpp[212, "COUNTRY"] <- "South Africa"

urbanpp <- subset(urbanpp, is.element(urbanpp$COUNTRY, Final_Data_Country$COUNTRY))

# I only keep the columns I care about.
colnames(urbanpp)
myvarsurbanpp <- c("propurban", "COUNTRY")

urbanpp <- urbanpp[myvarsurbanpp]

Final_Data_Country <- merge(Final_Data_Country, urbanpp, by = c("COUNTRY"), all=TRUE)

Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

# Now, I add the population density indicator. Note the latest year available for this data is 2018. 
popdensity <- read.csv("COVID-19_Final/data/popdensity.csv")
  
popdensity$COUNTRY <- popdensity$Country.Name

# Next, I correct the country names.
popdensity[22, "COUNTRY"] <- "Bahamas"
popdensity[30, "COUNTRY"] <- "Brunei"
popdensity[42, "COUNTRY"] <- "Congo (Kinshasa)"
popdensity[43, "COUNTRY"] <- "Congo (Brazzaville)"
popdensity[53, "COUNTRY"] <- "Czechia"
popdensity[66, "COUNTRY"] <- "Egypt"
popdensity[85, "COUNTRY"] <- "Gambia"
popdensity[111, "COUNTRY"] <- "Iran"
popdensity[125, "COUNTRY"] <- "Korea, South"
popdensity[121, "COUNTRY"] <- "Kyrgyzstan"
popdensity[128, "COUNTRY"] <- "Laos"
popdensity[132, "COUNTRY"] <- "Saint Lucia"
popdensity[159, "COUNTRY"] <- "Burma"
popdensity[201, "COUNTRY"] <- "Russia"
popdensity[220, "COUNTRY"] <- "Slovakia"
popdensity[226, "COUNTRY"] <- "Syria"
popdensity[250, "COUNTRY"] <- "US"
popdensity[252, "COUNTRY"] <- "Saint Vincent and the Grenadines"
popdensity[253, "COUNTRY"] <- "Venezuela"
popdensity[255, "COUNTRY"] <- "Virgin Islands"
popdensity[261, "COUNTRY"] <- "Yemen"
popdensity[7, "COUNTRY"] <- "United Arab Emirates"
popdensity[80, "COUNTRY"] <- "United Kingdom"
popdensity[179, "COUNTRY"] <- "New Zealand"
popdensity[204, "COUNTRY"] <- "Saudi Arabia"
popdensity[262, "COUNTRY"] <- "South Africa"

popdensity <- subset(popdensity, COUNTRY %in% Final_Data_Country$COUNTRY)

# I only keep the columns I care about.
colnames(popdensity)
myvarspopdensity <- c("popdensity", "COUNTRY")

popdensity <- popdensity[myvarspopdensity]

popdensity <- popdensity[order(popdensity$COUNTRY, popdensity$popdensity),]

Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

Final_Data_Country <- merge(Final_Data_Country, popdensity, by = c("COUNTRY"), all=TRUE)

Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]  
  
```

# Merging the testing data. 

***** This has been commented out for now, because of the poor quality of the data. However, the dataframe is updated with the newest results each time the chunk is run. If we want to re-implement testing in some way, we can uncomment and run this chunk. *****
```{r testing}
# Next, I add our testing data from:
# owurl = "https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/testing/covid-testing-all-observations.csv"
# testcap <- read_csv(url(owurl))
# testcap <- separate(testcap, Entity, into=c("Country", "Unit type"), sep = " - ") 
# write_csv(testcap, path = "/Users/sameernair-desai/Desktop/COVID-19_Final/data/testcap.csv")

# testcap$COUNTRY <- testcap$Country
# testcap$COUNTRY <- ifelse(testcap$COUNTRY == "Czech Republic", "Czechia", testcap$COUNTRY)
# testcap$COUNTRY <- ifelse(testcap$COUNTRY == "South Korea", "Korea, South", testcap$COUNTRY)
# testcap$COUNTRY <- ifelse(testcap$COUNTRY == "Taiwan", "Taiwan*", testcap$COUNTRY)
# testcap$COUNTRY <- ifelse(testcap$COUNTRY == "United States", "US", testcap$COUNTRY)
 
# testcap <- subset(testcap, is.element(testcap$COUNTRY, Final_Data_Country$COUNTRY))

# I don't like some of the variable names in the original data, so I change them below.
# testcap$Test_Type <- testcap$`Unit type`
# testcap$Cumulative_Tests <- testcap$`Cumulative total`
# testcap$Daily_Change_Cumulative_Tests <- testcap$`Daily change in cumulative total`
# testcap$Cumulative_Tests_Per_Thousand <- testcap$`Cumulative total per thousand`
# testcap$Daily_Change_Cumulative_Tests_Per_Thousand <- testcap$`Daily change in cumulative total per thousand`
# testcap$Three_Day_Rolling_Mean_Tests <- testcap$`3-day rolling mean daily change`
# testcap$Three_Day_Rolling_Mean_Tests_Per_Thousand <- testcap$`3-day rolling mean daily change per thousand`
# 
# Here, I keep the variables I care about.
# colnames(testcap)
# myvarstest <- c("COUNTRY", "Date", "Test_Type", "Cumulative_Tests", "Daily_Change_Cumulative_Tests", "Cumulative_Tests_Per_Thousand", "Daily_Change_Cumulative_Tests_Per_Thousand", "Three_Day_Rolling_Mean_Tests", "Three_Day_Rolling_Mean_Tests_Per_Thousand")

# testcap <- testcap[myvarstest]
 
# Now, I convert from long to wide format.
# testcap <- pivot_wider(testcap, id_cols = c("COUNTRY", "Date", "Test_Type"), names_from = "Test_Type", values_from = c("Cumulative_Tests", "Daily_Change_Cumulative_Tests", "Cumulative_Tests_Per_Thousand", "Daily_Change_Cumulative_Tests_Per_Thousand", "Three_Day_Rolling_Mean_Tests", "Three_Day_Rolling_Mean_Tests_Per_Thousand"))

# Now, I merge the data to our final file.
# Final_Data_Country <- merge(Final_Data_Country, testcap, by = c("COUNTRY", "Date"), all=TRUE)
```

# Merging the mobility data.

```{r mobility}
Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

# Here, I integrate the Apple Mobility data. 

mobility <- read.csv("COVID-19_Final/data/applemobilitytrends-2020-04-27.csv")

# First, we convert from wide to long format.
mobility <- pivot_longer(mobility, cols = starts_with("X"), names_to = "Dates")

# Next, we reformat the dates.
mobility$Dates<-sub(".", "", mobility$Dates)
mobility$Date <- mdy(mobility$Dates, quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"),
  truncated = 0)

# I only keep the variables we care about. I also filter for only countries (we can re-add cities at a later period).

mobility <- mobility %>%
  dplyr:: filter(mobility$geo_type == "country/region")

colnames(mobility)
myvarsmobility <- c("region", "transportation_type", "Date", "value")

mobility <- mobility[myvarsmobility]

mobility$COUNTRY <- mobility$region

# Now, I re-convert from long to wide format.
mobility <- pivot_wider(mobility, id_cols = c("COUNTRY", "Date", "transportation_type"), names_from = "transportation_type", values_from = c("value"))

# Next, we ensure the countries from the mobility file and our data align.

mobility$COUNTRY <- ifelse(mobility$COUNTRY == "Czech Republic", "Czechia", mobility$COUNTRY)
mobility$COUNTRY <- ifelse(mobility$COUNTRY == "Republic of Korea", "Korea, South", mobility$COUNTRY)
mobility$COUNTRY <- ifelse(mobility$COUNTRY == "Taiwan", "Taiwan*", mobility$COUNTRY)
mobility$COUNTRY <- ifelse(mobility$COUNTRY == "UK", "United Kingdom", mobility$COUNTRY)
mobility$COUNTRY <- ifelse(mobility$COUNTRY == "United States", "US", mobility$COUNTRY)

mobility <- subset(mobility, is.element(mobility$COUNTRY, Final_Data_Country$COUNTRY))

Final_Data_Country <- merge(Final_Data_Country, mobility, by = c("COUNTRY", "Date"), all=TRUE)

```

# Now, I add our controls for cross-country travel.
```{r travel}
Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

# First, I add information on the number of tourist arrivals (2018 is l.y.a.). Run this in the console
arrivals <- read.csv("COVID-19_Final/data/arrivals.csv")

arrivals$COUNTRY <- arrivals$Country.Name

# Next, I correct the country names.
arrivals[22, "COUNTRY"] <- "Bahamas"
arrivals[30, "COUNTRY"] <- "Brunei"
arrivals[42, "COUNTRY"] <- "Congo (Kinshasa)"
arrivals[43, "COUNTRY"] <- "Congo (Brazzaville)"
arrivals[53, "COUNTRY"] <- "Czechia"
arrivals[66, "COUNTRY"] <- "Egypt"
arrivals[85, "COUNTRY"] <- "Gambia"
arrivals[111, "COUNTRY"] <- "Iran"
arrivals[125, "COUNTRY"] <- "Korea, South"
arrivals[121, "COUNTRY"] <- "Kyrgyzstan"
arrivals[128, "COUNTRY"] <- "Laos"
arrivals[132, "COUNTRY"] <- "Saint Lucia"
arrivals[159, "COUNTRY"] <- "Burma"
arrivals[201, "COUNTRY"] <- "Russia"
arrivals[220, "COUNTRY"] <- "Slovakia"
arrivals[226, "COUNTRY"] <- "Syria"
arrivals[250, "COUNTRY"] <- "US"
arrivals[252, "COUNTRY"] <- "Saint Vincent and the Grenadines"
arrivals[253, "COUNTRY"] <- "Venezuela"
arrivals[255, "COUNTRY"] <- "Virgin Islands"
arrivals[261, "COUNTRY"] <- "Yemen"
arrivals[7, "COUNTRY"] <- "United Arab Emirates"
arrivals[80, "COUNTRY"] <- "United Kingdom"
arrivals[179, "COUNTRY"] <- "New Zealand"
arrivals[204, "COUNTRY"] <- "Saudi Arabia"
arrivals[262, "COUNTRY"] <- "South Africa"

arrivals <- subset(arrivals, COUNTRY %in% Final_Data_Country$COUNTRY)

# I only keep the columns I care about.
colnames(arrivals)
myvarsarrivals <- c("arrivals", "COUNTRY")

arrivals <- arrivals[myvarsarrivals]

Final_Data_Country <- merge(Final_Data_Country, arrivals, by = c("COUNTRY"), all=TRUE)

Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

# Next, I add information on tourism departures (2018 is l.y.a.). 
departures <- read.csv("COVID-19_Final/data/departures.csv")

departures$COUNTRY <- departures$Country.Name

# Next, I correct the country names.
departures[22, "COUNTRY"] <- "Bahamas"
departures[30, "COUNTRY"] <- "Brunei"
departures[42, "COUNTRY"] <- "Congo (Kinshasa)"
departures[43, "COUNTRY"] <- "Congo (Brazzaville)"
departures[53, "COUNTRY"] <- "Czechia"
departures[66, "COUNTRY"] <- "Egypt"
departures[85, "COUNTRY"] <- "Gambia"
departures[111, "COUNTRY"] <- "Iran"
departures[125, "COUNTRY"] <- "Korea, South"
departures[121, "COUNTRY"] <- "Kyrgyzstan"
departures[128, "COUNTRY"] <- "Laos"
departures[132, "COUNTRY"] <- "Saint Lucia"
departures[159, "COUNTRY"] <- "Burma"
departures[201, "COUNTRY"] <- "Russia"
departures[220, "COUNTRY"] <- "Slovakia"
departures[226, "COUNTRY"] <- "Syria"
departures[250, "COUNTRY"] <- "US"
departures[252, "COUNTRY"] <- "Saint Vincent and the Grenadines"
departures[253, "COUNTRY"] <- "Venezuela"
departures[255, "COUNTRY"] <- "Virgin Islands"
departures[261, "COUNTRY"] <- "Yemen"
departures[7, "COUNTRY"] <- "United Arab Emirates"
departures[80, "COUNTRY"] <- "United Kingdom"
departures[179, "COUNTRY"] <- "New Zealand"
departures[204, "COUNTRY"] <- "Saudi Arabia"
departures[262, "COUNTRY"] <- "South Africa"

departures <- subset(departures, COUNTRY %in% Final_Data_Country$COUNTRY)

# I only keep the columns I care about.
colnames(departures)
myvarsdepartures <- c("departures", "COUNTRY")

departures <- departures[myvarsdepartures]

Final_Data_Country <- merge(Final_Data_Country, departures, by = c("COUNTRY"), all=TRUE)

Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

```

# Now, I add additional country-specific characteristics gathered from the World Bank. All data is from 2018, unless noted.
```{r world bank}
Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

# First, I add the percentage of vulnerable employment by nation from: https://data.worldbank.org/indicator/SL.EMP.VULN.ZS?view=chart 
vulnerable_employment <- read.csv("COVID-19_Final/data/vulnerable_employment.csv")

# Next, I correct the country names.
vulnerable_employment[22, "COUNTRY"] <- "Bahamas"
vulnerable_employment[30, "COUNTRY"] <- "Brunei"
vulnerable_employment[42, "COUNTRY"] <- "Congo (Kinshasa)"
vulnerable_employment[43, "COUNTRY"] <- "Congo (Brazzaville)"
vulnerable_employment[53, "COUNTRY"] <- "Czechia"
vulnerable_employment[66, "COUNTRY"] <- "Egypt"
vulnerable_employment[85, "COUNTRY"] <- "Gambia"
vulnerable_employment[111, "COUNTRY"] <- "Iran"
vulnerable_employment[125, "COUNTRY"] <- "Korea, South"
vulnerable_employment[121, "COUNTRY"] <- "Kyrgyzstan"
vulnerable_employment[128, "COUNTRY"] <- "Laos"
vulnerable_employment[132, "COUNTRY"] <- "Saint Lucia"
vulnerable_employment[159, "COUNTRY"] <- "Burma"
vulnerable_employment[201, "COUNTRY"] <- "Russia"
vulnerable_employment[220, "COUNTRY"] <- "Slovakia"
vulnerable_employment[226, "COUNTRY"] <- "Syria"
vulnerable_employment[250, "COUNTRY"] <- "US"
vulnerable_employment[252, "COUNTRY"] <- "Saint Vincent and the Grenadines"
vulnerable_employment[253, "COUNTRY"] <- "Venezuela"
vulnerable_employment[255, "COUNTRY"] <- "Virgin Islands"
vulnerable_employment[261, "COUNTRY"] <- "Yemen"
vulnerable_employment[7, "COUNTRY"] <- "United Arab Emirates"
vulnerable_employment[80, "COUNTRY"] <- "United Kingdom"
vulnerable_employment[179, "COUNTRY"] <- "New Zealand"
vulnerable_employment[204, "COUNTRY"] <- "Saudi Arabia"
vulnerable_employment[262, "COUNTRY"] <- "South Africa"

vulnerable_employment <- subset(vulnerable_employment, COUNTRY %in% Final_Data_Country$COUNTRY)

# I only keep the columns I care about.
colnames(vulnerable_employment)
myvarsvulnerable_employment <- c("vul_emp", "COUNTRY")

vulnerable_employment <- vulnerable_employment[myvarsvulnerable_employment]

Final_Data_Country <- merge(Final_Data_Country, vulnerable_employment, by = c("COUNTRY"), all=TRUE)

Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

# Next, I add GNI per capita from: https://data.worldbank.org/indicator/NY.GNP.PCAP.CD?view=chart. 
GNI <- read.csv("COVID-19_Final/data/GNI.csv")

# Next, I correct the country names.
GNI[22, "COUNTRY"] <- "Bahamas"
GNI[30, "COUNTRY"] <- "Brunei"
GNI[42, "COUNTRY"] <- "Congo (Kinshasa)"
GNI[43, "COUNTRY"] <- "Congo (Brazzaville)"
GNI[53, "COUNTRY"] <- "Czechia"
GNI[66, "COUNTRY"] <- "Egypt"
GNI[85, "COUNTRY"] <- "Gambia"
GNI[111, "COUNTRY"] <- "Iran"
GNI[125, "COUNTRY"] <- "Korea, South"
GNI[121, "COUNTRY"] <- "Kyrgyzstan"
GNI[128, "COUNTRY"] <- "Laos"
GNI[132, "COUNTRY"] <- "Saint Lucia"
GNI[159, "COUNTRY"] <- "Burma"
GNI[201, "COUNTRY"] <- "Russia"
GNI[220, "COUNTRY"] <- "Slovakia"
GNI[226, "COUNTRY"] <- "Syria"
GNI[250, "COUNTRY"] <- "US"
GNI[252, "COUNTRY"] <- "Saint Vincent and the Grenadines"
GNI[253, "COUNTRY"] <- "Venezuela"
GNI[255, "COUNTRY"] <- "Virgin Islands"
GNI[261, "COUNTRY"] <- "Yemen"
GNI[7, "COUNTRY"] <- "United Arab Emirates"
GNI[80, "COUNTRY"] <- "United Kingdom"
GNI[179, "COUNTRY"] <- "New Zealand"
GNI[204, "COUNTRY"] <- "Saudi Arabia"
GNI[262, "COUNTRY"] <- "South Africa"

GNI <- subset(GNI, COUNTRY %in% Final_Data_Country$COUNTRY)

# I only keep the columns I care about.
colnames(GNI)
myvarsGNI <- c("GNI", "COUNTRY")

GNI <- GNI[myvarsGNI]

Final_Data_Country <- merge(Final_Data_Country, GNI, by = c("COUNTRY"), all=TRUE)

Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

# Next, I control for current health expenditures (l.y.a. is 2017): https://data.worldbank.org/indicator/SH.XPD.CHEX.PC.CD?view=chart. 
health_pc <- read.csv("COVID-19_Final/data/health_pc.csv")

# Next, I correct the country names.
health_pc[22, "COUNTRY"] <- "Bahamas"
health_pc[30, "COUNTRY"] <- "Brunei"
health_pc[42, "COUNTRY"] <- "Congo (Kinshasa)"
health_pc[43, "COUNTRY"] <- "Congo (Brazzaville)"
health_pc[53, "COUNTRY"] <- "Czechia"
health_pc[66, "COUNTRY"] <- "Egypt"
health_pc[85, "COUNTRY"] <- "Gambia"
health_pc[111, "COUNTRY"] <- "Iran"
health_pc[125, "COUNTRY"] <- "Korea, South"
health_pc[121, "COUNTRY"] <- "Kyrgyzstan"
health_pc[128, "COUNTRY"] <- "Laos"
health_pc[132, "COUNTRY"] <- "Saint Lucia"
health_pc[159, "COUNTRY"] <- "Burma"
health_pc[201, "COUNTRY"] <- "Russia"
health_pc[220, "COUNTRY"] <- "Slovakia"
health_pc[226, "COUNTRY"] <- "Syria"
health_pc[250, "COUNTRY"] <- "US"
health_pc[252, "COUNTRY"] <- "Saint Vincent and the Grenadines"
health_pc[253, "COUNTRY"] <- "Venezuela"
health_pc[255, "COUNTRY"] <- "Virgin Islands"
health_pc[261, "COUNTRY"] <- "Yemen"
health_pc[7, "COUNTRY"] <- "United Arab Emirates"
health_pc[80, "COUNTRY"] <- "United Kingdom"
health_pc[179, "COUNTRY"] <- "New Zealand"
health_pc[204, "COUNTRY"] <- "Saudi Arabia"
health_pc[262, "COUNTRY"] <- "South Africa"

health_pc <- subset(health_pc, COUNTRY %in% Final_Data_Country$COUNTRY)

# I only keep the columns I care about.
colnames(health_pc)
myvarshealth_pc <- c("health_exp", "COUNTRY")

health_pc <- health_pc[myvarshealth_pc]

Final_Data_Country <- merge(Final_Data_Country, health_pc, by = c("COUNTRY"), all=TRUE)

Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

# I also add data on air pollution by nation from: https://data.worldbank.org/indicator/EN.ATM.PM25.MC.M3?view=chart. 
pollution <- read.csv("COVID-19_Final/data/pollution.csv")

# Next, I correct the country names.
pollution[22, "COUNTRY"] <- "Bahamas"
pollution[30, "COUNTRY"] <- "Brunei"
pollution[42, "COUNTRY"] <- "Congo (Kinshasa)"
pollution[43, "COUNTRY"] <- "Congo (Brazzaville)"
pollution[53, "COUNTRY"] <- "Czechia"
pollution[66, "COUNTRY"] <- "Egypt"
pollution[85, "COUNTRY"] <- "Gambia"
pollution[111, "COUNTRY"] <- "Iran"
pollution[125, "COUNTRY"] <- "Korea, South"
pollution[121, "COUNTRY"] <- "Kyrgyzstan"
pollution[128, "COUNTRY"] <- "Laos"
pollution[132, "COUNTRY"] <- "Saint Lucia"
pollution[159, "COUNTRY"] <- "Burma"
pollution[201, "COUNTRY"] <- "Russia"
pollution[220, "COUNTRY"] <- "Slovakia"
pollution[226, "COUNTRY"] <- "Syria"
pollution[250, "COUNTRY"] <- "US"
pollution[252, "COUNTRY"] <- "Saint Vincent and the Grenadines"
pollution[253, "COUNTRY"] <- "Venezuela"
pollution[255, "COUNTRY"] <- "Virgin Islands"
pollution[261, "COUNTRY"] <- "Yemen"
pollution[7, "COUNTRY"] <- "United Arab Emirates"
pollution[80, "COUNTRY"] <- "United Kingdom"
pollution[179, "COUNTRY"] <- "New Zealand"
pollution[204, "COUNTRY"] <- "Saudi Arabia"
pollution[262, "COUNTRY"] <- "South Africa"

pollution <- subset(pollution, COUNTRY %in% Final_Data_Country$COUNTRY)

# I only keep the columns I care about.
colnames(pollution)
myvarspollution <- c("pollution", "COUNTRY")

pollution <- pollution[myvarspollution]

Final_Data_Country <- merge(Final_Data_Country, pollution, by = c("COUNTRY"), all=TRUE)

# Here, I add democracy indicators from Freedom House: https://freedomhouse.org/countries/freedom-world/scores and the Economist: https://www.eiu.com/topic/democracy-index?&zid=democracyindex2019&utm_source=blog&utm_medium=blog&utm_name=democracyindex2019&utm_term=democracyindex2019&utm_content=top_link. 

democracy <- read.csv("COVID-19_Final/data/democracy.csv")

democracy <- subset(democracy, COUNTRY %in% Final_Data_Country$COUNTRY)

# I only keep the columns I care about.
colnames(democracy)
myvarsdemocracy <- c("EUI_democracy", "freedom_house", "COUNTRY")

democracy <- democracy[myvarsdemocracy]

Final_Data_Country <- merge(Final_Data_Country, democracy, by = c("COUNTRY"), all=TRUE)

# Here, I add data on the number of cellular subscriptions by nation from: https://data.worldbank.org/indicator/IT.CEL.SETS.P2?start=1960.

cellular <- read.csv("COVID-19_Final/data/cellular.csv")

cellular <- subset(cellular, COUNTRY %in% Final_Data_Country$COUNTRY)

# I only keep the columns I care about.
colnames(cellular)
myvarscellular <- c("cellular_sub", "COUNTRY")

cellular <- cellular[myvarscellular]

Final_Data_Country <- merge(Final_Data_Country, cellular, by = c("COUNTRY"), all=TRUE)

# Now, I add military data from: https://correlatesofwar.org/data-sets/national-material-capabilities. Note the l.y.a. is 2012.

military <- read.csv("COVID-19_Final/data/military.csv")

military <- subset(military, COUNTRY %in% Final_Data_Country$COUNTRY)

# I only keep the columns I care about.
colnames(military)
myvarsmilitary <- c("milex", "milper", "irst", "pec", "cinc", "COUNTRY")

military <- military[myvarsmilitary]

Final_Data_Country <- merge(Final_Data_Country, military, by = c("COUNTRY"), all=TRUE)

```

# Adding data on prior deaths from diseases.
```{r diseases}
# I now add data on diseases (aggregated from 2015-2018) from the WHO ICD10: https://www.who.int/classifications/icd/icdonlineversions/en/. 
diseases <- read.csv("COVID-19_Final/data/ICD_Deaths_Final.csv")

diseases <- subset(diseases, COUNTRY %in% Final_Data_Country$COUNTRY)

Final_Data_Country <- merge(Final_Data_Country, diseases, by = c("COUNTRY"), all=TRUE)

Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]
```

# Performing final edits and saving the dataframe (plus filtering the sample).
```{r editing}
# Labelling our variables.
label(Final_Data_Country$C1_School.closing) <- "Record Closings of Schools and Universities (0 - No Measures; 1 - Recommended Closing; 2 - Required Closing (some levels); 3 - Required Closing (all levels))"
label(Final_Data_Country$C1_Flag) <- "Targeted vs. General School Closings (0 - Targeted; 1 - General)"
label(Final_Data_Country$C2_Workplace.closing) <- "Record Closings of Workplaces (0 - No Measures; 1 - Recommended Closing; 2 - Required Closing (some sectors); 3 - Required Closing (all but essential workers))"
label(Final_Data_Country$C2_Flag) <- "Targeted vs. General Workplace Closings (0 - Targeted; 1 - General)"
label(Final_Data_Country$C3_Cancel.public.events) <- "Record Closings of Public Events (0 - No Measures; 1 - Recommended Cancelling; 2 - Required Cancelling)"
label(Final_Data_Country$C3_Flag) <- "Targeted vs. General Public Event Closings (0 - Targeted; 1 - General)"
label(Final_Data_Country$C4_Restrictions.on.gatherings) <- "Restrictions on Public Gatherings (0 - No Measures; 1 - Restrictions on Gatherings of 1000 + people; 2 - Restrictions on Gatherings of 100-1000 people; 3 - Restrictions on Gatherings of 10-100 people; 4 - Restrictions on Gatherings of < 10 people)"
label(Final_Data_Country$C4_Flag) <- "Targeted vs. General Public Gathering Restrictions (0 - Targeted; 1 - General)"
label(Final_Data_Country$C5_Close.public.transport) <- "Record Closings of Public Transport (0 - No Measures; 1 - Recommended Closing (means of transport reduced); 2 - Required Closing (prohibit public transit operations))"
label(Final_Data_Country$C5_Flag) <- "Targeted vs. General Public Transport Closings (0 - Targeted; 1 - General)"
label(Final_Data_Country$C6_Stay.at.home.requirements) <- "Lockdown Measures (0 - No Measures; 1 - Recommendeded; 2 - Lax Lockdown (allows for exercise, shopping, and essential trips); 3 - Strict Lockdown)"
label(Final_Data_Country$C6_Flag) <- "Targeted vs. General Lockdown (0 - Targeted; 1 - General)"
label(Final_Data_Country$C7_Restrictions.on.internal.movement) <- "Record Restrictions on Internal Movement (0 - No Measures; 1 - Recommend Movement Restriction (reduce means of transport); 2 - Restrict Movement (prohibit internal movement))"
label(Final_Data_Country$C7_Flag) <- "Targeted vs. General Restrictions on Internal Movement (0 - Targeted; 1 - General)"
label(Final_Data_Country$C8_International.travel.controls) <- "Record Restrictions on International Travel (0 - No Measures; 1 - Screening; 2 - Quarantine on High-Risk Regions; 3 - Ban on High-Risk Regions)"
label(Final_Data_Country$E1_Income.support) <- "Income Support (0 - None; 1 - Govt. Funds < 50% of Lost Salary; 2 - Govt. Funds > 50% of Lost Salary)"
label(Final_Data_Country$E1_Flag) <- "Targeted vs. General Income Support"
label(Final_Data_Country$E2_Debt.contract.relief) <- "Debt Relief (0 - None; 1 - Narrow Relief (specific kinds of contracts); 2 - Broad Relief)"
label(Final_Data_Country$E3_Fiscal.measures) <- "Value of Fiscal Stimuli, Including Spending or Tax Cuts (in USD)"
label(Final_Data_Country$H1_Public.information.campaigns) <- "Record Presence of Public Information Campaigns (0 - No; 1 - Public Officials Urge Caution; 2 - Coordinated Public Information Campaign)"
label(Final_Data_Country$H1_Flag) <- "Targeted vs. General Public Information Campaigns (0 - Targeted; 1 - General)"
label(Final_Data_Country$H2_Testing.policy) <- "Who Can Get Tested (0 - No Testing Policy; 1 - Testing for those with a) Symptoms AND b) Meet Given Criteria (key workers; admitted to hospital; came into contact with known patient; returned from overseas); 2 - Testing of anyone showing symptoms; 3 - Open Public Testing ('drive-through testing')"
label(Final_Data_Country$H3_Contact.tracing) <- "Contact Tracing (0 - No Contact Tracing; 1 - Limited Contact Tracing; 2 - Comprehensive Contact Tracing)"
label(Final_Data_Country$H4_Emergency.investment.in.healthcare) <- "Value of New Short-Term Spending on Health (in USD)"
label(Final_Data_Country$H5_Investment.in.vaccines) <- "Value of Investment (in USD)"
label(Final_Data_Country$StringencyIndex) <- "Index for Government Stringency (calculated using C1-S8 + H1)"
label(Final_Data_Country$LegacyStringencyIndex) <- "Legacy Index for Government Stringency (converts new calculation to prior calculation for our 'original' Stringency Index)"
label(Final_Data_Country$Oxford_Cases) <- "Cumulative Sum of Confirmed Cases by Country (Oxford)"
label(Final_Data_Country$Oxford_Deaths) <- "Cumulative Sum of Deaths by Country (Oxford)"
label(Final_Data_Country$prop65) <- "Proportion of the Population Above Age 65"
label(Final_Data_Country$propurban) <- "Proportion of Population in Urban Areas"
label(Final_Data_Country$popdensity) <- "People per 100 Sq. Km. of Land Area"
label(Final_Data_Country$arrivals) <- "Number of Tourist Arrivals"
label(Final_Data_Country$departures) <- "Number of Tourist Departures"
label(Final_Data_Country$vul_emp) <- "Percentage of Population in Vulnerable Employment"
label(Final_Data_Country$GNI) <- "GNI per capita (current USD - Atlas Method) "
label(Final_Data_Country$health_exp) <- "Health Expenditure Per Capita"
label(Final_Data_Country$pollution) <- "PM2.5 Air Pollution (micrograms per cubic meter)"
label(Final_Data_Country$EUI_democracy) <- "Democracy scores from the Economist Intelligence Unit"
label(Final_Data_Country$freedom_house) <- "Democracy scores from Freedom House"
label(Final_Data_Country$milex) <- "Military expenditures (thousands of GBP)"
label(Final_Data_Country$milper) <- "Military personnel (thousands of soldiers)"
label(Final_Data_Country$irst) <- "Iron and steel production (thousands of ton)"
label(Final_Data_Country$pec) <- "Primary energy consumption (thousands of coal-ton equivalents)"
label(Final_Data_Country$cinc) <- "Composite Index of National Capability score"

# For now, we are restricting our analysis to OECD/EM markets. I do so below, using a loose definition of EMs from: https://www.msci.com/documents/10199/c0db0a48-01f2-4ba9-ad01-226fd5678111 and advanced economies from: https://www.imf.org/external/pubs/ft/weo/2020/01/weodata/groups.htm. Provinces of China (Taiwan, Macao, Hong Kong) and Italy (San Marino) are aggregated to the national level. Note that Lithuania, while included here for visualizations, does not have government responses data and is thus not run in the regressions.

Final_Data_Country <- subset(Final_Data_Country, (COUNTRY == "Argentina" | COUNTRY == "Australia" | COUNTRY == "Austria" | COUNTRY == "Belgium" | COUNTRY == "Brazil" | COUNTRY == "Canada" | COUNTRY == "Chile" | COUNTRY == "China" | COUNTRY == "Colombia" | COUNTRY == "Cyprus" | COUNTRY == "Czechia" |COUNTRY == "Denmark" | COUNTRY == "Egypt" | COUNTRY == "Estonia" | COUNTRY == "Finland" | COUNTRY == "France" | COUNTRY == "Germany" | COUNTRY == "Greece" | COUNTRY == "Hungary" | COUNTRY == "Iceland" | COUNTRY == "India" | COUNTRY == "Indonesia" | COUNTRY == "Ireland" | COUNTRY == "Israel" | COUNTRY == "Italy" | COUNTRY == "Japan" | COUNTRY == "Jordan" | COUNTRY == "Korea, South" | COUNTRY == "Kuwait" | COUNTRY == "Latvia" | COUNTRY == "Lithuania" | COUNTRY == "Luxembourg" | COUNTRY == "Malaysia" | COUNTRY == "Malta" | COUNTRY == "Mexico" | COUNTRY == "Morocco" | COUNTRY == "Netherlands" | COUNTRY == "New Zealand" |COUNTRY == "Norway" | COUNTRY == "Peru" | COUNTRY == "Philippines" | COUNTRY == "Poland" | COUNTRY == "Portugal" | COUNTRY == "Qatar" | COUNTRY == "Russia" | COUNTRY == "Saudi Arabia" | COUNTRY == "Singapore" | COUNTRY == "Slovakia" | COUNTRY == "Slovenia" |  COUNTRY == "South Africa" | COUNTRY == "Spain" | COUNTRY == "Sweden" | COUNTRY == "Switzerland" | COUNTRY == "Thailand" | COUNTRY == "Turkey" | COUNTRY == "United Arab Emirates" | COUNTRY == "United Kingdom" | COUNTRY == "US" | COUNTRY == "Vietnam"))

# Next, I label and clean the final dataset. This is excluded for brevity.
```

# We now have a final panel dataset. I import the saved CSV, to ensure there are no discrepancies.
```{r saving}
remove(Final_Data_Country)

#  Note that I change the column types so reader can properly parse the data. This dataset also includes lagged variables for the mortality rate, which are not generated in the code for brevity.

library(readr)
Final_Data_Country <- read_csv(("COVID-19_Final/data/Final_Data_Country.csv"), 
  col_types = cols(`E2_Debt.contract.relief` = col_number(),
                   `Lagged_Debt_Relief_One_Week` = col_number(),
                   `Lagged_Debt_Relief_Two_Weeks` = col_number(),
                   `Lagged_Debt_Relief_Three_Weeks` = col_number(),
                   `E1_Income.support` = col_number(),
                   `Lagged_Income_Support_One_Week` = col_number(),
                   `Lagged_Income_Support_Two_Weeks` = col_number(),
                   `Lagged_Income_Support_Three_Weeks` = col_number()))
Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

```

# Adding data on government indicators.
```{r government}
# I now add data on government indicators from: https://info.worldbank.org/governance/wgi/Home/Documents. 
govt <- read.csv("COVID-19_Final/data/govt.csv")

govt <- subset(govt, COUNTRY %in% Final_Data_Country$COUNTRY)

Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

Final_Data_Country <- merge(Final_Data_Country, govt, by = c("COUNTRY"), all=TRUE)

Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]
```

# Next, I want to merge the spatial data. We do this after the final dataset has been filtered, to ensure a smaller dataset size.
```{r spatial}
# Now, we want to integrate our spatial datasets from CEPII. 

geo_cepii <- read_csv("COVID-19_Final/data/spatial_data/geo_cepii.csv")

# We only have country-level information for our COVID data. So, we want to collapse the geo_cepii data to the country level, without losing the local variation provided by our coordinates and distances for city indicators. However, in the case where we have multiple cities per country, we must make a decision on how to collapse. I choose to only keep the capital cities, and collapse by countries in this way.

geo_cepii_final <- geo_cepii %>%
  dplyr:: filter(geo_cepii$cap == 1)

geo_cepii_final$COUNTRY <- geo_cepii_final$country
geo_cepii_final$City <- geo_cepii_final$city_en
geo_cepii_final$City_Latitude <- geo_cepii_final$lat
geo_cepii_final$City_Longitude <- geo_cepii_final$lon
geo_cepii_final$Capital <- geo_cepii_final$cap

# Below, I create a new dataframe for merging the geo_cepii data with the distance_cepii data.
geo_cepii_merge <- geo_cepii_final[c(2,35)]

# Now, I read in the distance_cepii data. 
distance_cepii <- read_csv("COVID-19_Final/data/spatial_data/distance_cepii.csv")

# We want to merge by both ISO values, and match the ISOs to country names. I do this below.
geo_cepii_merge$iso_d <- geo_cepii_merge$iso3

merge_1 <- merge(geo_cepii_merge, distance_cepii, by = c("iso_d"), all=TRUE)

geo_cepii_merge$iso_o <- geo_cepii_merge$iso_d

merge_2 <- merge(geo_cepii_merge, merge_1, by = c("iso_o"), all=TRUE)

merge_2$COUNTRY <- merge_2$COUNTRY.x
merge_2$COUNTRY_Dyad <- merge_2$COUNTRY.y

colnames(merge_2)

Cepii_Data_Final <- merge(geo_cepii_final, merge_2, by = c("COUNTRY"), all=TRUE)

# I keep only the relevant variables.

myvarscepiifinal <- c("COUNTRY", "COUNTRY_Dyad", "dist", "distcap", "distw", "distwces", "area", "dis_int", "landlocked", "continent", "City", "City_Latitude", "City_Longitude", "Capital", "maincity", "langoff_1", "langoff_2", "langoff_3", "lang20_1", "lang20_2", "lang20_3", "lang20_4", "lang9_1", "lang9_2", "lang9_3", "lang9_4", "colonizer1", "colonizer2", "colonizer3", "colonizer4", "short_colonizer1", "short_colonizer2", "short_colonizer3", "contig", "comlang_off", "comlang_ethno", "colony", "comcol", "curcol", "col45", "smctry")

Cepii_Data_Final <- Cepii_Data_Final[myvarscepiifinal]

label(Cepii_Data_Final$landlocked) <- "Dummy Variable for Landlocked (0 = No; 1 = Yes)"
label(Cepii_Data_Final$Capital) <- "Dummy Variable for City being Capital City (0 = No; 1 = Yes)"
label(Cepii_Data_Final$maincity) <- "Dummy Variable for City being Main City (0 = No; 1 = Yes)"

# Next, we want to merge our spatial data from CEPII to our COVID dataset. I don't do this here do the size of the resulting file, and the runtime. If you wish to view the merged file, see "Spatial_Merged.csv" in the spatial_data folder.
```

## INTERACTIVE VISUALIZATIONS

```{r initial marker (confirmed) - January 23rd, 2020}
# I start by making a marker map which captures the number of confirmed cases on the first date of recorded data. To isolate these values, we must filter the dataframe to include observations for this date.

X1.23.20 <- Temporary_Data_Country %>%
  dplyr:: filter(Date == "2020-01-23")

# First, I want to visualize the "relative intensity" of cases across the world (using a consistent scale). To do this, I cut my variable into six quantiles, based on the values of confirmed cases from the LAST available date (3-31-20).
X1.23.20$magrangeconfirmed = cut(X1.23.20$Total_Cases_Country,
                          breaks = c(0, 1000, 10000, 100000, 250000, 500000, 1025000),
                          right=FALSE, labels = c("Very Low [0-1000)", "Low     
                          [1000-10000)", "Moderate [10000-100000)", "High [100000-250000)",
                          "Very High [250000-500000)", "Extreme [500000-1025000]"))

# I also want to jitter the latitude and longitude of my data points, in case our observations are clustered. We want to introduce a jitter which is large enough to differentiate markers, but not so large as to affect our spatial accuracy. I use a factor of 1.
X1.23.20$Lat <- jitter(X1.23.20$Latitude, factor = 1)
X1.23.20$Long <- jitter(X1.23.20$Longitude, factor = 1)

# To ease the user's interpretation of our data, we want to create an interactive label which provides information on each data point when the user hovers over the markers.
X1.23.20$labelconfirmed <- paste ("<Country: >", X1.23.20$COUNTRY, "<p>",
                         "<Confirmed Cases: >", X1.23.20$Total_Cases_Country, "<p>")

# Finally, we can construct our initial marker map. First, I set different colors for each quantile.
pal = colorFactor(palette = c("#CCCCCC", "#999999", "#99FF33", "#FFCC33", "#FF6600", "#990000"), domain=X1.23.20$magrangeconfirmed)

# Now, I pass the data through leaflet and generate the map.
Plot_1 <- leaflet(data=X1.23.20) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addCircleMarkers(data=X1.23.20, lng = ~longitude, lat = ~latitude,
                 # Here, I add the color pallete to shade the markers by intensity.
                 color = ~ pal(magrangeconfirmed),
                 weight = 5,
                 radius = 10,
                 label = lapply(X1.23.20$labelconfirmed, HTML),
                 clusterOptions = markerClusterOptions()) %>%
addLegend("bottomright", pal = pal, values = ~magrangeconfirmed,
    title = "Total Confirmed Cases - COVID19 (January 23rd, 2020)",
    opacity = 1)
Plot_1
```

```{r initial marker (deceased) - January 23rd, 2020}
# Now, I repeat the process for deaths. Note that in both of these maps, we see low values (which makes sense, given this was the start of the pandemic).
X1.23.20$magrangedeceased = cut(X1.23.20$Total_Deceased_Country,
                          breaks = c(0, 100, 500, 1000, 5000, 25000, 60000), right=FALSE,
                          labels = c("Very Low [0-100)", "Low [100-500)", "Moderate [500-1000)", "High [1000-5000)", "Very High   
                                     [5000-25000)", "Extreme [25000-60000]"))
X1.23.20$Lat <- jitter(X1.23.20$Latitude, factor = 1)
X1.23.20$Long <- jitter(X1.23.20$Longitude, factor = 1)
X1.23.20$labeldeceased <- paste ("<Country: >", X1.23.20$COUNTRY, "<p>",
                         "<Deceased: >", X1.23.20$Total_Deceased_Country, "<p>")
pal = colorFactor(palette = c("#CCCCCC", "#999999", "#99FF33", "#FFCC33", "#FF6600", "#990000"), domain=X1.23.20$magrangedeceased)
Plot_2 <- leaflet(data=X1.23.20) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addCircleMarkers(data=X1.23.20, lng = ~longitude, lat = ~latitude,
                 color = ~ pal(magrangedeceased),
                 weight = 5,
                 radius = 10,
                 label = lapply(X1.23.20$labeldeceased, HTML),
                 clusterOptions = markerClusterOptions()) %>%
addLegend("bottomright", pal = pal, values = ~magrangedeceased,
    title = "Total Deaths - COVID19 (January 23rd, 2020)",
    opacity = 1)
Plot_2
```

```{r last marker (confirmed) - April 28th, 2020}
# Now, I repeat the same procedure for the last date in our dataset.
X4.28.20 <- Temporary_Data_Country %>%
  dplyr:: filter(Date == "2020-04-28")

X4.28.20$magrangeconfirmed2 = cut(X4.28.20$Total_Cases_Country, 
                          breaks = c(0, 1000, 10000, 100000, 250000, 500000, 1025000),
                          right=FALSE, labels = c("Very Low [0-1000)", "Low     
                          [1000-10000)", "Moderate [10000-100000)", "High [100000-250000)",
                          "Very High [250000-500000)", "Extreme [500000-1025000]"))
X4.28.20$Lat <- jitter(X4.28.20$Latitude, factor = 1)
X4.28.20$Long <- jitter(X4.28.20$Longitude, factor = 1)
X4.28.20$labelconfirmed <- paste ("<Country: >", X4.28.20$COUNTRY, "<p>",
                         "<Confirmed Cases: >", X4.28.20$Total_Cases_Country, "<p>")

# Finally, we can construct our initial marker map. First, I set different colors for each quantile.
pal = colorFactor(palette = c("#CCCCCC", "#999999", "#99FF33", "#FFCC33", "#FF6600", "#990000"), domain=X4.28.20$magrangeconfirmed2)
# Now, I pass the data through leaflet and generate the map.
Plot_3 <- leaflet(data=X4.28.20) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addCircleMarkers(data=X4.28.20, lng = ~longitude, lat = ~latitude,
                 # Here, I add the color pallete to shade the markers by intensity.
                 color = ~ pal(magrangeconfirmed2),
                 weight = 5,
                 radius = 10,
                 label = lapply(X4.28.20$labelconfirmed, HTML),
                 clusterOptions = markerClusterOptions()) %>%
addLegend("bottomright", pal = pal, values = ~magrangeconfirmed2,
    title = "Total Confirmed Cases - COVID19 (April 28th, 2020)",
    opacity = 1)
Plot_3
```

```{r last marker (deceased) - March 31st, 2020}
X4.28.20$magrangedeceased2 = cut(X4.28.20$Total_Deceased_Country,
                          breaks = c(0, 100, 500, 1000, 5000, 25000, 60000), right=FALSE,
                          labels = c("Very Low [0-100)", "Low [100-500)", "Moderate [500-1000)", "High [1000-5000)", "Very High   
                                     [5000-25000)", "Extreme [25000-60000]"))
X4.28.20$Lat <- jitter(X4.28.20$Latitude, factor = 1)
X4.28.20$Long <- jitter(X4.28.20$Longitude, factor = 1)
X4.28.20$labeldeceased <- paste ("<Country: >", X4.28.20$COUNTRY, "<p>",
                         "<Deceased: >", X4.28.20$Total_Deceased_Country, "<p>")
pal = colorFactor(palette = c("#CCCCCC", "#999999", "#99FF33", "#FFCC33", "#FF6600", "#990000"), domain=X4.28.20$magrangedeceased2)
Plot_4 <- leaflet(data=X4.28.20) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addCircleMarkers(data=X4.28.20, lng = ~longitude, lat = ~latitude,
                 color = ~ pal(magrangedeceased2),
                 weight = 5,
                 radius = 10,
                 label = lapply(X4.28.20$labeldeceased, HTML),
                 clusterOptions = markerClusterOptions()) %>%
addLegend("bottomright", pal = pal, values = ~magrangedeceased2,
    title = "Total Deaths - COVID19 (April 28th, 2020)",
    opacity = 1)
Plot_4
```

```{r bubbles}
# Now we create bubble maps for confirmed and deceased. Credit for some of these visualizations goes to: Yanchang Zhao, COVID-19 Data Analysis with R – Worldwide. RDataMining.com, 2020. URL: http://www.rdatamining.com/docs/Coronavirus-data-analysis-world.pdf. 
Plot_5 <- leaflet(data = X4.28.20) %>% 
  addProviderTiles(providers$CartoDB.Positron) %>%
  addCircleMarkers(X4.28.20$longitude, X4.28.20$latitude,
  radius=2+log2(X4.28.20$Total_Cases_Country), stroke=F,
  color='red', fillOpacity=0.3, label = lapply(X4.28.20$labelconfirmed, HTML))
Plot_5

Plot_6 <- leaflet(data = X4.28.20) %>% 
  addProviderTiles(providers$CartoDB.Positron) %>%
  addCircleMarkers(X4.28.20$longitude, X4.28.20$latitude,
  radius=2+log2(X4.28.20$Total_Deceased_Country), stroke=F,
  color='black', fillOpacity=0.3, label = lapply(X4.28.20$labeldeceased, HTML))
Plot_6
```

## Choropleth Maps

```{r Bloomberg Plot 2 (confirmed)}
# First, filter the data and create my labels.
# Choropleth_Country <- Temporary_Data_Country %>%
#   dplyr:: filter(Date == "2020-04-28") 
 
# Choropleth_Country$choroplethlabelsconfirmed <- paste ("<Country: >", Choropleth_Country$COUNTRY, "<p>", "<Confirmed Total: >", Choropleth_Country$Total_Cases_Country, "<p>")

# Then, I read in my shape file. 
# Shape_File <- st_read("/COVID-19_Final/data/UIA_World_Countries_Boundaries/UIA_World_Countries_Boundaries.shp")
# str(Shape_File)
 
# In order to properly use the shape file, I need to make a few edits to our country names in the data.
 
# Choropleth_Country$COUNTRY <- ifelse(Choropleth_Country$COUNTRY == "Czechia", "Czech Republic", Choropleth_Country$COUNTRY)
# Choropleth_Country$COUNTRY <- ifelse(Choropleth_Country$COUNTRY == "Kyrgyzstan", "Krygz Republic", Choropleth_Country$COUNTRY)
# Choropleth_Country$COUNTRY <- ifelse(Choropleth_Country$COUNTRY == "Korea, South", "South Korea", Choropleth_Country$COUNTRY)
# Choropleth_Country$COUNTRY <- ifelse(Choropleth_Country$COUNTRY == "Russia", "Russian Federation", Choropleth_Country$COUNTRY)
# Choropleth_Country$COUNTRY <- ifelse(Choropleth_Country$COUNTRY == "Holy See", "Vatican City", Choropleth_Country$COUNTRY)
# Choropleth_Country$COUNTRY <- ifelse(Choropleth_Country$COUNTRY == "US", "United States", Choropleth_Country$COUNTRY)
# Choropleth_Country$COUNTRY <- ifelse(Choropleth_Country$COUNTRY == "Cote d'Ivoire", "Côte d'Ivoire", Choropleth_Country$COUNTRY)
# Choropleth_Country$COUNTRY <- ifelse(Choropleth_Country$COUNTRY == "French Guiana", "French Guiana", Choropleth_Country$COUNTRY)
# Choropleth_Country$COUNTRY <- ifelse(Choropleth_Country$COUNTRY == "Congo (Kinshasa)", "Congo DRC", Choropleth_Country$COUNTRY)
# Choropleth_Country$COUNTRY <- ifelse(Choropleth_Country$COUNTRY == "Congo (Brazzaville)", "Congo", Choropleth_Country$COUNTRY)

# Shape_File <- subset(Shape_File, is.element(Shape_File$COUNTRY, Choropleth_Country$COUNTRY))

# Choropleth_Country <- Choropleth_Country[order(match(Choropleth_Country$COUNTRY, Shape_File$COUNTRY)),]
 
# I also create a bin, separating the total confirmed cases into relevant quantiles. I then set colors for the bin values.
# binsconfirmed <- c(0, 5000, 25000, 50000, 100000, 250000, 1250000)
# palconfirmed <- colorBin("OrRd", domain = Choropleth_Country$Total_Cases_Country, bins = binsconfirmed)
# Plot_7 <- leaflet(data=Choropleth_Country) %>%
# addProviderTiles(providers$CartoDB.Positron) %>%
# addPolygons(data=Shape_File,
#   smoothFactor = 1,
#   weight = 2,
#   opacity = 1,
#   color = "black",
#   dashArray = "",
#   fillOpacity = 0.7,
#   fillColor = palconfirmed(Choropleth_Country$Total_Cases_Country),
#   highlight = highlightOptions(
#     weight = 5,
#     color = "#666",
#     dashArray = "",
#     fillOpacity = 0.7,
#     bringToFront = TRUE),
#   label = lapply(Choropleth_Country$choroplethlabelsconfirmed, HTML)) %>% 
# addLegend("bottomleft", pal = palconfirmed, values = ~binsconfirmed,
#     title = "Total Confirmed Cases - COVID19 (April 28th, 2020)",
#     opacity = 1)
# Plot_7

# Please note: this choropleth only provides a static version of current cases (just like the Bloomberg graph). I am working on creating a web app through R Shiny which will allow the user to select a range of dates to update the choropleth.
```

```{r Bloomberg Plot 2 (deceased)}
# I now repeat this process for deaths.
 
# Choropleth_Country$choroplethlabelsdeceased <- paste ("<Country: >", Choropleth_Country$COUNTRY, "<p>", "<Deceased Total: >", Choropleth_Country$Total_Deceased_Country, "<p>")
 
# binsdeceased <- c(0, 500, 1000, 5000, 25000, 60000)
# paldeceased <- colorBin("OrRd", domain = Choropleth_Country$Total_Deceased_Country, bins = binsdeceased)
# Plot_8 <- leaflet(data=Choropleth_Country) %>%
# addProviderTiles(providers$CartoDB.Positron) %>%
# addPolygons(data=Shape_File,
#   smoothFactor = 1,
#   weight = 2,
#   opacity = 1,
#   color = "black",
#   dashArray = "",
#   fillOpacity = 0.7,
#   fillColor = paldeceased(Choropleth_Country$Total_Deceased_Country),
#   highlight = highlightOptions(
#     weight = 5,
#     color = "#666",
#     dashArray = "",
#     fillOpacity = 0.7,
#     bringToFront = TRUE),
#   label = lapply(Choropleth_Country$choroplethlabelsdeceased, HTML)) %>% 
# addLegend("bottomleft", pal = paldeceased, values = ~binsdeceased,
#     title = "Total Deaths - COVID19 (April 28th, 2020)",
#     opacity = 1)
# Plot_8

```

## TIME SERIES VISUALIZATIONS

```{r Bloomberg Plot 1 (confirmed)}
# Here, I recreate a version of the first Bloomberg graph from below: https://www.bloomberg.com/graphics/2020-coronavirus-cases-world-map/. To isolate a nation of interest, simply click on it in the legend at right. You can isolate multiple nations at once. I use the final data here, which is only our developed/emerging markets of interest.
Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

Days_Since_100_Confirmed <- Final_Data_Country %>%
  dplyr::filter(Total_Cases_Country >= 100)

Days_Since_100_Confirmed <- Days_Since_100_Confirmed %>%
  group_by(COUNTRY) %>%
  mutate(Days = row_number(COUNTRY))

Plot_9 <- plot_ly(Days_Since_100_Confirmed, x=~Days, y=~Total_Cases_Country) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Days Since 100 Cases - COVID19", yaxis = list(type = "log"))
Plot_9
```

```{r Bloomberg Plot 1 (deceased)}
# Now, I repeat the process for deaths.
Days_Since_100_Deceased <- Final_Data_Country %>%
  dplyr:: filter(Total_Deceased_Country >= 100)

Days_Since_100_Deceased <- Days_Since_100_Deceased %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(Days = row_number(COUNTRY))

Plot_10 <- plot_ly(Days_Since_100_Deceased, x=~Days, y=~Total_Deceased_Country) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Days Since 100 Deaths - COVID19")
Plot_10

Days_Since_100_Deceased_Filtered <- Days_Since_100_Deceased %>%
  dplyr::filter(COUNTRY != "Malaysia")

# I also make a facet graph for days since 100 deaths, for countries in our sample.
Plot_10A <- ggplot(data = Days_Since_100_Deceased, aes(Days, scale(Total_Deceased_Country))) + geom_line() + facet_wrap(~COUNTRY, scales = "free", ncol = 9) + theme_bw() + theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        strip.background = element_rect(color="white", fill="white"))
Plot_10A

Plot_10B <- ggplot(data = Days_Since_100_Deceased_Filtered, aes(x = Days, y = scale(Total_Deceased_Country), group = COUNTRY)) + geom_line() + theme_bw() + theme(legend.title = element_blank(), axis.text.y=element_blank(), axis.title.y=element_text(size=9), axis.title.x=element_text(size=9)) + ylab("Deaths") + xlab("Days")
Plot_10B

Days_Since_100A <- Days_Since_100_Deceased_Filtered %>%
  dplyr::filter(COUNTRY != "China") %>%
  dplyr::filter(COUNTRY != "US") %>%
  dplyr::filter(COUNTRY != "Italy")

Days_Since_100B <- Days_Since_100_Deceased_Filtered %>%
  dplyr::filter(COUNTRY == "China" | COUNTRY == "US" | COUNTRY == "Italy")


```

### Generating Figure 2.1.
```{r}
Plot_10C <- ggplot(data = Days_Since_100_Deceased_Filtered, aes(x = Days, y = scale(Total_Deceased_Country), color = COUNTRY)) + geom_line() + theme_bw() + theme(axis.text.y=element_blank(), axis.title.y=element_text(size=9), axis.title.x=element_text(size=9)) + gghighlight(COUNTRY == "US" | COUNTRY == "Italy" | COUNTRY == "China", use_direct_label = FALSE) + ylab("Deaths") + xlab("Days")
Plot_10C

```

```{r Bloomberg Plot 3 (confirmed)}
# Here, I recreate a version of the third Bloomberg graph, plotting new global cases per day: https://www.bloomberg.com/graphics/2020-coronavirus-cases-world-map/.
New_Global_Cases <- Temporary_Data_Country %>%
  group_by(Date) %>%
  summarise(New_Cases = sum(New_Confirmed_Country))

New_Confirmed <- ggplot(data = New_Global_Cases, aes(x = Date, y = New_Cases)) +
      geom_bar(stat = "identity", fill = "dodgerblue") +
      labs(title = "New Confirmed Cases - COVID19",
           subtitle = "January 23rd, 2020 - April 28th, 2020",
           x = "Date", y = "New Confirmed Cases")
Plot_11 <- ggplotly(New_Confirmed)
Plot_11
```

```{r Bloomberg Plot 3 (deceased)}
# Now, I do the same thing for deaths.
New_Global_Deaths <- Temporary_Data_Country %>%
  group_by(Date) %>%
  summarise(New_Deaths = sum(New_Total_Deceased_Country))

New_Deaths <- ggplot(data = New_Global_Deaths, aes(x = Date, y = New_Deaths)) +
      geom_bar(stat = "identity", fill = "sandybrown") +
      labs(title = "New Deaths - COVID19",
           subtitle = "January 23rd, 2020 - April 28th, 2020",
           x = "Date", y = "New Deaths")
Plot_12 <- ggplotly(New_Deaths)
Plot_12
```

```{r Bloomberg Plot 4}
# Next, I construct a graph illustrating the seven-day rolling average of new deaths, new cases, and the mortality rate per capita. This is a version of the fourth Bloomberg plot from the above link. You will need to slide to the right (to March 2020) to see variation in these plots (or simply check the output folder). I use the Temporary Data, rather than the filtered Final Data, so that users may explore the entire set of nations available.

Temporary_Data_Country <- Temporary_Data_Country[order(Temporary_Data_Country$COUNTRY, Temporary_Data_Country$Date),]

Plot_13 <- plot_ly(Temporary_Data_Country, x=~Date, y=~rolling_average_confirmed) %>% add_lines(linetype = ~COUNTRY) %>% layout(title="Rolling Average of Confirmed Cases")
Plot_13

Plot_14 <- plot_ly(Temporary_Data_Country, x=~Date, y=~rolling_average_deceased) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Rolling Average of Deaths")
Plot_14

Plot_15 <- plot_ly(Temporary_Data_Country, x=~Date, y=~total_rolling_average_mortality) %>% add_lines(linetype = ~COUNTRY) %>% layout(title="Total Rolling Average of Mortality Rate per Capita")
Plot_15

Plot_16 <- plot_ly(Temporary_Data_Country, x=~Date, y=~new_rolling_average_mortality) %>% add_lines(linetype = ~COUNTRY) %>% layout(title="New Rolling Average of Mortality Rate per Capita")
Plot_16

```

```{r time series 1}
# Here, I plot the global confirmed cases over our time period.
exponential <- function(x) exp(x)
exponential_function <- ggplot(data = data.frame(x=c(0,10)), mapping=aes(x=x)) + stat_function(fun = exponential)
exponential_function

Confirmed <- ggplot(data = World_Data, aes(x = Date, y = Global_Confirmed_Cases)) +
      geom_bar(stat = "identity", fill = "red") +
      labs(title = "Global Confirmed Cases - COVID19",
           subtitle = "January 22nd, 2020 - April 28th, 2020",
           x = "Date", y = "Confirmed Cases")
Plot_17 <- ggplotly(Confirmed)
Plot_17

# Now, I plot the global deaths over our time period.
Deaths <- ggplot(data = World_Data, aes(x = Date, y = Global_Deceased)) +
      geom_bar(stat = "identity", fill = "darkred") +
      labs(title = "Global Deaths - COVID19",
           subtitle = "January 22nd, 2020 - April 16th, 2020",
           x = "Date", y = "Deaths")
Plot_18 <- ggplotly(Deaths)
Plot_18

# Now, I plot the mortality rate per capita over our time period, for our total and new mortality rates.
Total_Global_Mortality <- Temporary_Data_Country %>%
  group_by(Date) %>%
  summarise(Total_Mortality = sum(Total_Mortality_Rate_Per_Capita))

Total_Mortality <- ggplot(data = Total_Global_Mortality, aes(x = Date, y = Total_Mortality)) +
      geom_bar(stat = "identity", fill = "darkblue") +
      labs(title = "Total Global Mortality Rate - COVID19",
           subtitle = "January 22nd, 2020 - April 28th, 2020",
           x = "Date", y = "Total Mortality Rate Per Capita")
Plot_19 <- ggplotly(Total_Mortality)
Plot_19

New_Global_Mortality <- Temporary_Data_Country %>%
  group_by(Date) %>%
  summarise(New_Mortality = sum(New_Mortality_Rate_Per_Capita))

options(scipen = 999)
```

### Generating Figure 2.2.
```{r}
New_Mortality <- ggplot(data = New_Global_Mortality, aes(x = Date, y = (New_Mortality * 100))) +
      geom_bar(stat = "identity", fill = "darkred") +
      labs(subtitle = "January 22nd, 2020 - April 28th, 2020", y = "New Mortality Rate Per Capita (%)") + theme_bw() + theme(axis.title.x=element_blank())
New_Mortality

Plot_20 <- ggplotly(New_Mortality)
Plot_20
```

```{r time series 2}
# Now, I plot the change in the global death rate across the time period.
Death_Rate <- ggplot(World_Data, aes(x=Date)) +
geom_line(aes(y=Death_Rate, colour='Daily')) +
xlab('') + ylab('Death Rate (%)') + labs(title='Change in Death Rate (%)') +
theme(legend.position='bottom', legend.title=element_blank(),
legend.text=element_text(size=8),
legend.key.size=unit(0.5, 'cm'),
axis.text.x=element_text(angle=45, hjust=1))
Plot_21 <- ggplotly(Death_Rate)
Plot_21
```

```{r time series 3}
# This plot compares the number of deaths to the number of confirmed cases across the time period.
Plots <- Temporary_Data_Country %>%
  group_by(Date) %>%
  summarise(Confirmed_Total = sum(Total_Cases_Country), Deceased_Total = sum(Total_Deceased_Country))

plot1 <- ggplot(data = Plots, aes(x = Date, y = Confirmed_Total)) +
      geom_line(color = "royalblue1")
plot2 <- ggplot(data = Plots, aes(x = Date, y = Deceased_Total)) +
      geom_line(color = "orangered2")

overlay2 <- ggplot(data = Plots, aes(x = Date)) +
      geom_line(aes(y = Confirmed_Total), color = "royalblue1") + geom_line(aes(y = Deceased_Total), color = "orangered2") + scale_y_continuous(name = "Total Confirmed Cases", sec.axis = sec_axis(trans = ~.*1, name = "Total Deaths"))
Plot_22 <- ggplotly(overlay2)
Plot_22
```

```{r time series 4}
# Now, I extend this analysis to generate the number of confirmed cases and deaths by country.
Plot_23 <- plot_ly(Temporary_Data_Country, x=~Date, y=~Total_Cases_Country) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Confirmed Cases Across Countries")
Plot_23

Plot_24 <- plot_ly(Temporary_Data_Country, x=~Date, y=~Total_Deceased_Country) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Deaths Across Countries")
Plot_24

Plot_25 <- plot_ly(Temporary_Data_Country, x=~Date, y=~Total_Mortality_Rate_Per_Capita) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Total Mortality Rate Across Countries")
Plot_25

Plot_26 <- plot_ly(Temporary_Data_Country, x=~Date, y=~New_Mortality_Rate_Per_Capita) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="New Mortality Rate Across Countries")
Plot_26

```

# Weekly Growth Rate Visualizations

``` {r growth rates}
# Here, I filter by first deaths per country.
First_Death <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::filter(Total_Deceased_Country > 0)

# Now, I calculate the week-by-week growth rate in the rolling average of the mortality rate. This is equivalent to the log[total_total_rolling_average_mortality_(t) – total_total_rolling_average_mortality_(t-7)]. First, I create a variable for weeks by country. This tells us in what week of the year each nation had their first death.
First_Death$week_num = lubridate::week(ymd(First_Death$Date))

# Next, I generate week-over-week mortality growth rates. Should be (current week - previous week)/previous week. I use two distinct formulas for this calculation.

First_Death <- First_Death %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(total_mortality_growth = log((total_rolling_average_mortality/Lag(total_rolling_average_mortality,7))))

First_Death <- First_Death %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(total_mortality_growth_b <- (total_rolling_average_mortality-Lag(total_rolling_average_mortality,7))/Lag(total_rolling_average_mortality,7))

First_Death$total_mortality_growth_b  <- log(First_Death$`... <- NULL`,10)

First_Death <- First_Death %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(new_mortality_growth <- log((new_rolling_average_mortality/Lag(new_rolling_average_mortality,7)))) 

First_Death$new_mortality_growth  <- First_Death$`... <- NULL`

First_Death <- First_Death %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(new_mortality_growth_b <- (new_rolling_average_mortality-Lag(new_rolling_average_mortality,7))/Lag(new_rolling_average_mortality,7))

First_Death$new_mortality_growth_b  <- log(First_Death$`... <- NULL`,10)

# Please see the First Death dataset in the data folder.

# The following code allows us to visualize the rolling average of the mortality rate by country.
Plot_27A <- plot_ly(First_Death, x=~Date, y=~total_rolling_average_mortality) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Total Rolling Average of Mortality Rate Over Time - COVID19")
Plot_27A

Plot_27B <- plot_ly(First_Death, x=~Date, y=~new_rolling_average_mortality) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="New Rolling Average of Mortality Rate Over Time - COVID19")
Plot_27B

# Here, I implement a log axis.
Plot_28 <- Plot_27A %>% layout(yaxis = list(type = "log"))
Plot_28

First_Death_Filtered <- First_Death %>%
  dplyr::filter(COUNTRY != "Singapore") %>%
  dplyr::filter(COUNTRY != "Vietnam")

Plot_28A <- ggplot(data = First_Death_Filtered, aes(x = Date, y = log(total_rolling_average_mortality), group = COUNTRY)) + geom_line() + theme_bw() + theme(legend.title = element_blank(), axis.text.y=element_blank(), axis.title.y=element_text(size=9), axis.title.x=element_blank()) + ylab("Rolling Average Cumulative Mortality")
Plot_28A

# Here, I add a facet wrap for each nation in our sample.
Plot_28B <- ggplot(data = First_Death_Filtered, aes(Date, log(total_rolling_average_mortality))) + geom_line(size=.7) + facet_wrap(~COUNTRY, switch="x", ncol = 7) + theme_bw() + theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.x = element_blank(),
        strip.background = element_rect(color="white", fill="white"))
Plot_28B

Plot_28C <- ggplot(data = First_Death_Filtered, aes(x = Date, y = new_rolling_average_mortality, group = COUNTRY)) + geom_line() + theme_bw() + theme(legend.title = element_blank(), axis.text.y=element_blank(), axis.title.y=element_text(size=9), axis.title.x=element_blank()) + ylab("Rolling Average New Mortality")
Plot_28C
```

### Generating Figures 1.1 and 1.2.
```{r}
library(gghighlight)

Plot_28D <- ggplot(data = First_Death_Filtered, aes(x = Date, y = new_rolling_average_mortality, color = COUNTRY)) + geom_line() + theme_bw() + theme(legend.title = element_blank(), legend.position = "none", axis.text.y=element_blank(), axis.title.y=element_text(size=9), axis.title.x=element_text(size=9)) + ylab("Rolling Average New Mortality") + gghighlight(COUNTRY == "Italy" | COUNTRY == "China" | COUNTRY == "US")
Plot_28D

Plot_28E <- ggplot(data = First_Death_Filtered, aes(x = Date, y = log(total_rolling_average_mortality), color = COUNTRY)) + geom_line() + theme_bw() + theme(legend.title = element_blank(), legend.position = "none", axis.text.y=element_blank(), axis.title.y=element_text(size=9), axis.title.x=element_text(size=9)) + ylab("Rolling Average Cumulative Mortality") + gghighlight(COUNTRY == "Italy" | COUNTRY == "China" | COUNTRY == "US")
Plot_28E
```

```{r}
# Next, I create initial visualizations of the mortality growth rates by country.
Plot_29 <- plot_ly(First_Death, x=~Date, y=~total_mortality_growth) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Weekly Growth Rate in Total Rolling Average Mortality per Capita - COVID19")
Plot_29

Plot_30 <- plot_ly(First_Death, x=~Date, y=~total_mortality_growth_b) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Alternate Weekly Growth Rate in Total Rolling Average Mortality per Capita - COVID19")
Plot_30

Plot_31 <- plot_ly(First_Death, x=~Date, y=~new_mortality_growth) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Weekly Growth Rate in New Rolling Average Mortality per Capita - COVID19")
Plot_31

```

# Pre-Estimation Visualizations
```{r summaries}
# First, we generate extensive summary statistics for each variable with describe in the Hmisc function.
Hmisc::describe(Final_Data_Country)
# n, nmiss, unique, mean, 5, 10, 25, 50, 75, 90, 95th percentiles

# Next, I generate shareable outputs, using the summarytools package. Set st_options(use.x11 = FALSE).
saved_x11_option <- st_options("use.x11")
st_options(use.x11 = TRUE)
dfSummary(Final_Data_Country, plain.ascii = FALSE, style = "grid", 
          graph.magnif = 0.75, valid.col = FALSE, tmp.img.dir = "/tmp")
view(dfSummary(Final_Data_Country))
# For the complete output, please open the summary in the html link.
```

```{r correlations}
# Now, I generate a correlation heat map, using a subset of variables from the final dataset.
corrmapvarlist <- c("total_rolling_average_mortality", "Total_Cases_Country", "Total_Deceased_Country", "New_Confirmed_Country", "New_Total_Deceased_Country", "Population", "rolling_average_confirmed", "rolling_average_deceased", "C1_School.closing", "C2_Workplace.closing", "C3_Cancel.public.events", "C4_Restrictions.on.gatherings", "C5_Close.public.transport", "C6_Stay.at.home.requirements", "C7_Restrictions.on.internal.movement", "C8_International.travel.controls", "E1_Income.support", "E2_Debt.contract.relief", "E3_Fiscal.measures", "H1_Public.information.campaigns", "H2_Testing.policy", "H3_Contact.tracing", "H4_Emergency.investment.in.healthcare", "H5_Investment.in.vaccines", "StringencyIndex", "LegacyStringencyIndex", "prop65", "propurban", "driving", "walking")
corrmapvars <- Final_Data_Country[corrmapvarlist]

# Here, I rename the variables to make them easier to read on the map.
corrmapvars <- corrmapvars %>% dplyr::rename(mortality_ra = total_rolling_average_mortality)
corrmapvars <- corrmapvars %>% dplyr::rename(confirmed_ra = rolling_average_confirmed)
corrmapvars <- corrmapvars %>% dplyr::rename(deceased_ra = rolling_average_deceased)
corrmapvars <- corrmapvars %>% dplyr::rename(cases = Total_Cases_Country)
corrmapvars <- corrmapvars %>% dplyr::rename(deaths = Total_Deceased_Country)
corrmapvars <- corrmapvars %>% dplyr::rename(new_cases = New_Confirmed_Country)
corrmapvars <- corrmapvars %>% dplyr::rename(new_deaths = New_Total_Deceased_Country)
corrmapvars <- corrmapvars %>% dplyr::rename(school_closing = C1_School.closing)
corrmapvars <- corrmapvars %>% dplyr::rename(work_closing = C2_Workplace.closing)
corrmapvars <- corrmapvars %>% dplyr::rename(public_event_closing = C3_Cancel.public.events)
corrmapvars <- corrmapvars %>% dplyr::rename(gathering_restrictions = C4_Restrictions.on.gatherings)
corrmapvars <- corrmapvars %>% dplyr::rename(transport_closing = C5_Close.public.transport)
corrmapvars <- corrmapvars %>% dplyr::rename(lockdown = C6_Stay.at.home.requirements)
corrmapvars <- corrmapvars %>% dplyr::rename(internal_restrictions = C7_Restrictions.on.internal.movement)
corrmapvars <- corrmapvars %>% dplyr::rename(travel_restrictions = C8_International.travel.controls)
corrmapvars <- corrmapvars %>% dplyr::rename(income = E1_Income.support)
corrmapvars <- corrmapvars %>% dplyr::rename(debt = E2_Debt.contract.relief)
corrmapvars <- corrmapvars %>% dplyr::rename(fiscal = E3_Fiscal.measures)
corrmapvars <- corrmapvars %>% dplyr::rename(campaigns = H1_Public.information.campaigns)
corrmapvars <- corrmapvars %>% dplyr::rename(testing = H2_Testing.policy)
corrmapvars <- corrmapvars %>% dplyr::rename(tracing = H3_Contact.tracing)
corrmapvars <- corrmapvars %>% dplyr::rename(health_care = H4_Emergency.investment.in.healthcare)
corrmapvars <- corrmapvars %>% dplyr::rename(vaccine = H5_Investment.in.vaccines)
corrmapvars <- corrmapvars %>% dplyr::rename(stringency_index = StringencyIndex)
corrmapvars <- corrmapvars %>% dplyr::rename(legacy_stringency_index = LegacyStringencyIndex)
corrmapvalues <- round(cor(corrmapvars, use = "pairwise.complete.obs"), 2)

# Here, I get the lower triangle of the correlation matrix
get_lower_tri<-function(cormat){
  cormat[upper.tri(cormat)] <- NA
  return(cormat)
}
# Now, I get the upper triangle of the correlation matrix
get_upper_tri <- function(cormat){
  cormat[lower.tri(cormat)]<- NA
  return(cormat)
}
reorder_cormat <- function(cormat){
### Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}
### Reorder the correlation matrix
corrmapvalues <- reorder_cormat(corrmapvalues)
### Get the Upper Triangle
upper_tri <- get_upper_tri(corrmapvalues) 
### Melt the Correlation Map
melted_corrmap <- reshape2::melt(upper_tri, na.rm = TRUE)

### Generate the Static Correlation Map
ggheatmap <- ggplot(data = melted_corrmap, aes(x=Var2, y=Var1, fill=value)) + 
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white",
    midpoint = 0, limit = c(-1,1), space = "Lab", 
    name="Pearson\nCorrelation") +
  theme(axis.text.x = element_text(angle = 45)) +
  theme(axis.text.x = element_text(margin = margin(t = 5, r = 0, b = 0, l = 0))) +
  theme(axis.text.x = element_text(hjust=1))
print(ggheatmap)

### Generate an Interactive Correlation Map (you are able to zoom to specific correlates).
interactive_heatmap <- heatmaply_cor(
  cor(corrmapvalues),
  row_text_angle = 0,
  column_text_angle = 45,
  na.value = "grey50",
  na.rm = TRUE,
  xlab = "Features",
  ylab = "Features",
  k_col = 0,
  k_row = 0,
  fontsize_row = 5,
  fontsize_col = 5,
  plot_method = c("ggplot", "plotly"),
  show_dendrogram = c(FALSE, FALSE),
  key.title = "Pearson Correlations")
interactive_heatmap
```

```{r relationships}

## Following code from: https://www.rstatisticsblog.com/data-science-in-action/lasso-regression/.

str(Final_Data_Country)
# The following code gives us every set of possible relationships between our numeric independent variables. Factor variables and lags have been excluded.

# First, government responses linked to the seven-day rolling average of mortality rates per capita.
pairs.panels(Final_Data_Country[c("total_rolling_average_mortality", "StringencyIndex", "E1_Income.support", "E2_Debt.contract.relief", "E3_Fiscal.measures", "H2_Testing.policy", "H3_Contact.tracing", "H4_Emergency.investment.in.healthcare")])

# Next, government responses linked to the total and new mortality rates per capita.
pairs.panels(Final_Data_Country[c("Total_Mortality_Rate_Per_Capita", "StringencyIndex", "E1_Income.support", "E2_Debt.contract.relief", "E3_Fiscal.measures", "H2_Testing.policy", "H3_Contact.tracing", "H4_Emergency.investment.in.healthcare")])

pairs.panels(Final_Data_Country[c("New_Mortality_Rate_Per_Capita", "StringencyIndex", "E1_Income.support", "E2_Debt.contract.relief", "E3_Fiscal.measures", "H2_Testing.policy", "H3_Contact.tracing", "H4_Emergency.investment.in.healthcare")])
```

### **CUMULATIVE MORTALITY RATES** - Cross-Sectional + Panel Analysis

``` {r Rashad Panel Analysis - Cumulative Mortality}

library(lubridate)
library(zoo)
library(quantmod)
library(fBasics)
library(tseries)
library(sandwich)
library(lmtest)
library(lattice)
library(xtable)
library(vars)
library(plyr)
library(gridExtra)
library(corrplot)
library(ggplot2)
library(reshape2)
library(data.table)
library(rvest)
library(plm)
library(stringr)
library(stargazer)
library(plotly)

### Creating the dataframe.
a<-Final_Data_Country
a<-pdata.frame(Final_Data_Country, index = c("COUNTRY", "Date"))
a$Date<-as.Date(a$Date,"%m/%d/%y")
#reorder
a<-a[order(a$Date),]
a<-a[order(a$COUNTRY),]

# Creating the cumulative mortality growth rate.
cum_mort_growth<-log(subset(a,COUNTRY==unique(COUNTRY)[1])$total_rolling_average_mortality)-Lag(log(subset(a,COUNTRY==unique(COUNTRY)[1])$total_rolling_average_mortality),7)
for(i in 2:length(unique(a$COUNTRY))){
  cum_mort_growth<-c(cum_mort_growth,log(subset(a,COUNTRY==unique(COUNTRY)[i])$total_rolling_average_mortality)-Lag(log(subset(a,COUNTRY==unique(COUNTRY)[i])$total_rolling_average_mortality),7))
}
a$cum_mort_growth<-cum_mort_growth

```

### Baseline Regressions - Cumulative Mortality Growth Rates
```{r Rashad analysis - April 26th 2020}

###baseline projection regressions, remove 'infinite' values. two-way FE, HAC robust SEs, clustered on country
regmoda<-plm(cum_mort_growth~Lag(cum_mort_growth,7)+Lag(StringencyIndex,c(14)),method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))
regmodb<-plm(cum_mort_growth~Lag(cum_mort_growth,14)+Lag(StringencyIndex,c(21)),method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))
regmodc<-plm(cum_mort_growth~Lag(cum_mort_growth,21)+Lag(StringencyIndex,c(28)),method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))
regmodd<-plm(cum_mort_growth~Lag(cum_mort_growth,28)+Lag(StringencyIndex,c(35)),method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))
```

### RESULTS DON'T MATCH THOSE OF PAPER

### HTML output of the regressions - Cumulative Mortality
```{r,warning=FALSE, results='hide',message=FALSE}
stargazer(digits=6,regmoda,regmodb,regmodc,regmodd,type="html",se=list(se.a[,2],se.b[,2],se.c[,2],se.d[,2]),out="baseline_reg_output.htm",
          dep.var.labels=c("Weekly Avg. Cumulative Mortality Growth (t)"),
          covariate.labels=c("Mortality Growth (t-7)","Stringency (t-14)","Mortality Growth (t-14)","Stringency (t-21)","Mortality Growth (t-21)","Stringency (t-28)","Mortality Growth (t-28)","Stringency (t-35)"), df = FALSE,omit.stat="adj.rsq",notes = c("*,**,*** correspond to 10%, 5% and 1% significance, respectively.","HAC robust standard errors, clustered by country. Time and Country FEs."),notes.append=F,notes.align ="l",title="Local Projection Regressions",add.lines = list(c("Fixed effects?", "Y", "Y","Y","Y")))
```

### Plots - Cumulative Mortality
```{r}
### plot of 10-unit increase in Stringency effects over time on future mortality growth
p.dat<-c(coef(regmoda)[2],coef(regmodb)[2],coef(regmodc)[2],coef(regmodd)[2])
p.dat<-cbind(p.dat,p.dat+1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
p.dat<-cbind(p.dat,p.dat[,1]-1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
colnames(p.dat)<-c("mean","upper","lower")
p.dat<-data.frame(p.dat)*10*100

Plot_32 <-ggplot(data=p.dat,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean))+geom_point(size=4,shape=21,fill="grey")+geom_hline(yintercept=0,linetype=2)+xlab("Increase in Stringency Index of 10 units")+theme_bw()+ylab("Effect on Mortality Growth (%)")+geom_errorbar(aes(ymin=lower,ymax=upper))
Plot_32                                                                                   
Plot_33 <-ggplot(data=p.dat,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean))+geom_point(size=4,shape=21,fill="grey")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on Mortality Growth (%)")+geom_errorbar(aes(ymin=lower,ymax=upper))+ggtitle("Average Impact")
Plot_33
```

#### Heterogeneity: Proportion Elderly - Cumulative Mortality
```{r}
###baseline projection regressions, remove 'infinite' values. two-way FE, HAC robust SEs, clustered on country

regmoda<-plm(cum_mort_growth~Lag(cum_mort_growth,7)+Lag(StringencyIndex,c(14)):prop65,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))
regmodb<-plm(cum_mort_growth~Lag(cum_mort_growth,14)+Lag(StringencyIndex,c(21)):prop65,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))
regmodc<-plm(cum_mort_growth~Lag(cum_mort_growth,21)+Lag(StringencyIndex,c(28)):prop65,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))
regmodd<-plm(cum_mort_growth~Lag(cum_mort_growth,28)+Lag(StringencyIndex,c(35)):prop65,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))

### plot of 10-unit increase in Stringency effects over time on future mortality growth
 p.dat<-c(coef(regmoda)[2],coef(regmodb)[2],coef(regmodc)[2],coef(regmodd)[2])
 p.dat<-cbind(p.dat,p.dat+1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 p.dat<-cbind(p.dat,p.dat[,1]-1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 colnames(p.dat)<-c("mean","upper","lower")
 p.dat<-data.frame(p.dat)*10*100
 
 
###figure out the 25% percentile  and 75% percentile of elderly population rate across countries, to compare effects of a 10-unit rise in stringency level
 summary(unique(a$prop65)) #roughly 8.5% and 20%, respectively
 
#plot
Plot_34 <-ggplot(data=p.dat,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*20))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*20),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*8.5),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*8.5)),linetype=2)+ggtitle("Proportion 65+")
Plot_34                                 
```

### HTML output of the regressions:elderly - Cumulative Mortality
```{r,warning=FALSE, results='hide',message=FALSE}
stargazer(digits=6,regmoda,regmodb,regmodc,regmodd,type="html",se=list(se.a[,2],se.b[,2],se.c[,2],se.d[,2]),out="elderly_reg_output.htm",
          dep.var.labels=c("Weekly Avg. Cumulative Mortality Growth (t)"),
          covariate.labels=c("Mortality Growth (t-7)","Stringency (t-14) X Prop. 65+","Mortality Growth (t-14)","Stringency (t-21) X Prop. 65+","Mortality Growth (t-21)","Stringency (t-28) X Prop. 65+","Mortality Growth (t-28)","Stringency (t-35) X Prop. 65+"), df = FALSE,omit.stat="adj.rsq",notes = c("*,**,*** correspond to 10%, 5% and 1% significance, respectively.","HAC robust standard errors, clustered by country. Time and Country FEs."),notes.append=F,notes.align ="l",title="Heterogeneity: Proportion 65 or Older",add.lines = list(c("Fixed effects?", "Y", "Y","Y","Y")))
```

#### Heterogeneity: Proportion Urban - Cumulative Mortality
```{r}
###baseline projection regressions, remove 'infinite' values. two-way FE, HAC robust SEs, clustered on country

regmoda<-plm(cum_mort_growth~Lag(cum_mort_growth,7)+Lag(StringencyIndex,c(14)):propurban,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))
regmodb<-plm(cum_mort_growth~Lag(cum_mort_growth,14)+Lag(StringencyIndex,c(21)):propurban,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))
regmodc<-plm(cum_mort_growth~Lag(cum_mort_growth,21)+Lag(StringencyIndex,c(28)):propurban,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))
regmodd<-plm(cum_mort_growth~Lag(cum_mort_growth,28)+Lag(StringencyIndex,c(35)):propurban,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))

### plot of 10-unit increase in Stringency effects over time on future mortality growth
 p.dat<-c(coef(regmoda)[2],coef(regmodb)[2],coef(regmodc)[2],coef(regmodd)[2])
 p.dat<-cbind(p.dat,p.dat+1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 p.dat<-cbind(p.dat,p.dat[,1]-1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 colnames(p.dat)<-c("mean","upper","lower")
 p.dat<-data.frame(p.dat)*10*100
 
 
###figure out the 25% percentile  and 75% percentile of elderly population rate across countries, to compare effects of a 10-unit rise in stringency level
 summary(unique(a$propurban)) #roughly 66% and 86%, respectively
 
#plot
Plot_35 <-ggplot(data=p.dat,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*86))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*86),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*66),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*66)),linetype=2)+ggtitle("Proportion Urban")
Plot_35
```

### HTML output of the regressions:urban - Cumulative Mortality
```{r,warning=FALSE, results='hide',message=FALSE}
stargazer(digits=6,regmoda,regmodb,regmodc,regmodd,type="html",se=list(se.a[,2],se.b[,2],se.c[,2],se.d[,2]),out="urban_reg_output.htm",
          dep.var.labels=c("Weekly Avg. Cumulative Mortality Growth (t)"),
          covariate.labels=c("Mortality Growth (t-7)","Stringency (t-14) X Prop. Urban","Mortality Growth (t-14)","Stringency (t-21) X Prop. Urban","Mortality Growth (t-21)","Stringency (t-28) X Prop. Urban","Mortality Growth (t-28)","Stringency (t-35) X Prop. Urban"), df = FALSE,omit.stat="adj.rsq",notes = c("*,**,*** correspond to 10%, 5% and 1% significance, respectively.","HAC robust standard errors, clustered by country. Time and Country FEs."),notes.append=F,notes.align ="l",title="Heterogeneity: Proportion Urban",add.lines = list(c("Fixed effects?", "Y", "Y","Y","Y")))
```

#### Heterogeneity: Latitude - Cumulative Mortality
```{r}
###baseline projection regressions, remove 'infinite' values. two-way FE, HAC robust SEs, clustered on country

regmoda<-plm(cum_mort_growth~Lag(cum_mort_growth,7)+Lag(StringencyIndex,c(14)):Latitude,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))
regmodb<-plm(cum_mort_growth~Lag(cum_mort_growth,14)+Lag(StringencyIndex,c(21)):Latitude,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))
regmodc<-plm(cum_mort_growth~Lag(cum_mort_growth,21)+Lag(StringencyIndex,c(28)):Latitude,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))
regmodd<-plm(cum_mort_growth~Lag(cum_mort_growth,28)+Lag(StringencyIndex,c(35)):Latitude,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))

### plot of 10-unit increase in Stringency effects over time on future mortality growth
 p.dat<-c(coef(regmoda)[2],coef(regmodb)[2],coef(regmodc)[2],coef(regmodd)[2])
 p.dat<-cbind(p.dat,p.dat+1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 p.dat<-cbind(p.dat,p.dat[,1]-1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 colnames(p.dat)<-c("mean","upper","lower")
 p.dat<-data.frame(p.dat)*10*100
 
 
###figure out the 25% percentile  and 75% percentile of elderly population rate across countries, to compare effects of a 10-unit rise in stringency level
 summary(unique(a$Latitude)) #roughly 23.42% and 51.92%, respectively
 
 #plot
Plot_36 <-ggplot(data=p.dat,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*52))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*52),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*23),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*23)),linetype=2)+ggtitle("Latitude")
Plot_36                                
```

### HTML output of the regressions: latitude - Cumulative Mortality
```{r,warning=FALSE, results='hide',message=FALSE}
stargazer(digits=6,regmoda,regmodb,regmodc,regmodd,type="html",se=list(se.a[,2],se.b[,2],se.c[,2],se.d[,2]),out="latitude_reg_output.htm",
          dep.var.labels=c("Weekly Avg. Cumulative Mortality Growth (t)"),
          covariate.labels=c("Mortality Growth (t-7)","Stringency (t-14) X Latitude","Mortality Growth (t-14)","Stringency (t-21) X Latitude","Mortality Growth (t-21)","Stringency (t-28) X Latitude","Mortality Growth (t-28)","Stringency (t-35) X Latitude"), df = FALSE,omit.stat="adj.rsq",notes = c("*,**,*** correspond to 10%, 5% and 1% significance, respectively.","HAC robust standard errors, clustered by country. Time and Country FEs."),notes.append=F,notes.align ="l",title="Heterogeneity: Latitude",add.lines = list(c("Fixed effects?", "Y", "Y","Y","Y")))
```

#### Heterogeneity: Longitude - Cumulative Mortality
```{r}
###baseline projection regressions, remove 'infinite' values. two-way FE, HAC robust SEs, clustered on country

regmoda<-plm(cum_mort_growth~Lag(cum_mort_growth,7)+Lag(StringencyIndex,c(14)):Longitude,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))
regmodb<-plm(cum_mort_growth~Lag(cum_mort_growth,14)+Lag(StringencyIndex,c(21)):Longitude,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))
regmodc<-plm(cum_mort_growth~Lag(cum_mort_growth,21)+Lag(StringencyIndex,c(28)):Longitude,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))
regmodd<-plm(cum_mort_growth~Lag(cum_mort_growth,28)+Lag(StringencyIndex,c(35)):Longitude,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))

### plot of 10-unit increase in Stringency effects over time on future mortality growth
 p.dat<-c(coef(regmoda)[2],coef(regmodb)[2],coef(regmodc)[2],coef(regmodd)[2])
 p.dat<-cbind(p.dat,p.dat+1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 p.dat<-cbind(p.dat,p.dat[,1]-1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 colnames(p.dat)<-c("mean","upper","lower")
 p.dat<-data.frame(p.dat)*10*100
 
 
###figure out the 25% percentile  and 75% percentile of elderly population rate across countries, to compare effects of a 10-unit rise in stringency level
 summary(unique(a$Longitude)) #roughly 2.2 and 51.2, respectively
 
 #plot
Plot_37 <-ggplot(data=p.dat,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*51))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*51),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*2.2),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*2.2)),linetype=2)+ggtitle("Longitude")
Plot_37                                  
```

### HTML output of the regressions:longitude - Cumulative Mortality
```{r,warning=FALSE, results='hide',message=FALSE}
stargazer(digits=6,regmoda,regmodb,regmodc,regmodd,type="html",se=list(se.a[,2],se.b[,2],se.c[,2],se.d[,2]),out="longitude_reg_output.htm",
          dep.var.labels=c("Weekly Avg. Cumulative Mortality Growth (t)"),
          covariate.labels=c("Mortality Growth (t-7)","Stringency (t-14) X Longitude","Mortality Growth (t-14)","Stringency (t-21) X Longitude","Mortality Growth (t-21)","Stringency (t-28) X Longitude","Mortality Growth (t-28)","Stringency (t-35) X Longitude"), df = FALSE,omit.stat="adj.rsq",notes = c("*,**,*** correspond to 10%, 5% and 1% significance, respectively.","HAC robust standard errors, clustered by country. Time and Country FEs."),notes.append=F,notes.align ="l",title="Heterogeneity: Longitude",add.lines = list(c("Fixed effects?", "Y", "Y","Y","Y")))
```

#### Heterogeneity: Density - Cumulative Mortality
```{r}
###baseline projection regressions, remove 'infinite' values. two-way FE, HAC robust SEs, clustered on country

regmoda<-plm(cum_mort_growth~Lag(cum_mort_growth,7)+Lag(StringencyIndex,c(14)):popdensity,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))
regmodb<-plm(cum_mort_growth~Lag(cum_mort_growth,14)+Lag(StringencyIndex,c(21)):popdensity,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))
regmodc<-plm(cum_mort_growth~Lag(cum_mort_growth,21)+Lag(StringencyIndex,c(28)):popdensity,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))
regmodd<-plm(cum_mort_growth~Lag(cum_mort_growth,28)+Lag(StringencyIndex,c(35)):popdensity,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))

### plot of 10-unit increase in Stringency effects over time on future mortality growth
 p.dat<-c(coef(regmoda)[2],coef(regmodb)[2],coef(regmodc)[2],coef(regmodd)[2])
 p.dat<-cbind(p.dat,p.dat+1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 p.dat<-cbind(p.dat,p.dat[,1]-1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 colnames(p.dat)<-c("mean","upper","lower")
 p.dat<-data.frame(p.dat)*10*100
 
 
###figure out the 25% percentile  and 75% percentile of elderly population rate across countries, to compare effects of a 10-unit rise in stringency level
 summary(unique(a$popdensity)) #roughly 33.3% and 223.8, respectively
 
 #plot
Plot_38 <-ggplot(data=p.dat,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*223.8))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*223.8),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*33.3),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*33.3)),linetype=2)+ggtitle("Population Density")
Plot_38                                  

```

###HTML output of the regressions:density - Cumulative Mortality
```{r,warning=FALSE, results='hide',message=FALSE}
stargazer(digits=6,regmoda,regmodb,regmodc,regmodd,type="html",se=list(se.a[,2],se.b[,2],se.c[,2],se.d[,2]),out="popdensity_reg_output.htm",
          dep.var.labels=c("Weekly Avg. Cumulative Mortality Growth (t)"),
          covariate.labels=c("Mortality Growth (t-7)","Stringency (t-14) X Pop. Density","Mortality Growth (t-14)","Stringency (t-21) X Pop. Density","Mortality Growth (t-21)","Stringency (t-28) X Pop. Density","Mortality Growth (t-28)","Stringency (t-35) X Pop. Density"), df = FALSE,omit.stat="adj.rsq",notes = c("*,**,*** correspond to 10%, 5% and 1% significance, respectively.","HAC robust standard errors, clustered by country. Time and Country FEs."),notes.append=F,notes.align ="l",title="Heterogeneity: Population Density",add.lines = list(c("Fixed effects?", "Y", "Y","Y","Y")))
```

#### Heterogeneity: Arrivals - Cumulative Mortality
```{r}
###baseline projection regressions, remove 'infinite' values. two-way FE, HAC robust SEs, clustered on country

regmoda<-plm(cum_mort_growth~Lag(cum_mort_growth,7)+Lag(StringencyIndex,c(14)):log(arrivals),method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))
regmodb<-plm(cum_mort_growth~Lag(cum_mort_growth,14)+Lag(StringencyIndex,c(21)):log(arrivals),method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))
regmodc<-plm(cum_mort_growth~Lag(cum_mort_growth,21)+Lag(StringencyIndex,c(28)):log(arrivals),method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))
regmodd<-plm(cum_mort_growth~Lag(cum_mort_growth,28)+Lag(StringencyIndex,c(35)):log(arrivals),method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))

### plot of 10-unit increase in Stringency effects over time on future mortality growth
 p.dat<-c(coef(regmoda)[2],coef(regmodb)[2],coef(regmodc)[2],coef(regmodd)[2])
 p.dat<-cbind(p.dat,p.dat+1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 p.dat<-cbind(p.dat,p.dat[,1]-1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 colnames(p.dat)<-c("mean","upper","lower")
 p.dat<-data.frame(p.dat)*10*100
 
###figure out the 25% percentile  and 75% percentile of elderly population rate across countries, to compare effects of a 10-unit rise in stringency levels
 summary(unique(log(a$arrivals))) #roughly 15 and 17, respectively
 
 #plot
Plot_39 <-ggplot(data=p.dat,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*17))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*17),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*15),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*15)),linetype=2)+ggtitle("Log Arrivals")
Plot_39                              

```

###HTML output of the regressions:log(Arrivals) - Cumulative Mortality
```{r,warning=FALSE, results='hide',message=FALSE}
stargazer(digits=6,regmoda,regmodb,regmodc,regmodd,type="html",se=list(se.a[,2],se.b[,2],se.c[,2],se.d[,2]),out="logarrivals_reg_output.htm",
          dep.var.labels=c("Weekly Avg. Cumulative Mortality Growth (t)"),
          covariate.labels=c("Mortality Growth (t-7)","Stringency (t-14) X Log(Arrivals)","Mortality Growth (t-14)","Stringency (t-21) X Log(Arrivals)","Mortality Growth (t-21)","Stringency (t-28) X Log(Arrivals)","Mortality Growth (t-28)","Stringency (t-35) X Log(Arrivals)"), df = FALSE,omit.stat="adj.rsq",notes = c("*,**,*** correspond to 10%, 5% and 1% significance, respectively.","HAC robust standard errors, clustered by country. Time and Country FEs."),notes.append=F,notes.align ="l",title="Heterogeneity: Log Arrivals",add.lines = list(c("Fixed effects?", "Y", "Y","Y","Y")))
```

#### Heterogeneity: Departures - Cumulative Mortality
```{r}
###baseline projection regressions, remove 'infinite' values. two-way FE, HAC robust SEs, clustered on country

regmoda<-plm(cum_mort_growth~Lag(cum_mort_growth,7)+Lag(StringencyIndex,c(14)):log(departures),method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))
regmodb<-plm(cum_mort_growth~Lag(cum_mort_growth,14)+Lag(StringencyIndex,c(21)):log(departures),method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))
regmodc<-plm(cum_mort_growth~Lag(cum_mort_growth,21)+Lag(StringencyIndex,c(28)):log(departures),method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))
regmodd<-plm(cum_mort_growth~Lag(cum_mort_growth,28)+Lag(StringencyIndex,c(35)):log(departures),method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))

### plot of 10-unit increase in Stringency effects over time on future mortality growth
 p.dat<-c(coef(regmoda)[2],coef(regmodb)[2],coef(regmodc)[2],coef(regmodd)[2])
 p.dat<-cbind(p.dat,p.dat+1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 p.dat<-cbind(p.dat,p.dat[,1]-1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 colnames(p.dat)<-c("mean","upper","lower")
 p.dat<-data.frame(p.dat)*10*100
 
 
###figure out the 25% percentile  and 75% percentile of elderly population rate across countries, to compare effects of a 10-unit rise in stringency level
 summary(unique(log(a$departures))) #roughly 13.4 and  16.7, respectively
 
 #plot
Plot_40 <-ggplot(data=p.dat,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*16.7))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*16.7),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*15),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*15)),linetype=2)+ggtitle("Log Departures")
Plot_40                               

```

###HTML output of the regressions:log(Departures) - Cumulative Mortality
```{r,warning=FALSE, results='hide',message=FALSE}
stargazer(digits=6,regmoda,regmodb,regmodc,regmodd,type="html",se=list(se.a[,2],se.b[,2],se.c[,2],se.d[,2]),out="logdepartures_reg_output.htm",
          dep.var.labels=c("Weekly Avg. Cumulative Mortality Growth (t)"),
          covariate.labels=c("Mortality Growth (t-7)","Stringency (t-14) X Log(Departures)","Mortality Growth (t-14)","Stringency (t-21) X Log(Departures)","Mortality Growth (t-21)","Stringency (t-28) X Log(Departures)","Mortality Growth (t-28)","Stringency (t-35) X Log(Departures)"), df = FALSE,omit.stat="adj.rsq",notes = c("*,**,*** correspond to 10%, 5% and 1% significance, respectively.","HAC robust standard errors, clustered by country. Time and Country FEs."),notes.append=F,notes.align ="l",title="Heterogeneity: Log Departures",add.lines = list(c("Fixed effects?", "Y", "Y","Y","Y")))
```

#### Heterogeneity: Vulnerable Employees - Cumulative Mortality
```{r}
###baseline projection regressions, remove 'infinite' values. two-way FE, HAC robust SEs, clustered on country

regmoda<-plm(cum_mort_growth~Lag(cum_mort_growth,7)+Lag(StringencyIndex,c(14)):vul_emp,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))
regmodb<-plm(cum_mort_growth~Lag(cum_mort_growth,14)+Lag(StringencyIndex,c(21)):vul_emp,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))
regmodc<-plm(cum_mort_growth~Lag(cum_mort_growth,21)+Lag(StringencyIndex,c(28)):vul_emp,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))
regmodd<-plm(cum_mort_growth~Lag(cum_mort_growth,28)+Lag(StringencyIndex,c(35)):vul_emp,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))

### plot of 10-unit increase in Stringency effects over time on future mortality growth
 p.dat<-c(coef(regmoda)[2],coef(regmodb)[2],coef(regmodc)[2],coef(regmodd)[2])
 p.dat<-cbind(p.dat,p.dat+1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 p.dat<-cbind(p.dat,p.dat[,1]-1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 colnames(p.dat)<-c("mean","upper","lower")
 p.dat<-data.frame(p.dat)*10*100
 
 
###figure out the 25% percentile  and 75% percentile of elderly population rate across countries, to compare effects of a 10-unit rise in stringency level
 summary(unique(a$vul_emp)) #roughly 7.4 and 21.7, respectively
 
 #plot
Plot_41 <-ggplot(data=p.dat,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*21.7))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*21.7),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*7.4),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*7.4)),linetype=2)+ggtitle("Vulnerable Employees")
Plot_41                                

```

###HTML output of the regressions:vulnerable employees - Cumulative Mortality
```{r,warning=FALSE, results='hide',message=FALSE}
stargazer(digits=6,regmoda,regmodb,regmodc,regmodd,type="html",se=list(se.a[,2],se.b[,2],se.c[,2],se.d[,2]),out="vulnerablemp_reg_output.htm",
          dep.var.labels=c("Weekly Avg. Cumulative Mortality Growth (t)"),
          covariate.labels=c("Mortality Growth (t-7)","Stringency (t-14) X Vulnerable Emp.","Mortality Growth (t-14)","Stringency (t-21) X Vulnerable Emp.","Mortality Growth (t-21)","Stringency (t-28) X Vulnerable Emp.","Mortality Growth (t-28)","Stringency (t-35) X Vulnerambe Emp."), df = FALSE,omit.stat="adj.rsq",notes = c("*,**,*** correspond to 10%, 5% and 1% significance, respectively.","HAC robust standard errors, clustered by country. Time and Country FEs."),notes.append=F,notes.align ="l",title="Heterogeneity: Vulnerable Employees",add.lines = list(c("Fixed effects?", "Y", "Y","Y","Y")))
```

#### Heterogeneity: GNI - Cumulative Mortality
```{r}
###baseline projection regressions, remove 'infinite' values. two-way FE, HAC robust SEs, clustered on country

regmoda<-plm(cum_mort_growth~Lag(cum_mort_growth,7)+Lag(StringencyIndex,c(14)):GNI,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))
regmodb<-plm(cum_mort_growth~Lag(cum_mort_growth,14)+Lag(StringencyIndex,c(21)):GNI,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))
regmodc<-plm(cum_mort_growth~Lag(cum_mort_growth,21)+Lag(StringencyIndex,c(28)):GNI,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))
regmodd<-plm(cum_mort_growth~Lag(cum_mort_growth,28)+Lag(StringencyIndex,c(35)):GNI,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))

### plot of 10-unit increase in Stringency effects over time on future mortality growth
 p.dat<-c(coef(regmoda)[2],coef(regmodb)[2],coef(regmodc)[2],coef(regmodd)[2])
 p.dat<-cbind(p.dat,p.dat+1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 p.dat<-cbind(p.dat,p.dat[,1]-1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 colnames(p.dat)<-c("mean","upper","lower")
 p.dat<-data.frame(p.dat)*10*100
 
 
###figure out the 25% percentile  and 75% percentile of elderly population rate across countries, to compare effects of a 10-unit rise in stringency level
 summary(unique(a$GNI)) #roughly 10325 and 46500, respectively
 
 #plot
Plot_42 <-ggplot(data=p.dat,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*46500))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*46500),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*10325),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*10325)),linetype=2)+ggtitle("GNI per Capita")
Plot_42                                   

```

###HTML output of the regressions:GNI - Cumulative Mortality
```{r,warning=FALSE, results='hide',message=FALSE}
stargazer(digits=6,regmoda,regmodb,regmodc,regmodd,type="html",se=list(se.a[,2],se.b[,2],se.c[,2],se.d[,2]),out="GNI_reg_output.htm",
          dep.var.labels=c("Weekly Avg. Cumulative Mortality Growth (t)"),
          covariate.labels=c("Mortality Growth (t-7)","Stringency (t-14) X GNI","Mortality Growth (t-14)","Stringency (t-21) X GNI","Mortality Growth (t-21)","Stringency (t-28) X GNI","Mortality Growth (t-28)","Stringency (t-35) X GNI"), df = FALSE,omit.stat="adj.rsq",notes = c("*,**,*** correspond to 10%, 5% and 1% significance, respectively.","HAC robust standard errors, clustered by country. Time and Country FEs."),notes.append=F,notes.align ="l",title="Heterogeneity: GNI per Capita",add.lines = list(c("Fixed effects?", "Y", "Y","Y","Y")))
```

#### Heterogeneity:health expenditure - Cumulative Mortality
```{r}
###baseline projection regressions, remove 'infinite' values. two-way FE, HAC robust SEs, clustered on country

regmoda<-plm(cum_mort_growth~Lag(cum_mort_growth,7)+Lag(StringencyIndex,c(14)):health_exp,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))
regmodb<-plm(cum_mort_growth~Lag(cum_mort_growth,14)+Lag(StringencyIndex,c(21)):health_exp,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))
regmodc<-plm(cum_mort_growth~Lag(cum_mort_growth,21)+Lag(StringencyIndex,c(28)):health_exp,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))
regmodd<-plm(cum_mort_growth~Lag(cum_mort_growth,28)+Lag(StringencyIndex,c(35)):health_exp,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))

### plot of 10-unit increase in Stringency effects over time on future mortality growth
 p.dat<-c(coef(regmoda)[2],coef(regmodb)[2],coef(regmodc)[2],coef(regmodd)[2])
 p.dat<-cbind(p.dat,p.dat+1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 p.dat<-cbind(p.dat,p.dat[,1]-1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 colnames(p.dat)<-c("mean","upper","lower")
 p.dat<-data.frame(p.dat)*10*100
 
 
###figure out the 25% percentile  and 75% percentile of elderly population rate across countries, to compare effects of a 10-unit rise in stringency level
 summary(unique(a$health_exp)) #roughly 2.2 and 51.2, respectively
 
 #plot
Plot_43 <-ggplot(data=p.dat,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*4292))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*4292),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*542),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*542)),linetype=2)+ggtitle("Health Expenditures")
Plot_43

```

###HTML output of the regressions:Health exp - Cumulative Mortality
```{r,warning=FALSE, results='hide',message=FALSE}
stargazer(digits=6,regmoda,regmodb,regmodc,regmodd,type="html",se=list(se.a[,2],se.b[,2],se.c[,2],se.d[,2]),out="healthexp_reg_output.htm",
          dep.var.labels=c("Weekly Avg. Cumulative Mortality Growth (t)"),
          covariate.labels=c("Mortality Growth (t-7)","Stringency (t-14) X Health Exp.","Mortality Growth (t-14)","Stringency (t-21) X Health Exp.","Mortality Growth (t-21)","Stringency (t-28) X Health Exp.","Mortality Growth (t-28)","Stringency (t-35) X Health Exp."), df = FALSE,omit.stat="adj.rsq",notes = c("*,**,*** correspond to 10%, 5% and 1% significance, respectively.","HAC robust standard errors, clustered by country. Time and Country FEs."),notes.append=F,notes.align ="l",title="Heterogeneity: Health Expenditures",add.lines = list(c("Fixed effects?", "Y", "Y","Y","Y")))
```

#### Heterogeneity: pollution - Cumulative Mortality
```{r}
###baseline projection regressions, remove 'infinite' values. two-way FE, HAC robust SEs, clustered on country

regmoda<-plm(cum_mort_growth~Lag(cum_mort_growth,7)+Lag(StringencyIndex,c(14)):pollution,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))
regmodb<-plm(cum_mort_growth~Lag(cum_mort_growth,14)+Lag(StringencyIndex,c(21)):pollution,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))
regmodc<-plm(cum_mort_growth~Lag(cum_mort_growth,21)+Lag(StringencyIndex,c(28)):pollution,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))
regmodd<-plm(cum_mort_growth~Lag(cum_mort_growth,28)+Lag(StringencyIndex,c(35)):pollution,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))

### plot of 10-unit increase in Stringency effects over time on future mortality growth
 p.dat<-c(coef(regmoda)[2],coef(regmodb)[2],coef(regmodc)[2],coef(regmodd)[2])
 p.dat<-cbind(p.dat,p.dat+1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 p.dat<-cbind(p.dat,p.dat[,1]-1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 colnames(p.dat)<-c("mean","upper","lower")
 p.dat<-data.frame(p.dat)*10*100
 
 
###figure out the 25% percentile  and 75% percentile of elderly population rate across countries, to compare effects of a 10-unit rise in stringency level
 summary(unique(a$pollution)) #roughly 10.4 and 23, respectively
 
 #plot
Plot_44 <-ggplot(data=p.dat,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*23))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*23),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*10.4),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*10.4)),linetype=2)+ggtitle("Pollution")
Plot_44                             

```

###HTML output of the regressions:Pollution - Cumulative Mortality
```{r,warning=FALSE, results='hide',message=FALSE}
stargazer(digits=6,regmoda,regmodb,regmodc,regmodd,type="html",se=list(se.a[,2],se.b[,2],se.c[,2],se.d[,2]),out="pollution_reg_output.htm",
          dep.var.labels=c("Weekly Avg. Cumulative Mortality Growth (t)"),
          covariate.labels=c("Mortality Growth (t-7)","Stringency (t-14) X Pollution","Mortality Growth (t-14)","Stringency (t-21) X Pollution","Mortality Growth (t-21)","Stringency (t-28) X Pollution","Mortality Growth (t-28)","Stringency (t-35) X Pollution"), df = FALSE,omit.stat="adj.rsq",notes = c("*,**,*** correspond to 10%, 5% and 1% significance, respectively.","HAC robust standard errors, clustered by country. Time and Country FEs."),notes.append=F,notes.align ="l",title="Heterogeneity: Pollution",add.lines = list(c("Fixed effects?", "Y", "Y","Y","Y")))
```

### Cumulative Mortality Plots
```{r}
grid.arrange(Plot_33,Plot_34,Plot_35,Plot_36,Plot_37,Plot_38,Plot_39,Plot_40,Plot_41,Plot_42,Plot_43,Plot_44,ncol=4,nrow=3)
```

### Weining Cross-Sectional Analysis - Cumulative Mortality

```{r Weining Cross Sectional Analysis - Cumulative Mortality}
library(lubridate)
library(zoo)
library(quantmod)
library(fBasics)
library(tseries)
library(sandwich)
library(lmtest)
library(lattice)
library(xtable)
library(vars)
library(plyr)
library(gridExtra)
library(corrplot)
library(ggplot2)
library(reshape2)
library(data.table)
library(rvest)
library(plm)
library(stringr)
library(stargazer)
library(survival)
library(ggfortify)
library(haven)
```

### Merging Global Preferences Survey data.
```{r}
# Remove factor variables for government responses
dat<-Final_Data_Country[,-c(48:125,151:154)]

gps.country <- read_dta("COVID-19_Final/data/global_preference_survey_country.dta")
# Change country names for merge
gps.country[which(gps.country$country == "South Korea"),"country"] <- "Korea, South"
gps.country[which(gps.country$country == "Czech Republic"),"country"] <- "Czechia"
gps.country[which(gps.country$country == "United States"),"country"] <- "US"

gps.individual <- read_dta("COVID-19_Final/data/global_preference_survey_individual.dta")
# Change country names for merge
gps.individual[which(gps.individual$country == "South Korea"),"country"] <- "Korea, South"
gps.individual[which(gps.individual$country == "Czech Republic"),"country"] <- "Czechia"
gps.individual[which(gps.individual$country == "United States"),"country"] <- "US"

gps.individual$age <- as.character(gps.individual$age)
gps.individual[which(gps.individual$age == "99 99+"), "age"] <- "99"
gps.individual[which(gps.individual$age == "100 (Refused"), "age"] <- NA
gps.individual$age <- as.numeric(gps.individual$age)
gps.individual.pop65 <- gps.individual[which(!is.na(gps.individual$age) & gps.individual$age > 65), ]
gps.individual.pop65 <- gps.individual.pop65[which(!is.na(gps.individual.pop65$trust)),]
gps.country.pop65 <- ddply(gps.individual.pop65, "country", function(X) data.frame(wm.trust = weighted.mean(X$trust, X$wgt)))

colnames(gps.country)[1] <- "COUNTRY"
dat <- merge(dat, gps.country, by=c("COUNTRY"), all.x=TRUE)
colnames(gps.country.pop65)[1] <- "COUNTRY"
dat <- merge(dat, gps.country.pop65, by=c("COUNTRY"), all.x=TRUE)
```

### Renaming variables and creating some new variables.
```{r}
aa<-pdata.frame(dat, index = c("COUNTRY", "Date"))
aa$Date<-as.Date(aa$Date,"%Y-%m-%d")
#reorder
aa<-aa[order(aa$Date),]
aa<-aa[order(aa$COUNTRY),]

colnames(aa)[4] <- "Total_Case_Country"
colnames(aa)[5] <- "Total_Death_Country"
colnames(aa)[6] <- "New_Case_Country"
colnames(aa)[7] <- "New_Death_Country"
colnames(aa)[9] <- "Total_Mortality_Rate"
colnames(aa)[10] <- "New_Mortality_Rate"
colnames(aa)[11] <- "Total_Case_Rate"
colnames(aa)[12] <- "RollingAverage_New_Case_Country"
colnames(aa)[13] <- "RollingAverage_New_Death_Country"
colnames(aa)[14] <- "RollingAverage_Total_Mortality_Rate"
colnames(aa)[15] <- "RollingAverage_New_Mortality_Rate"
colnames(aa)[16] <- "EIU_Democracy"

aa$New_Case_Rate = aa$New_Case_Country/aa$Population

aa <- aa %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(RollingAverage_Total_Case_Country = frollmean(Total_Case_Country, 7, na.rm=TRUE))
aa <- aa %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(RollingAverage_Total_Death_Country = frollmean(Total_Death_Country, 7,na.rm=TRUE))

aa <- aa %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(RollingAverage_Total_Case_Rate = frollmean(Total_Case_Rate, 7,na.rm=TRUE))

aa <- aa %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(RollingAverage_New_Case_Rate = frollmean(New_Case_Rate, 7,na.rm=TRUE))

## Select command is not working (says there's a problem with using grouped_df as the index type).
aa <- aa %>%
  dplyr::select(colnames(aa)[c(1:8,11,81,9,10,82,12,83,13,84,85,14,15)], everything())

## Why is total mortality growth always 0? Does it have to do with the log?
aa <- aa %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(Total_Mortality_Rate_Growth = log(RollingAverage_Total_Mortality_Rate) - log(lag(RollingAverage_Total_Mortality_Rate,7)))

aa$respiratory_deaths_rate <- 1/3*(aa$respiratory_deaths/aa$Population)

colnames(aa)
```

### Generating key endogenous variables used in cross-country analysis.
```{r}
first.date.mortality<-c(0)
first.date.case<-c(0)

peak.date.mortality<-c(0)
peak.date.case<-c(0)

days.to.peak.mortality<-c(0)
days.to.peak.case<-c(0)
peak.or.no.mortality<-c(0)
peak.or.no.case<-c(0)
country <- c("")

peak.mortality<-c(0)
peak.case<-c(0)

early.mortality<-c(0)
early.case<-c(0)

peak.new.mortality<-c(0)
peak.new.case<-c(0)

early.stringency<-c(0)
peak.stringency<-c(0)
peak.date.stringency<-c(0)

early.mobility.walking<-c(0)
early.mortality.growth<-c(0)
early.case.growth<-c(0)

dems_data<-aggregate(data=aa,cbind(prop65,propurban,popdensity,vul_emp,health_exp,GNI,pollution,Latitude,Longitude,EIU_Democracy,freedom_house)~COUNTRY,FUN=mean,na.rm=T)

for(i in 1:length(unique(dems_data$COUNTRY))){
  
  bb<-subset(aa,COUNTRY==unique(dems_data$COUNTRY)[i])
  country[i] <- as.character(unique(dems_data$COUNTRY)[i])
  bb<-bb[order(bb$Date),]
  bb<-bb[order(bb$COUNTRY),]
  bb <- bb %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(RollingAverage_Walking = frollmean(walking, 7))
  bb <- bb %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(RollingAverage_StringencyIndex = frollmean(StringencyIndex, 7))
  
  peak.new.mortality[i]<-max(bb$RollingAverage_New_Mortality_Rate,na.rm = TRUE) # Peak new mortality
  peak.new.case[i]<-max(bb$RollingAverage_New_Case_Rate, na.rm = TRUE) # Peak new case
  
  peak.date.mortality[i]<-as.character(bb$Date[which((bb$RollingAverage_New_Mortality_Rate==peak.new.mortality[i]))]) # Peak date of new mortality
  first.date.mortality[i]<-as.character(bb$Date[which(bb$Total_Death_Country>0)[1]]) # Date of first death
  peak.mortality[i]<-bb$RollingAverage_Total_Mortality_Rate[which(bb$RollingAverage_New_Mortality_Rate==peak.new.mortality[i])] # Total mortality rate at the peak

  peak.date.case[i]<-as.character(bb$Date[which((bb$RollingAverage_New_Case_Rate==peak.new.case[i]))]) # Peak date of new case
  first.date.case[i]<-as.character(bb$Date[which(bb$Total_Case_Country>0)[1]]) # Date of first case
  peak.case[i]<-bb$RollingAverage_Total_Case_Rate[which.max(bb$RollingAverage_New_Case_Rate==peak.new.case[i])] # Toal case rate at the peak
  
  days.to.peak.mortality[i]<-as.Date(peak.date.mortality[i])-as.Date(first.date.mortality[i])
  peak.or.no.mortality[i]<-ifelse(peak.date.mortality[i]==max(bb$Date),0,1)
  
  days.to.peak.case[i]<-as.Date(peak.date.case[i])-as.Date(first.date.case[i])
  peak.or.no.case[i]<-ifelse(peak.date.case[i]==max(bb$Date),0,1)
  
  early.mortality[i]<-bb$RollingAverage_Total_Mortality_Rate[which(bb$Total_Death_Country>0)[7]] # Total death rate in the first week since first death
  early.mortality.growth[i]<-log(bb$RollingAverage_New_Mortality_Rate[which(bb$Total_Death_Country>0)[7]]) -  log(bb$RollingAverage_New_Mortality_Rate[which(bb$Total_Death_Country>0)[1]])# Growth rate of new mortality rate in the first week since first death
  
  early.case[i]<-bb$RollingAverage_Total_Case_Rate[which(bb$Total_Case_Country>0)[7]] # Total case rate in the first week since first case
  if (bb$RollingAverage_New_Case_Rate[which(bb$Total_Case_Country>0)[1]] == 0){
    early.case.growth[i]<-log(bb$RollingAverage_New_Case_Rate[which(bb$Total_Case_Country>0)[7]]) -  log(bb$RollingAverage_Total_Case_Rate[which(bb$Total_Case_Country>0)[1]])# Growth rate of new case rate in the first week since first case
  }else{
    early.case.growth[i]<-log(bb$RollingAverage_New_Case_Rate[which(bb$Total_Case_Country>0)[7]]) -  log(bb$RollingAverage_New_Case_Rate[which(bb$Total_Case_Country>0)[1]])# Growth rate of new case rate in the first week since first case
  }
  early.mobility.walking[i]<-bb$RollingAverage_Walking[which(bb$Total_Death_Country>0)[1]-1] # Weekly average walking mobility in the week prior to first death
  
  early.stringency[i]<-bb$RollingAverage_StringencyIndex[which(bb$Total_Death_Country>0)[1]-7] #Weekly average stringency index in the week prior to first death
  peak.stringency[i]<-max(bb$StringencyIndex,na.rm=T)
  
  if (peak.stringency[i] == -Inf){
    peak.date.stringency[i] <- -Inf
  }else{
    peak.date.stringency[i]<-as.character(bb$Date[which.max(bb$StringencyIndex)])
  }
}

stringency.growth.to.max<-(peak.stringency-early.stringency)/as.numeric(as.Date(peak.date.stringency)-as.Date(first.date.mortality))
log.peak.mortality.to.duration <- log(peak.new.mortality)/as.numeric(days.to.peak.mortality)
log.peak.case.to.duration <- log(peak.new.case)/as.numeric(days.to.peak.case)

# set NA early stringency to 0
# early.string[is.na(early.string)]<-0

```

### Cumulative Mortality Cross-Sectional Dataset.
```{r}
surv.dat<-data.frame(country,days.to.peak.mortality,peak.or.no.mortality,
                     days.to.peak.case,peak.or.no.case,
                     early.mortality,early.mortality.growth,
                     early.case,early.case.growth,
                     peak.mortality,peak.case,peak.new.mortality,peak.new.case,
                     log.peak.mortality.to.duration,log.peak.case.to.duration,
                     early.stringency,stringency.growth.to.max,peak.stringency,early.mobility.walking,dems_data[,-1])

#remove vietnam
surv.dat<-surv.dat[-nrow(surv.dat),]
surv.dat<-mutate(surv.dat,stringent=ifelse(early.stringency>19,"SI>19","SI<19"),stringent=factor(stringent))
```

### Plotting K-P curves for confirmed cases.
```{r}
km_fit <- survfit(Surv(days.to.peak.case,peak.or.no.case) ~1, data=surv.dat)

p1<-autoplot(km_fit)+theme_bw()+xlab("Number of Days")+ylab("Probability Case Peak is Yet to Come")
km_fit2<-survfit(Surv(days.to.peak.case,peak.or.no.case)~stringent, data=surv.dat)
p2<-autoplot(km_fit2)+theme_bw()+xlab("Number of Days")+ylab("Probability Case Peak is Yet to Come")+theme(legend.position = c(0.2, 0.2),legend.title=element_blank())
p3<-ggplot(data=surv.dat,aes(x=early.stringency,fill=stringent))+geom_histogram(color="black",alpha=.5)+theme_bw()+xlab("Average SI in the Week Prior to First Death")+ylab("Frequency of Countries")+theme(legend.title = element_blank(),legend.position = c(0.8,0.6))
g <- grid.arrange(p1, p2, p3, nrow=1)
# g <- arrangeGrob(p1,p2,p3,nrow=1)
ggsave("Figure_cox_case.png", g, width = 15, height = 7)
```

### Plotting K-P curves for cumulative mortality.
```{r}
km_fit <- survfit(Surv(days.to.peak.mortality,peak.or.no.mortality) ~1, data=surv.dat)

p1<-autoplot(km_fit)+theme_bw()+xlab("Number of Days")+ylab("Probability Mortality Peak is Yet to Come")
km_fit2<-survfit(Surv(days.to.peak.mortality,peak.or.no.mortality)~stringent, data=surv.dat)
p2<-autoplot(km_fit2)+theme_bw()+xlab("Number of Days")+ylab("Probability Mortality Peak is Yet to Come")+theme(legend.position = c(0.2, 0.2),legend.title=element_blank())
p3<-ggplot(data=surv.dat,aes(x=early.stringency,fill=stringent))+geom_histogram(color="black",alpha=.5)+theme_bw()+xlab("Average SI in the Week Prior to First Death")+ylab("Frequency of Countries")+theme(legend.title = element_blank(),legend.position = c(0.8,0.6))
g <- grid.arrange(p1, p2, p3, nrow=1)
# g <- arrangeGrob(p1,p2,p3,nrow=1)
ggsave("Figure_cox_mortality.png", g, width = 15, height = 7)

```

### Cox proportional hazard regression.
```{r}
cox.death<-coxph(Surv(days.to.peak.mortality,peak.or.no.mortality) ~
                   log(peak.new.mortality)+log(early.mortality)+early.mortality.growth+
                   early.stringency+stringency.growth.to.max+early.mobility.walking+
                   prop65+propurban+popdensity+vul_emp+log(GNI)+EIU_Democracy+Latitude:Longitude,data=surv.dat)

cox.case<-coxph(Surv(days.to.peak.case,peak.or.no.case) ~
                   log(peak.new.case)+log(early.case)+early.case.growth+
                   early.stringency+stringency.growth.to.max+early.mobility.walking+
                   prop65+propurban+popdensity+vul_emp+log(GNI)+EIU_Democracy+Latitude:Longitude,data=surv.dat)
```

### Testing the proportional hazards assumption.
```{r}
test.death<-cox.zph(cox.death)$table[nrow(cox.zph(cox.death)$table),ncol(cox.zph(cox.death)$table)]
test.case<-cox.zph(cox.case)$table[nrow(cox.zph(cox.case)$table),ncol(cox.zph(cox.case)$table)]

```

### HTML output of the Cox hazard model
```{r,warning=FALSE, results='hide',message=FALSE}
stargazer(cox.death,cox.case,type="html",out="Table_cox_reg_output.htm",
          dep.var.labels=c("Survival Probability of Mortality Peaking at Time (t)", "Survival Probability of Case Peaking at Time (t)"), 
          covariate.labels = c("Log(Peak Mortality)", "Log(Early Mortality)", "Early Mortality Growth",
                               "Log(Peak Case)", "Log(Early Case)", "Early Case Growth",
                              "Early Stringency","Stringency Growth to Maximum", "Early Mobility",
                              "Prop. 65+","Prop. Urban","Pop. Density","Vulnerable Emp.",
                              "Log(GNI)","EIU Democracy","Latitude-Longitude"),
          df = FALSE,omit.stat =c("max.rsq","logrank"),
          notes = c("*,**,*** correspond to 10%, 5% and 1% significance, respectively.","PH Test refers to testing the proportional hazards assumption (Grambsch and Therneau (1994)).","Null hypothesis is the assumption is not violated."),
          notes.append=F,notes.align ="l",
          title=("Cox Proportional Hazards Regression: Duration to Peak Mortality"),
          add.lines = list(c("PH Test p-value",round(test.death,3),round(test.case,3))))
```

### Cross-country analysis of peak mortality.
```{r}
### - peak cum. mortality - 
cs.total.mortality<- lm(log(peak.mortality) ~ 
                          log(early.mortality)+early.mortality.growth+
                          early.stringency+stringency.growth.to.max+early.mobility.walking+
                          prop65+propurban+popdensity+vul_emp+log(GNI)+EIU_Democracy+Latitude:Longitude,data=surv.dat)
se.total.mortality<-coeftest(cs.total.mortality, vcov = vcovHC(cs.total.mortality, type = "HC1"))

### - peak new mortality - 
cs.new.mortality<- lm(log(peak.new.mortality) ~ 
                       log(early.mortality)+early.mortality.growth+
                       early.stringency+stringency.growth.to.max+early.mobility.walking+
                       prop65+propurban+popdensity+vul_emp+log(GNI)+EIU_Democracy+Latitude:Longitude,data=surv.dat)
se.new.mortality<-coeftest(cs.new.mortality, vcov = vcovHC(cs.new.mortality, type = "HC1"))

### - peak new mortality to duration ratio - 
cs.peak.duration.ratio<- lm(log.peak.mortality.to.duration ~ 
                                  log(early.mortality)+early.mortality.growth+
                                  early.stringency+stringency.growth.to.max+early.mobility.walking+
                                  prop65+propurban+popdensity+vul_emp+log(GNI)+EIU_Democracy+Latitude:Longitude,data=surv.dat)
se.peak.duration.ratio<-coeftest(cs.peak.duration.ratio, vcov = vcovHC(cs.peak.duration.ratio, type = "HC1"))

```

### HTML output of the cross-country analysis
```{r,warning=FALSE, results='hide',message=FALSE}
stargazer(cs.total.mortality,cs.new.mortality,cs.peak.duration.ratio,
          se=list(se.total.mortality[,2],se.new.mortality[,2],se.peak.duration.ratio[,2]),type="html",out="Table_cs_reg_output.htm",intercept.bottom = FALSE,
          dep.var.labels=c("Log(Peak Cum. Mortality Rate)", "Log(Peak New Mortality Rate)", "Peak New Moratlity Rate to Duration Rato"),
          covariate.labels=c("Intercept","Log(Early Mortality)","Early Mortality Growth",
                             "Early Stringency","Stringency Growth to Maximum", "Early Mobility",
                             "Prop. 65+","Prop. Urban","Pop. Density","Vulnerable Emp.", "Log(GNI)",
                             "EIU Democracy","Latitude-Longitude"), 
          df = FALSE,notes = c("*,**,*** correspond to 10%, 5% and 1% significance, respectively.","Heteroscedastic-Robust standard errors"),
          notes.append=F,notes.align ="l",font.size = "tiny",
          title=("Cross-Country Regression: Explaining Differences in First-Wave Mortality Rates"))
```

### Correlation matrix of explanatory variables
```{r}
cor.surv.dat <- surv.dat[,-c(1,3,5,30,31)]
colnames(cor.surv.dat)<-c("PD to Peak Mortality", "PD to Peak Confirmed Case", "Early Mortality", "Early Mortality Growth",
                     "Early Confirmed Case", "Early Confirmed Case Growth",
                     "Peak Cum. Mortality", "Peak Cum. Confirmed Case", 
                     "Peak New Mortality", "Peak New Confirmed Case",
                     "Logged Peak Mortality-to-PD", "Logged Peak Case-to-PD", 
                     "Early Stringency", "Stringency Delta", "Peak Stringency",
                     "Early Mobility",
                     "Prop. 65+", "Prop. Urban", "Pop. Density", 
                     "Vulnerable Emp.","Health Exp.","GNI","Pollution","Latitude","Longitude","Democracy")
cormat<-round(cor(cor.surv.dat,use = "complete.obs"), 2)

# Here, I get the lower triangle of the correlation matrix
get_lower_tri<-function(cormat){
  cormat[upper.tri(cormat)] <- NA
  return(cormat)
}
# Now, I get the upper triangle of the correlation matrix
get_upper_tri <- function(cormat){
  cormat[lower.tri(cormat)]<- NA
  return(cormat)
}
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}
cormat <- reorder_cormat(cormat)
melted_cormat <- reshape2::melt(get_upper_tri(cormat), na.rm = TRUE)

### Generate the Static Correlation Map
ggheatmap <- ggplot(data = melted_cormat, aes(x=Var2, y=Var1, fill=value)) + 
  geom_tile(color = "black") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white",
    midpoint = 0, limit = c(-1,1), space = "Lab", 
    name="Pearson\nCorrelation") +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 45)) +
  theme(axis.text.x = element_text(margin = margin(t = 5, r = 0, b = 0, l = 0))) +
  theme(axis.text.x = element_text(hjust=1))+coord_fixed()

p.cor <- ggheatmap + 
geom_text(aes(Var2, Var1, label = value), color = "black", size = 1.75) +
theme(
  axis.title.x = element_blank(),
  axis.title.y = element_blank(),
  axis.text=element_text(size=7),
  panel.grid.major = element_blank(),
  panel.border = element_blank(),
  panel.background = element_blank(),
  axis.ticks = element_blank(),
  legend.justification = c(1, 0),
  legend.position = c(0.4, 0.8),
  legend.direction = "horizontal",
  legend.title = element_text(size = 6),
  legend.text=element_text(size=6))+
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                title.position = "top", title.hjust = 0.5))

# Print the heatmap
print(p.cor)
ggsave("Figure_corrmat_covariate.png",p.cor,width=8, height=8)

```

### Generating Table 3B.
```{r}
### Correlation matrix of government interventions
cor.policy.dat <- a[,c("C1_School.closing", 
                      "C2_Workplace.closing",
                      "C3_Cancel.public.events",
                      "C4_Restrictions.on.gatherings",
                      "C5_Close.public.transport",            
                      "C6_Stay.at.home.requirements",         
                      "C7_Restrictions.on.internal.movement", 
                      "C8_International.travel.controls",
                      "H1_Public.information.campaigns",
                      "StringencyIndex")]
colnames(cor.policy.dat) <- c("School Closing", 
                      "Workplace Closing",
                      "Cancel Public Events",
                      "Gathering Restrictions",
                      "Close Public Transport",            
                      "Stay at Home",         
                      "Internal Movement Restrictions", 
                      "International Travel Controls",
                      "Public Information Campaigns",
                      "Stringency Index")
cormat<-round(cor(cor.policy.dat,use = "complete.obs"), 2)

# Here, I get the lower triangle of the correlation matrix
get_lower_tri<-function(cormat){
  cormat[upper.tri(cormat)] <- NA
  return(cormat)
}
# Now, I get the upper triangle of the correlation matrix
get_upper_tri <- function(cormat){
  cormat[lower.tri(cormat)]<- NA
  return(cormat)
}
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}
cormat <- reorder_cormat(cormat)
melted_cormat <- reshape2::melt(get_upper_tri(cormat), na.rm = TRUE)

### Generate the Static Correlation Map
ggheatmap <- ggplot(data = melted_cormat, aes(x=Var2, y=Var1, fill=value)) + 
  geom_tile(color = "black") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white",
    midpoint = 0, limit = c(-1,1), space = "Lab", 
    name="Pearson\nCorrelation") +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 45)) +
  theme(axis.text.x = element_text(margin = margin(t = 5, r = 0, b = 0, l = 0))) +
  theme(axis.text.x = element_text(hjust=1))+coord_fixed()

p.cor <- ggheatmap + 
labs(caption = "Note: We consider pandemic policy interventions, which refer to containment\nand closure policies, as well as public information campaign in the Oxford\nCOVID-19 Government Response Tracker (OxCGRT). The Stringency Index\nis a weighted average of the scores of these pandemic policy interventions.") + 
geom_text(aes(Var2, Var1, label = value), color = "black", size = 1.75) +
theme(
  axis.title.x = element_blank(),
  axis.title.y = element_blank(),
  axis.text=element_text(size=7),
  panel.grid.major = element_blank(),
  panel.border = element_blank(),
  panel.background = element_blank(),
  axis.ticks = element_blank(),
  legend.justification = c(1, 0),
  legend.position = c(0.6, 0.7),
  legend.direction = "horizontal",
  legend.title = element_text(size = 7),
  legend.text=element_text(size=7),
  plot.caption = element_text(size = 7, hjust=0))+
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                title.position = "top", title.hjust = 0.5))

# Print the heatmap
print(p.cor)
ggsave("Figure_corrmat_policy.png",p.cor,width=5, height=5)

```

### Summary statistics of country characteristics
```{r}
cor.sum.dat <- surv.dat[,-c(1,3,5,30,31)]
cor.sum.dat$early.mortality <- cor.sum.dat$early.mortality * 10000000
cor.sum.dat$early.case <- cor.sum.dat$early.case * 10000000
cor.sum.dat$peak.mortality <- cor.sum.dat$peak.mortality * 100000
cor.sum.dat$peak.new.mortality <- cor.sum.dat$peak.new.mortality * 10000000
cor.sum.dat$peak.case <- cor.sum.dat$peak.case * 100000
cor.sum.dat$peak.new.case <- cor.sum.dat$peak.new.case * 10000000
cor.sum.dat$GNI <- log(cor.sum.dat$GNI)
colnames(cor.sum.dat)<-c("PD to Peak Mortality", "PD to Peak Confirmed Case",
                          "Early Mortality", "Early Mortality Growth",
                          "Early Confirmed Case", "Early Confirmed Case Growth",
                          "Peak Cum. Mortality", "Peak Cum. Confirmed Case", 
                          "Peak New Mortality", "Peak New Confirmed Case",
                          "Logged Peak Mortality-to-PD", "Logged Peak Case-to-PD", 
                          "Early Stringency", "Stringency Delta", "Peak Stringency",
                          "Early Mobility",
                          "Prop. 65+", "Prop. Urban", "Pop. Density", 
                          "Vulnerable Emp.","Health Exp.","Log(GNI)","Pollution","Latitude","Longitude","Democracy")
cor.sum.dat <- cor.sum.dat %>%
  dplyr::select(c("Early Mortality", "Early Mortality Growth", "Early Confirmed Case", "Early Confirmed Case Growth", "Peak Cum. Mortality", "Peak Cum. Confirmed Case", "Peak New Mortality", "Peak New Confirmed Case", "Logged Peak Mortality-to-PD", "Logged Peak Case-to-PD"), everything())

sum.stats <- t(round(basicStats(cor.sum.dat),3))
sum.stats <- data.frame(sum.stats[,c("nobs", "NAs", "Minimum", "Maximum", "1. Quartile", "3. Quartile", "Mean", "Median", "Stdev")])
sum.stats$N <- sum.stats$nobs - sum.stats$NAs
sum.stats <- sum.stats[,-c(1,2)]
sum.stats <- sum.stats %>%
  dplyr::select(c("N", "Minimum", "Maximum", "Mean", "Median", "Stdev"), everything())
colnames(sum.stats) <- c("N", "Minimum", "Maximum", "Mean", "Median", "Stdev", "1st Quartile", "3rd Quartile")
peak.stringency.finite <- cor.sum.dat$`Peak Stringency`[which(is.finite(cor.sum.dat$`Peak Stringency`))]
# sum.stats["Early.Mortality", ] <- scientific(sum.stats["Early.Mortality", ], digits = 7)
sum.stats["Peak.Stringency", ] <- c(length(peak.stringency.finite), min(peak.stringency.finite), max(peak.stringency.finite),
                                    mean(peak.stringency.finite), median(peak.stringency.finite), stdev(peak.stringency.finite), 
                                    quantile(peak.stringency.finite)[2], quantile(peak.stringency.finite)[4])
stargazer(sum.stats,type="html",summary = FALSE, out="Table_summary_country_char.htm",title="Country Characteristics: Summary")
```

### Table of variable definitions and sources
```{r}

df.definition <- data.frame("Variable" = c("Cum. Mortality Rate", "New Mortality Rate",
                                           "Early Mortality", "Early Mortality Growth", "Peak Cum. Mortality", "Peak New Mortality",
                                           "PD to Peak Mortality", "Logged Peak Mortality-to-PD",
                                           "Early Confirmed Case", "Early Confirmed Case Growth", "Peak Cum. Confirmed Case", "Peak New Confirmed Case",
                                           "PD to Peak Confirmed Case", "Logged Peak Case-to-PD", 
                                           "Early Stringency", "Stringency Delta", "Peak Stringency",
                                           "Early Mobility",
                                           "Prop. 65+", "Prop. Urban", "Pop. Density", 
                                           "Vulnerable Employment","Health Expenditure","Log(GNI)","Pollution",
                                           "Tourist Arrivals", "Tourist Departures",
                                           "Latitude","Longitude","Democracy"),
                            "Definition" = c("7-day rolling average of cumulative mortality rate out of the total population",
                                             "7-day rolling average of daily new mortality rate out ot the total population",
                                             "Cumulative mortality rate in the week following the first death",
                                             "Growth rate of new mortality rate in the week following the first death",
                                             "Cumulative mortality rate at the peak of new mortality rate in the first quasi-bell curve",
                                             "New mortality rate at the peak of new mortality rate in the first quasi-bell curve",
                                             "Day-to-peak of new mortality rate in the first quasi-bell curve",
                                             "The ratio of the logged peak new mortality rate to the PD to peak mortality",
                                             "Cumulative confirmed case rate in the week following the first case",
                                             "Growth rate of new confirmed case rate in the week following the first case",
                                             "Cumulative confirmed case rate at the peak of new confirmed case rate in the first quasi-bell curve",
                                             "New confirmed case rate at the peak of new confirmed case rate in the first quasi-bell curve",
                                             "Day-to-peak of new confirmed case rate in the first quasi-bell curve",
                                             "The ratio of the logged peak new confirmed case rate to the PD to peak confirmed case",
                                             "Weekly average stringency index in the week prior to the first death",
                                             "Growth rate of SI from the week prior to the first death to the maximum level of stringency",
                                             "Maximum level of stringency index in the first quasi-bell curve",
                                             "Weekly average level of mobility in terms of walking in the week prior to the first death, reported by Apple",
                                             "Elderly population (people aged 65 and over) as a percentage of the total population",
                                             "Urban population as a percentage of the total population",
                                             "Midyear population divided by land area in square kilometers",
                                             "Employment in vulnerable sectors (i.e., family workers and own-account workers) as a percentage of the total employment",
                                             "Level of current health expenditure (including healthcare goods and services) as a percentage of GDP",
                                             "The logged gross national income per capita",
                                             "Population-weighted exposure to ambient PM2.5 pollution",
                                             "International inbound tourists to the country",
                                             "International outbound tourists from the country",
                                             "Latitude coordinate of the country",
                                             "Longitude coordinate of the country",
                                             "The Democracy index calculated by The Economist Intelligence Unit"
                                             ),
                            "Source" = c("Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on OxCGRT Data",
                                         "Authors' calculation based on OxCGRT Data",
                                         "Authors' calculation based on OxCGRT Data",
                                         "Authors' calculation based on Apple COVID-19 Mobility Trends Reports",
                                         "World Development Indicators",
                                         "World Development Indicators",
                                         "World Development Indicators",
                                         "World Development Indicators",
                                         "World Development Indicators",
                                         "World Development Indicators",
                                         "World Development Indicators",
                                         "World Development Indicators",
                                         "World Development Indicators",
                                         "Country-level coordinates from Google",
                                         "Country-level coordinates from Google",
                                         "The EIU Democracy Index 2019 Database"
                                         )
                              )
rownames(df.definition) <- NULL
stargazer(df.definition,type="html",rownames = FALSE, summary = FALSE, out="Table_variable_definition.htm")
```

### WEEKLY MORTALITY RATES - Panel + Cross-Sectional Analysis

### PANEL REGRESSION
```{r Rashad Panel Analysis - Weekly Mortality}
### Creating new weekly mortality growth and running libraries.
library(lubridate)
library(zoo)
library(quantmod)
library(fBasics)
library(tseries)
library(sandwich)
library(lmtest)
library(lattice)
library(xtable)
library(vars)
library(plyr)
library(gridExtra)
library(corrplot)
library(ggplot2)
library(reshape2)
library(data.table)
library(rvest)
library(plm)
library(stringr)
library(stargazer)
library(haven)
# Remove factor variables for government responses
datweekly_panel<-Final_Data_Country[,-c(48:125,151:154)]
```

### Merging global preference survey data.
```{r}
gps.country <- read_dta("COVID-19_Final/data/global_preference_survey_country.dta")

# Change country names for merge
gps.country[which(gps.country$country == "South Korea"),"country"] <- "Korea, South"
gps.country[which(gps.country$country == "Czech Republic"),"country"] <- "Czechia"
gps.country[which(gps.country$country == "United States"),"country"] <- "US"

gps.individual <- read_dta("COVID-19_Final/data/global_preference_survey_individual.dta")

# Change country names for merge
gps.individual[which(gps.individual$country == "South Korea"),"country"] <- "Korea, South"
gps.individual[which(gps.individual$country == "Czech Republic"),"country"] <- "Czechia"
gps.individual[which(gps.individual$country == "United States"),"country"] <- "US"

gps.individual$age <- as.character(gps.individual$age)
gps.individual[which(gps.individual$age == "99 99+"), "age"] <- "99"
gps.individual[which(gps.individual$age == "100 (Refused"), "age"] <- NA
gps.individual$age <- as.numeric(gps.individual$age)
gps.individual.pop65 <- gps.individual[which(!is.na(gps.individual$age) & gps.individual$age > 65), ]
gps.individual.pop65 <- gps.individual.pop65[which(!is.na(gps.individual.pop65$trust)),]
gps.country.pop65 <- ddply(gps.individual.pop65, "country", function(X) data.frame(wm.trust = weighted.mean(X$trust, X$wgt)))

colnames(gps.country)[1] <- "COUNTRY"
datweekly_panel <- merge(datweekly_panel, gps.country, by=c("COUNTRY"), all.x=TRUE)
colnames(gps.country.pop65)[1] <- "COUNTRY"
datweekly_panel <- merge(datweekly_panel, gps.country.pop65, by=c("COUNTRY"), all.x=TRUE)
```

### Renaming variables and creating some new variables.
```{r}
datweekly_panel<-pdata.frame(datweekly_panel, index = c("COUNTRY", "Date"))
datweekly_panel$Date<-as.Date(datweekly_panel$Date,"%Y-%m-%d")
#reorder
datweekly_panel<-datweekly_panel[order(datweekly_panel$Date),]
datweekly_panel<-datweekly_panel[order(datweekly_panel$COUNTRY),]

colnames(datweekly_panel)[4] <- "Total_Case_Country"
colnames(datweekly_panel)[5] <- "Total_Death_Country"
colnames(datweekly_panel)[6] <- "New_Case_Country"
colnames(datweekly_panel)[7] <- "New_Death_Country"
colnames(datweekly_panel)[9] <- "Total_Mortality_Rate"
colnames(datweekly_panel)[10] <- "New_Mortality_Rate"
colnames(datweekly_panel)[11] <- "Total_Case_Rate"
colnames(datweekly_panel)[12] <- "RollingAverage_New_Case_Country"
colnames(datweekly_panel)[13] <- "RollingAverage_New_Death_Country"
colnames(datweekly_panel)[14] <- "RollingAverage_Total_Mortality_Rate"
colnames(datweekly_panel)[15] <- "RollingAverage_New_Mortality_Rate"
colnames(datweekly_panel)[62] <- "EIU_Democracy"
datweekly_panel$RollingAverage_Total_Mortality_Rate <- NULL
datweekly_panel$longitude <- NULL

datweekly_panel$New_Case_Rate = datweekly_panel$New_Case_Country/datweekly_panel$Population

datweekly_panel <- datweekly_panel %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(RollingAverage_New_Case_Rate = frollmean(New_Case_Rate, 7,na.rm=TRUE))

datweekly_panel <- datweekly_panel %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(Total_Mortality_Rate_Growth = log(Total_Mortality_Rate) - Lag(log(Total_Mortality_Rate),7))

datweekly_panel <- datweekly_panel %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(Total_Case_Rate_Growth = log(Total_Case_Rate) - Lag(log(Total_Case_Rate),7))

datweekly_panel <- datweekly_panel %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(New_Case_Rate_Growth = log(RollingAverage_New_Case_Rate) - Lag(log(RollingAverage_New_Case_Rate),7))

datweekly_panel <- datweekly_panel %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(New_Mortality_Rate_Growth = log(RollingAverage_New_Mortality_Rate) - Lag(log(RollingAverage_New_Mortality_Rate),7))

datweekly_panel$respiratory_deaths_rate <- 1/3*(datweekly_panel$respiratory_deaths/datweekly_panel$Population)
```

```{r}
### Reorder columns
datweekly_panel <- datweekly_panel %>%
  dplyr::select(c("COUNTRY", "X1", "Date", "Total_Case_Country", "Total_Death_Country", "New_Case_Country", "New_Death_Country", "Population", "Total_Case_Rate", "Total_Mortality_Rate", "New_Case_Rate", "New_Mortality_Rate", "RollingAverage_New_Case_Country", "RollingAverage_New_Death_Country", "RollingAverage_New_Case_Rate", "RollingAverage_New_Mortality_Rate", "Total_Case_Rate_Growth", "Total_Mortality_Rate_Growth", "New_Case_Rate_Growth", "New_Mortality_Rate_Growth"), everything())

datweekly_panel$Total_Case_Rate_Growth[is.nan(datweekly_panel$Total_Case_Rate_Growth)] <- NA
datweekly_panel$Total_Mortality_Rate_Growth[is.nan(datweekly_panel$Total_Mortality_Rate_Growth)] <- NA

datweekly_panel$New_Case_Rate_Growth[is.nan(datweekly_panel$New_Case_Rate_Growth)] <- NA
datweekly_panel$New_Mortality_Rate_Growth[is.nan(datweekly_panel$New_Mortality_Rate_Growth)] <- NA

datweekly_panel$New_Mortality_Rate_Growth[is.infinite(-datweekly_panel$New_Mortality_Rate_Growth)] <- Inf

colnames(datweekly_panel)
```

### Baseline regressions
```{r}
datweekly_panel <- datweekly_panel %>% dplyr::ungroup()
datweekly_panel<-pdata.frame(datweekly_panel, index = c("COUNTRY", "Date"))
datweekly_panel<-datweekly_panel[order(datweekly_panel$Date),]
datweekly_panel<-datweekly_panel[order(datweekly_panel$COUNTRY),]

###baseline projection regressions, remove 'infinite' values. two-way FE, HAC robust SEs, clustered on country
regmoda<-plm(New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,7)+Lag(StringencyIndex,c(14)),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(datweekly_panel$New_Mortality_Rate_Growth)),],na.action="na.exclude")
se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))

regmodb<-plm(New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,14)+Lag(StringencyIndex,c(21)),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(datweekly_panel$New_Mortality_Rate_Growth)),],na.action="na.exclude")
se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))

regmodc<-plm(New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,21)+Lag(StringencyIndex,c(28)),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(datweekly_panel$New_Mortality_Rate_Growth)),],na.action="na.exclude")
se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))

regmodd<-plm(New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,28)+Lag(StringencyIndex,c(35)),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(datweekly_panel$New_Mortality_Rate_Growth)),],na.action="na.exclude")
se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))
```

### HTML output of baseline regression results
```{r,warning=FALSE, results='hide',message=FALSE}
stargazer(digits=6,regmoda,regmodb,regmodc,regmodd,type="html",se=list(se.a[,2],se.b[,2],se.c[,2],se.d[,2]), out="Table_panel_reg_output_weekly.htm",
          dep.var.labels=c("Weekly Avg. New Mortality Growth (t)"),
          covariate.labels=c("New Mortality Growth (t-7)","Stringency (t-14)","New Mortality Growth (t-14)","Stringency (t-21)","New Mortality Growth (t-21)","Stringency (t-28)","New Mortality Growth (t-28)","Stringency (t-35)"), df = FALSE,omit.stat="adj.rsq",notes = c("*,**,*** correspond to 10%, 5% and 1% significance, respectively.","HAC robust standard errors, clustered by country. Time and Country FEs."),notes.append=F,notes.align ="l",title="Table 1. Mortality Projection - Average Impact",add.lines = list(c("Fixed effects?", "Y", "Y","Y","Y")))
```

### Plots
```{r}
### plot of 10-unit increase in Stringency effects over time on future mortality growth
p.dat_weekly<-c(coef(regmoda)[2],coef(regmodb)[2],coef(regmodc)[2],coef(regmodd)[2])
p.dat_weekly<-cbind(p.dat_weekly,p.dat_weekly+1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
p.dat_weekly<-cbind(p.dat_weekly,p.dat_weekly[,1]-1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
colnames(p.dat_weekly)<-c("mean","upper","lower")
p.dat_weekly<-data.frame(p.dat_weekly)*10*100

Plot_59 <-ggplot(data=p.dat_weekly,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean))+geom_point(size=4,shape=21,fill="grey")+geom_hline(yintercept=0,linetype=2)+xlab("Increase in Stringency Index of 10 units")+theme_bw()+ylab("Effect on New Mortality Growth (%)")+geom_errorbar(aes(ymin=lower,ymax=upper))
Plot_59
```

### Generating Figure 5.
```{r}                                                             
Plot_60 <-ggplot(data=p.dat_weekly,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean))+geom_point(size=4,shape=21,fill="grey")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on New Mortality Growth (%)")+geom_errorbar(aes(ymin=lower,ymax=upper))+ggtitle("Average Impact")
Plot_60
```

### RESULTS DON'T MATCH

### Loop to generate heterogeneity regression results
```{r}
###baseline projection regressions, remove 'infinite' values. two-way FE, HAC robust SEs, clustered on country
var.list <- c("prop65", "propurban", "Latitude", "Longitude", "popdensity", "arrivals", "departures", "vul_emp", "GNI", "health_exp", "pollution", "EIU_Democracy", "trust", "risktaking")
label.list <- c("Proportion 65+", "Proportion Urban", "Latitude", "Longitude", "Population Density", "Log(Arrivals)", "Log(Departures)", "Vulnerable Employees", "GNI per capita", "Health Expenditures", "Pollution", "EIU Democracy", "Trust", "Risk Taking")

p.dat.list <- list()
s.list <- list()

for (i in c(1:length(var.list))){

   var <- var.list[i]
   label <- label.list[i]
   
   if (var == "arrivals" || var == "departures"){
         regmoda<-plm(as.formula(paste("New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,7)+Lag(StringencyIndex,c(14)):","log(",var,")")),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(datweekly_panel$New_Mortality_Rate_Growth)),],na.action="na.exclude")
   se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))
   regmodb<-plm(as.formula(paste("New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,14)+Lag(StringencyIndex,c(21)):","log(",var,")")),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(datweekly_panel$New_Mortality_Rate_Growth)),],na.action="na.exclude")
   se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))
   regmodc<-plm(as.formula(paste("New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,21)+Lag(StringencyIndex,c(28)):","log(",var,")")),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(datweekly_panel$New_Mortality_Rate_Growth)),],na.action="na.exclude")
   se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))
   regmodd<-plm(as.formula(paste("New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,28)+Lag(StringencyIndex,c(35)):","log(",var,")")),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(datweekly_panel$New_Mortality_Rate_Growth)),],na.action="na.exclude")
   se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))
   }else{
   regmoda<-plm(as.formula(paste("New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,7)+Lag(StringencyIndex,c(14)):",var)),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(p.dat_weekly$New_Mortality_Rate_Growth)),],na.action="na.exclude")
   se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))
   regmodb<-plm(as.formula(paste("New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,14)+Lag(StringencyIndex,c(21)):",var)),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(p.dat_weekly$New_Mortality_Rate_Growth)),],na.action="na.exclude")
   se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))
   regmodc<-plm(as.formula(paste("New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,21)+Lag(StringencyIndex,c(28)):",var)),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(p.dat_weekly$New_Mortality_Rate_Growth)),],na.action="na.exclude")
   se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))
   regmodd<-plm(as.formula(paste("New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,28)+Lag(StringencyIndex,c(35)):",var)),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(p.dat_weekly$New_Mortality_Rate_Growth)),],na.action="na.exclude")
   se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))
   }
  
   stargazer(digits=6,regmoda,regmodb,regmodc,regmodd,type="html",
             se=list(se.a[,2],se.b[,2],se.c[,2],se.d[,2]),out=paste("Table_panel_",var,"_weekly_reg_output.htm"),
             dep.var.labels=c("Weekly Avg. New Mortality Growth (t)"),
             dep.var.labels.include = FALSE,
             covariate.labels=c("New Mortality Growth (t-7)",paste("Stringency (t-14) X ", label),"New Mortality Growth (t-14)", paste("Stringency (t-21) X ", label),"New Mortality Growth (t-21)",paste("Stringency (t-28) X ", label),"New Mortality Growth (t-28)",paste("Stringency (t-35) X ", label)), 
             df = FALSE,omit.stat="adj.rsq",
             notes = c("*,**,*** correspond to 10%, 5% and 1% significance, respectively.","HAC robust standard errors, clustered by country. Time and Country FEs."),notes.append=F,notes.align ="l",
             title=paste("Heterogeneity: ", label),add.lines = list(c("Fixed effects?", "Y", "Y","Y","Y")))
   
   ### plot of 10-unit increase in Stringency effects over time on future mortality growth
   datweekly_panel<-c(coef(regmoda)[2],coef(regmodb)[2],coef(regmodc)[2],coef(regmodd)[2])
   datweekly_panel<-cbind(datweekly_panel,datweekly_panel+1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
   datweekly_panel<-cbind(datweekly_panel,datweekly_panel[,1]-1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
   colnames(datweekly_panel)<-c("mean","upper","lower")
   p.dat.list[[i]]<-data.frame(datweekly_panel)*10*100
   
   ###figure out the 25% percentile  and 75% percentile of elderly population rate across countries, to compare effects of a 10-unit rise in stringency level
   if (var == "arrivals" || var == "departures"){
      
   s.list[[i]] <- summary(unique(log(datweekly_panel[[var]])))
   }else{
      s.list[[i]] <- summary(unique(datweekly_panel[[var]]))
   }
   s.list
}

```


### Loop to generate heterogeneity regression results
```{r}
###baseline projection regressions, remove 'infinite' values. two-way FE, HAC robust SEs, clustered on country
var.list <- c("prop65", "propurban", "Latitude", "Longitude", "popdensity", "arrivals", "departures", "vul_emp", "GNI", "health_exp", "pollution", "EIU_Democracy", "trust", "risktaking")
label.list <- c("Proportion 65+", "Proportion Urban", "Latitude", "Longitude", "Population Density", "Log Arrivals", "Log Departures", "Vulnerable Employees", "GNI per capita", "Health Expenditures", "Pollution", "EIU Democracy", "Trust", "Risk Taking")

p.dat.list <- list()
s.list <- list()

for (i in c(1:length(var.list))){

   var <- var.list[i]
   label <- label.list[i]
   
   if (var == "arrivals" || var == "departures"){
         regmoda<-plm(as.formula(paste("New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,7)+Lag(StringencyIndex,c(14)):","log(",var,")")),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(datweekly_panel$New_Mortality_Rate_Growth)),],na.action="na.exclude")
   se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))
   regmodb<-plm(as.formula(paste("New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,14)+Lag(StringencyIndex,c(21)):","log(",var,")")),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(datweekly_panel$New_Mortality_Rate_Growth)),],na.action="na.exclude")
   se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))
   regmodc<-plm(as.formula(paste("New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,21)+Lag(StringencyIndex,c(28)):","log(",var,")")),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(datweekly_panel$New_Mortality_Rate_Growth)),],na.action="na.exclude")
   se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))
   regmodd<-plm(as.formula(paste("New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,28)+Lag(StringencyIndex,c(35)):","log(",var,")")),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(datweekly_panel$New_Mortality_Rate_Growth)),],na.action="na.exclude")
   se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))
   }else{
   regmoda<-plm(as.formula(paste("New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,7)+Lag(StringencyIndex,c(14)):",var)),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(datweekly_panel$New_Mortality_Rate_Growth)),],na.action="na.exclude")
   se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))
   regmodb<-plm(as.formula(paste("New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,14)+Lag(StringencyIndex,c(21)):",var)),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(datweekly_panel$New_Mortality_Rate_Growth)),],na.action="na.exclude")
   se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))
   regmodc<-plm(as.formula(paste("New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,21)+Lag(StringencyIndex,c(28)):",var)),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(datweekly_panel$New_Mortality_Rate_Growth)),],na.action="na.exclude")
   se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))
   regmodd<-plm(as.formula(paste("New_Mortality_Rate_Growth~Lag(New_Mortality_Rate_Growth,28)+Lag(StringencyIndex,c(35)):",var)),method="pooling",effect="twoways",data=datweekly_panel[which(!is.infinite(datweekly_panel$New_Mortality_Rate_Growth)),],na.action="na.exclude")
   se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))
   }
   
   ### plot of 10-unit increase in Stringency effects over time on future mortality growth
   p.dat_weekly<-c(coef(regmoda)[2],coef(regmodb)[2],coef(regmodc)[2],coef(regmodd)[2])
   p.dat_weekly<-cbind(p.dat_weekly,p.dat_weekly+1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
   p.dat_weekly<-cbind(p.dat_weekly,p.dat_weekly[,1]-1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
   colnames(p.dat_weekly)<-c("mean","upper","lower")
   p.dat.list[[i]]<-data.frame(p.dat_weekly)*10*100
   
   ###figure out the 25% percentile  and 75% percentile of elderly population rate across countries, to compare effects of a 10-unit rise in stringency level
   if (var == "arrivals" || var == "departures"){
      
   s.list[[i]] <- summary(unique(log(datweekly_panel[[var]])))
   }else{
      s.list[[i]] <- summary(unique(datweekly_panel[[var]]))
   }
   s.list
}

```

### Plot Proportion 65+
```{r}
   #plot
   Plot_61 <- ggplot(data=p.dat.list[[1]],aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*19.400))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*19.400),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on New Mortality Growth (%)")+geom_point(size=4,aes(y=mean*8.283),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*8.283)),linetype=2)+ggtitle(label.list[1])+ylim(-25,5)
   Plot_61
```

### Plot Proportion Urban
```{r}
   #plot
   Plot_62 <- ggplot(data=p.dat.list[[2]],aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*86.56))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*86.56),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on New Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*66.47),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*66.47)),linetype=2)+ggtitle(label.list[2])+ylim(-25,5)
   Plot_62
```

### Plot Latitude
```{r}
   #plot
   Plot_63 <- ggplot(data=p.dat.list[[3]],aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*50.83))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*50.83),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on New Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*22.01),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*22.01)),linetype=2)+ggtitle(label.list[3])+ylim(-25,5)
   Plot_63
```

### Plot Longitude
```{r}
   #plot
   Plot_64 <- ggplot(data=p.dat.list[[4]],aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*49.333))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*49.333),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on New Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*3.342),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*3.342)),linetype=2)+ggtitle(label.list[4])+ylim(-25,5)
   Plot_64
```

### Plot Population Density
```{r}
   #plot
   Plot_65 <- ggplot(data=p.dat.list[[5]],aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*223.847))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*223.847),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on New Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*33.375),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*33.375)),linetype=2)+ggtitle(label.list[5])+ylim(-25,5)
   Plot_65
```

### Plot Log Arrivals
```{r}
   #plot
   Plot_66 <- ggplot(data=p.dat.list[[6]],aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*16.94))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*16.94),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on New Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*15.30),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*15.30)),linetype=2)+ggtitle("Log Arrivals")+ylim(-25,5)
   Plot_66
```

### Plot Log Departures
```{r}
   #plot
   Plot_67 <- ggplot(data=p.dat.list[[7]],aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*16.79))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*16.79),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on New Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*15.02),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*15.02)),linetype=2)+ggtitle("Log Departures")+ylim(-25,5)
   Plot_67
```

### Plot Vulnerable Employees
```{r}
   #plot
   Plot_68 <- ggplot(data=p.dat.list[[8]],aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*21.797))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*21.797),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on New Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*7.407),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*7.407)),linetype=2)+ggtitle(label.list[8])+ylim(-25,5)
   Plot_68
```

### Plot GNI per capita
```{r}
   Plot_69 <- ggplot(data=p.dat.list[[9]],aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*46500))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*46500),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on New Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*10325),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*10325)),linetype=2)+ggtitle(label.list[9])+ylim(-25,5)
   Plot_69
```

### Plot Health Expenditures
```{r}
   Plot_70 <- ggplot(data=p.dat.list[[10]],aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*4292.73))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*4292.73),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on New Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*542.55),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*542.55)),linetype=2)+ggtitle(label.list[10])+ylim(-25,5)
   Plot_70
```

### Plot Pollution
```{r}
   Plot_71 <- ggplot(data=p.dat.list[[11]],aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*23.084))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*23.084),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on New Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*10.419),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*10.419)),linetype=2)+ggtitle(label.list[11])+ylim(-25,5)
   Plot_71
```

### Plot EIU Democracy
```{r}
   Plot_72 <- ggplot(data=p.dat.list[[12]],aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*8.207))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*8.207),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on New Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*6.570),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*6.570)),linetype=2)+ggtitle(label.list[12])+ylim(-25,5)
   Plot_72
```

### Plot Trust
```{r}
   Plot_73 <- ggplot(data=p.dat.list[[13]],aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*0.28083))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*0.28083),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on New Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*-0.13294),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*-0.13294)),linetype=2)+ggtitle(label.list[13])+ylim(-25,5)
   Plot_73
```

### Plot Risk Taking
```{r}
   Plot_74 <- ggplot(data=p.dat.list[[14]],aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*0.06918))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*0.06918),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("")+theme_bw()+ylab("Effect on New Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*-0.15774),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*-0.15774)),linetype=2)+ggtitle(label.list[14])+ylim(-25,5)
   Plot_74
```

### Arrange all plots
```{r}
p.all <- grid.arrange(Plot_61, Plot_62, Plot_63, Plot_64, Plot_65, Plot_66, Plot_67, Plot_68, Plot_69, Plot_70, Plot_71, Plot_72, ncol=4,nrow=3)
```

### CROSS-SECTIONAL REGRESSION
```{r Weining Cross-Sectional Weekly Mortality}
# Importing libraries.
library(lubridate)
library(zoo)
library(quantmod)
library(fBasics)
library(tseries)
library(sandwich)
library(lmtest)
library(lattice)
library(xtable)
library(vars)
library(plyr)
library(gridExtra)
library(corrplot)
library(ggplot2)
library(reshape2)
library(data.table)
library(rvest)
library(foreign)
library(dplyr)
library(plm)
library(stringr)
library(stargazer)
library(survival)
library(ggfortify)
library(plotly)
library(sf)
library(readr)
library(mapview)
library(ggplot2)
library(tidyverse)
# library(rlang)
library(reshape)
library(rgdal)
library(lubridate)
library(plotly)
library(patchwork)
library(ggforce)
library(gridExtra)
library(htmltools)
library(data.table)
library(webshot)
library(coronavirus)
library(runner)
library(zoo)
library(DataCombine)
library(fastDummies)
library(car)
library(heatmaply)
library(htmlwidgets)
library(summarytools)
library(glmnet)
library(caret)
library(mlbench)
library(psych)
library(plm)
library(lmtest)
library(quantmod)
library(leaflet)
library(corrplot)
library(fBasics)
library(stargazer)
library(tseries)
library(vars)
library(dplyr)
library(haven)
```

# Cleaning
```{r}
# Remove factor variables for government responses.
datweekly_cs<-Final_Data_Country[,-c(48:125,151:154)]

# Merge global preference survey data to Final_Data_Country
gps.country <- read_dta("COVID-19_Final/data/global_preference_survey_country.dta")
# Change country names for merge
gps.country[which(gps.country$country == "South Korea"),"country"] <- "Korea, South"
gps.country[which(gps.country$country == "Czech Republic"),"country"] <- "Czechia"
gps.country[which(gps.country$country == "United States"),"country"] <- "US"

gps.individual <- read_dta("COVID-19_Final/data/global_preference_survey_individual.dta")
# Change country names for merge
gps.individual[which(gps.individual$country == "South Korea"),"country"] <- "Korea, South"
gps.individual[which(gps.individual$country == "Czech Republic"),"country"] <- "Czechia"
gps.individual[which(gps.individual$country == "United States"),"country"] <- "US"

gps.individual$age <- as.character(gps.individual$age)
gps.individual[which(gps.individual$age == "99 99+"), "age"] <- "99"
gps.individual[which(gps.individual$age == "100 (Refused"), "age"] <- NA
gps.individual$age <- as.numeric(gps.individual$age)
gps.individual.pop65 <- gps.individual[which(!is.na(gps.individual$age) & gps.individual$age > 65), ]
gps.individual.pop65 <- gps.individual.pop65[which(!is.na(gps.individual.pop65$trust)),]
gps.country.pop65 <- ddply(gps.individual.pop65, "country", function(X) data.frame(wm.trust = weighted.mean(X$trust, X$wgt)))

colnames(gps.country)[1] <- "COUNTRY"
datweekly_cs <- merge(datweekly_cs, gps.country, by=c("COUNTRY"), all.x=TRUE)
colnames(gps.country.pop65)[1] <- "COUNTRY"
datweekly_cs <- merge(datweekly_cs, gps.country.pop65, by=c("COUNTRY"), all.x=TRUE)
```

### Rename variables and create some new variables
```{r}
datweekly_cs<-pdata.frame(datweekly_cs, index = c("COUNTRY", "Date"))
datweekly_cs$Date<-as.Date(datweekly_cs$Date,"%Y-%m-%d")
#reorder
datweekly_cs<-datweekly_cs[order(datweekly_cs$Date),]
datweekly_cs<-datweekly_cs[order(datweekly_cs$COUNTRY),]

colnames(datweekly_cs)[4] <- "Total_Case_Country"
colnames(datweekly_cs)[5] <- "Total_Death_Country"
colnames(datweekly_cs)[6] <- "New_Case_Country"
colnames(datweekly_cs)[7] <- "New_Death_Country"
colnames(datweekly_cs)[9] <- "Total_Mortality_Rate"
colnames(datweekly_cs)[10] <- "New_Mortality_Rate"
colnames(datweekly_cs)[11] <- "Total_Case_Rate"
colnames(datweekly_cs)[12] <- "RollingAverage_New_Case_Country"
colnames(datweekly_cs)[13] <- "RollingAverage_New_Death_Country"
colnames(datweekly_cs)[14] <- "RollingAverage_Total_Mortality_Rate"
colnames(datweekly_cs)[15] <- "RollingAverage_New_Mortality_Rate"
colnames(datweekly_cs)[16] <- "EIU_Democracy"
datweekly_cs$RollingAverage_Total_Mortality_Rate <- NULL
datweekly_cs$longitude <- NULL
datweekly_cs$latitude <- NULL

datweekly_cs$New_Case_Rate = datweekly_cs$New_Case_Country/datweekly_cs$Population

datweekly_cs <- datweekly_cs %>%
 dplyr::group_by(COUNTRY) %>%
 dplyr::mutate(RollingAverage_New_Case_Rate = frollmean(New_Case_Rate, 7,na.rm=TRUE))

datweekly_cs <- datweekly_cs %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(Total_Mortality_Rate_Growth = log(Total_Mortality_Rate) - Lag(log(Total_Mortality_Rate),7))

datweekly_cs <- datweekly_cs %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(Total_Case_Rate_Growth = log(Total_Case_Rate) - Lag(log(Total_Case_Rate),7))

datweekly_cs <- datweekly_cs %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(New_Case_Rate_Growth = log(RollingAverage_New_Case_Rate) - Lag(log(RollingAverage_New_Case_Rate),7))

datweekly_cs <- datweekly_cs %>%
  dplyr::group_by(COUNTRY) %>%
  dplyr::mutate(New_Mortality_Rate_Growth = log(RollingAverage_New_Mortality_Rate) - Lag(log(RollingAverage_New_Mortality_Rate),7))

datweekly_cs$respiratory_deaths_rate <- 1/3*(datweekly_cs$respiratory_deaths/datweekly_cs$Population)
```

### Reorder columns
```{r}
datweekly_cs <- datweekly_cs %>%
 dplyr::select(c("COUNTRY", "X1", "Date",
          "Total_Case_Country", "Total_Death_Country", "New_Case_Country", "New_Death_Country", "Population",
          "Total_Case_Rate", "Total_Mortality_Rate", "New_Case_Rate", "New_Mortality_Rate", 
          "RollingAverage_New_Case_Country", "RollingAverage_New_Death_Country", 
          "RollingAverage_New_Case_Rate", "RollingAverage_New_Mortality_Rate", 
          "Total_Case_Rate_Growth", "Total_Mortality_Rate_Growth", 
          "New_Case_Rate_Growth", "New_Mortality_Rate_Growth"), everything())

datweekly_cs$Total_Case_Rate_Growth[is.nan(datweekly_cs$Total_Case_Rate_Growth)] <- NA
datweekly_cs$Total_Mortality_Rate_Growth[is.nan(datweekly_cs$Total_Mortality_Rate_Growth)] <- NA

datweekly_cs$New_Case_Rate_Growth[is.nan(datweekly_cs$New_Case_Rate_Growth)] <- NA
datweekly_cs$New_Mortality_Rate_Growth[is.nan(datweekly_cs$New_Mortality_Rate_Growth)] <- NA

datweekly_cs$New_Mortality_Rate_Growth[is.infinite(-datweekly_cs$New_Mortality_Rate_Growth)] <- Inf

colnames(datweekly_cs)
```

### Visualization of mortality curves
```{r}
datweekly_cs <- datweekly_cs %>%
  group_by(COUNTRY) %>%
  mutate(First_Date_Mortality = as.character(Date[which(Total_Death_Country>0)[1]]))
datweekly_cs$Days_Since_First_Death <- as.Date(as.character(datweekly_cs$Date))-as.Date(as.character(datweekly_cs$First_Date_Mortality))
datweekly_csnormalized <- datweekly_cs[which(datweekly_cs$First_Date_Mortality>-1),]
Plot_75 <- plot_ly(datweekly_csnormalized, x=~Days_Since_First_Death, y=~RollingAverage_New_Mortality_Rate) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(xaxis = list(range = c(0, 50)))
Plot_75
```

### Outcome variables 
```{r}
datweekly_csnormalized_v0 <- datweekly_csnormalized[which(datweekly_cs$COUNTRY == "Czechia"),]

Mortality_curve_v0 <- ggplot(data=datweekly_csnormalized_v0, aes(x=Days_Since_First_Death, y=RollingAverage_New_Mortality_Rate)) +
  geom_line(color="blue", size = 0.75) + geom_segment(aes(x=23, xend=23, y=0, yend=max(datweekly_csnormalized_v0$RollingAverage_New_Mortality_Rate[which(!is.na(datweekly_csnormalized_v0$RollingAverage_New_Mortality_Rate))])), size=1, colour="blue", linetype="dotted") + geom_ribbon(data = datweekly_csnormalized_v0 %>% filter(Days_Since_First_Death < 24), aes(ymin = 0, ymax = datweekly_csnormalized_v0$RollingAverage_New_Mortality_Rate[which(datweekly_csnormalized_v0$Days_Since_First_Death<24)]), fill = "red", alpha = .5) + xlim(0, 50) + labs(x = "Days since the first death", y = "Daily new mortality rate, 7-day rolling average") + theme_bw() + theme(axis.text.x = element_text(size = 10), axis.text.y = element_text(size = 10), axis.title = element_text(size = 14))
Mortality_curve_v0
```

### Same peak, different durations: Norway versus Hungary
```{r}
datweekly_csnormalized_v1 <- datweekly_csnormalized[which(datweekly_cs$COUNTRY == "Hungary" | datweekly_cs$COUNTRY == "Norway"),]


Mortality_curve_v1 <- ggplot(data=datweekly_csnormalized_v1, aes(x=Days_Since_First_Death, y=RollingAverage_New_Mortality_Rate, group=COUNTRY)) +
  geom_line(aes(color=COUNTRY), size = 0.75) + xlim(0, 50) + labs(x = "Days since the first death", y = "Daily new mortality rate, 7-day rolling average") + theme_bw() + theme(legend.position = c(0.2, 0.8), legend.title = element_blank(), legend.text=element_text(size=8))

Mortality_curve_v1

```

### Same duration, different peaks: Norway versus Denmark
```{r}
datweekly_csnormalized_v2 <- datweekly_csnormalized[which(datweekly_cs$COUNTRY == "Denmark" | datweekly_cs$COUNTRY == "Norway"),]


Mortality_curve_v2 <- ggplot(data=datweekly_csnormalized_v2, aes(x=Days_Since_First_Death, y=RollingAverage_New_Mortality_Rate, group=COUNTRY)) +
  geom_line(aes(color=COUNTRY), size = 0.75) + xlim(0, 50) + labs(x = "Days since the first death", y = "Daily new mortality rate, 7-day rolling average") + theme_bw() + theme(legend.position = c(0.2, 0.8), legend.title = element_blank(), legend.text=element_text(size=8))

Mortality_curve_v2

```

### Different durations, different peaks, different ratios: Austria, Czechia versus Estonia
```{r}
datweekly_csnormalized_v3 <- datweekly_csnormalized[which(datweekly_cs$COUNTRY == "Austria" | datweekly_cs$COUNTRY == "Estonia" | a$COUNTRY == "Greece"),]


Mortality_curve_v3 <- ggplot(data=datweekly_csnormalized_v3, aes(x=Days_Since_First_Death, y=RollingAverage_New_Mortality_Rate, group=COUNTRY)) +
  geom_line(aes(color=COUNTRY), size = 0.75) + xlim(0, 50) + labs(x = "Days since the first death", y = "Daily new mortality rate, 7-day rolling average") + theme_bw() + theme(legend.position = c(0.15, 0.85),legend.title = element_blank(), legend.text=element_text(size=8))

Mortality_curve_v3

```

### Arrange mortality curve plots
```{r}
Plot_76 <- grid.arrange(Mortality_curve_v1, Mortality_curve_v2, Mortality_curve_v3, nrow=1)
Plot_76
```

### Generate key endogenous variables used in cross-country analysis
```{r}
country <- c("")

# Mortality
date.first.death <- c(0)
date.peak.mortality <- c(0)
days.to.peak.mortality <- c(0)
peak.or.no.mortality <- c(0)
peak.cum.mortality <- c(0)
peak.new.mortality <- c(0)
early.mortality <- c(0)
early.mortality.growth<-c(0)

# Case
date.first.case <- c(0)
date.peak.case <- c(0)
days.to.peak.case <- c(0)
peak.or.no.case <- c(0)
peak.cum.case <- c(0)
peak.new.case <- c(0)
early.case <- c(0)
early.case.growth <- c(0)

# Stringency Index
early.stringency.sum <- c(0)
peak.stringency <- c(0)
first.stringency <- c(0)
date.first.stringency <- c(0)
date.peak.stringency <- c(0)
early.stringency.average <- c(0)

# Mobility
early.mobility.walking<-c(0)

dems_data<-aggregate(data=datweekly_cs,cbind(prop65,propurban,popdensity,vul_emp,health_exp,GNI,pollution,Latitude,Longitude,EIU_Democracy)~COUNTRY,FUN=mean,na.rm=T)

for(i in 1:length(unique(dems_data$COUNTRY))){
  
  datweekly_cs_v1<-subset(datweekly_cs,COUNTRY==unique(dems_data$COUNTRY)[i])
  country[i] <- as.character(unique(dems_data$COUNTRY)[i])
  datweekly_cs_v1<-datweekly_cs_v1[order(datweekly_cs_v1$Date),]
  datweekly_cs_v1<-datweekly_cs_v1[order(datweekly_cs_v1$COUNTRY),]
  datweekly_cs_v1 <- datweekly_cs_v1 %>%
    dplyr::group_by(COUNTRY) %>%
    dplyr::mutate(RollingAverage_Walking = frollmean(walking, 7))
  datweekly_cs_v1 <- datweekly_cs_v1 %>%
    dplyr::group_by(COUNTRY) %>%
    dplyr::mutate(RollingAverage_StringencyIndex = frollmean(StringencyIndex, 7))
  
  # Mortality
  date.first.death[i]<-as.character(datweekly_cs_v1$Date[which(datweekly_cs_v1$Total_Death_Country>0)[1]]) # Date of first death
  peak.new.mortality[i]<-max(datweekly_cs_v1$RollingAverage_New_Mortality_Rate,na.rm = TRUE) # Peak new mortality
  date.peak.mortality[i]<-as.character(datweekly_cs_v1$Date[which((datweekly_cs_v1$RollingAverage_New_Mortality_Rate==peak.new.mortality[i]))]) # Date of peak new mortality
  days.to.peak.mortality[i]<-as.Date(date.peak.mortality[i])-as.Date(date.first.death[i]) # Days from first death to peak new mortality
  peak.cum.mortality[i]<-datweekly_cs_v1$Total_Mortality_Rate[which(datweekly_cs_v1$RollingAverage_New_Mortality_Rate==peak.new.mortality[i])] # Total mortality rate at the peak
  peak.or.no.mortality[i]<-ifelse(date.peak.mortality[i]==max(datweekly_cs_v1$Date),0,1)
  early.mortality[i]<-datweekly_cs_v1$Total_Mortality_Rate[which(datweekly_cs_v1$Total_Death_Country>0)[7]] # Total mortality in the first week since first death
  early.mortality.growth[i]<-log(datweekly_cs_v1$RollingAverage_New_Mortality_Rate[which(datweekly_cs_v1$Total_Death_Country>0)[7]]) -
    log(datweekly_cs_v1$RollingAverage_New_Mortality_Rate[which(datweekly_cs_v1$Total_Death_Country>0)[1]])# Growth rate of new mortality rate in the first week since first death
  
  # Case
  date.first.case[i]<-as.character(datweekly_cs_v1$Date[which(datweekly_cs_v1$Total_Case_Country>0)[1]]) # Date of first case
  peak.new.case[i]<-max(datweekly_cs_v1$RollingAverage_New_Case_Rate, na.rm = TRUE) # Peak new case
  date.peak.case[i]<-as.character(datweekly_cs_v1$Date[which((datweekly_cs_v1$RollingAverage_New_Case_Rate==peak.new.case[i]))]) # Date of peak new case
  days.to.peak.case[i]<-as.Date(date.peak.case[i])-as.Date(date.first.case[i]) # Days from first case to peak new case
  peak.cum.case[i]<-datweekly_cs_v1$Total_Case_Rate[which.max(datweekly_cs_v1$RollingAverage_New_Case_Rate==peak.new.case[i])] # Toal case rate at the peak
  peak.or.no.case[i]<-ifelse(date.peak.case[i]==max(datweekly_cs_v1$Date),0,1)
  early.case[i]<-datweekly_cs_v1$Total_Case_Rate[which(datweekly_cs_v1$Total_Case_Country>0)[7]] # Total case rate in the first week since first case
  if (datweekly_cs_v1$RollingAverage_New_Case_Rate[which(datweekly_cs_v1$Total_Case_Country>0)[1]] == 0){
    early.case.growth[i]<-log(datweekly_cs_v1$RollingAverage_New_Case_Rate[which(datweekly_cs_v1$Total_Case_Country>0)[7]]) -  log(datweekly_cs_v1$Total_Case_Rate[which(datweekly_cs_v1$Total_Case_Country>0)[1]])# Growth rate of new case rate in the first week since first case
  }else{
    early.case.growth[i]<-log(datweekly_cs_v1$RollingAverage_New_Case_Rate[which(datweekly_cs_v1$Total_Case_Country>0)[7]]) -  log(datweekly_cs_v1$RollingAverage_New_Case_Rate[which(datweekly_cs_v1$Total_Case_Country>0)[1]]) #Growth rate of new case rate in the first week since first case
  }
  
  # Stringency Index
  early.stringency.sum[i] <- sum(datweekly_cs_v1$StringencyIndex[which(datweekly_cs_v1$Date<date.first.death[i] & !is.na(datweekly_cs_v1$StringencyIndex))])  # Sum of stringency index prior to first death
  early.stringency.average[i] <- mean(datweekly_cs_v1$StringencyIndex[which(datweekly_cs_v1$Date<date.first.death[i] & !is.na(datweekly_cs_v1$StringencyIndex))])  # Average of stringency index prior to first death
  # early.stringency[i]<-b$RollingAverage_StringencyIndex[which(b$Total_Death_Country>0)[1]-7] #Weekly average stringency index in the week prior to first death
  # early.stringency[i]<-b$StringencyIndex[which(b$Total_Death_Country>0)[1]-10] #Weekly average stringency index in the week prior to first death
  
  # first.stringency[i] <- b$StringencyIndex[which(b$StringencyIndex > 0)[1]] # First SI, no matter before or after the first case
  first.stringency[i] <- datweekly_cs_v1$StringencyIndex[which(datweekly_cs_v1$C1_School.closing > 0 | datweekly_cs_v1$C2_Workplace.closing > 0 |
                                                 datweekly_cs_v1$C3_Cancel.public.events > 0 | datweekly_cs_v1$C4_Restrictions.on.gatherings > 0 |
                                                 datweekly_cs_v1$C5_Close.public.transport > 0 | datweekly_cs_v1$C6_Stay.at.home.requirements > 0 | 
                                                 datweekly_cs_v1$C7_Restrictions.on.internal.movement > 0)[1]] # First SI, no matter before or after the first case or death
  peak.stringency[i] <- max(datweekly_cs_v1$StringencyIndex,na.rm=T) # Peak SI
  
  # date.first.stringency[i] <- as.character(b$Date[which(b$StringencyIndex > 0)[1]]) # Date of first SI
  date.first.stringency[i] <- as.character(datweekly_cs_v1$Date[which(datweekly_cs_v1$C1_School.closing > 0 | datweekly_cs_v1$C2_Workplace.closing > 0 | datweekly_cs_v1$C3_Cancel.public.events > 0 | datweekly_cs_v1$C4_Restrictions.on.gatherings > 0 | datweekly_cs_v1$C5_Close.public.transport > 0 | datweekly_cs_v1$C6_Stay.at.home.requirements > 0 |  datweekly_cs_v1$C7_Restrictions.on.internal.movement > 0)[1]])
# Date of first SI
  if (peak.stringency[i] == -Inf){
    date.peak.stringency[i] <- -Inf
  }else{
    date.peak.stringency[i] <- as.character(datweekly_cs_v1$Date[which.max(datweekly_cs_v1$StringencyIndex)])
  }
  
  # Mobility
  early.mobility.walking[i]<-datweekly_cs_v1$RollingAverage_Walking[which(datweekly_cs_v1$Total_Death_Country>0)[1]-1] # Weekly average walking mobility in the week prior to first death
  
}

stringency.delta <- (peak.stringency-first.stringency)/as.numeric(as.Date(date.peak.stringency)-as.Date(date.first.stringency))
log.early.stringency.sum <- log(early.stringency.sum)
log.early.stringency.sum[which(is.infinite(-log.early.stringency.sum))] <- NA
how.early.stringency <- as.numeric(as.Date(date.first.death)-as.Date(date.first.stringency))
# early.stringency.average <- early.stringency/how.early.stringency
log.peak.mortality.to.duration <- log(peak.new.mortality)/as.numeric(days.to.peak.mortality)
log.peak.case.to.duration <- log(peak.new.case)/as.numeric(days.to.peak.case)

# set NA early stringency to 0
# early.string[is.na(early.string)]<-0

```

### Set up cross-section data
```{r}
surv.dat_weekly<-data.frame(country,days.to.peak.mortality,peak.or.no.mortality, days.to.peak.case,peak.or.no.case, early.mortality,early.mortality.growth, early.case,early.case.growth, peak.cum.mortality,peak.cum.case,peak.new.mortality,peak.new.case, log.peak.mortality.to.duration,log.peak.case.to.duration, early.stringency.average,early.stringency.sum,log.early.stringency.sum,how.early.stringency,stringency.delta,peak.stringency, early.mobility.walking,dems_data[,-1])

#remove vietnam
surv.dat_weekly<-surv.dat_weekly[-nrow(surv.dat_weekly),]
surv.dat_weekly<-mutate(surv.dat_weekly,stringent=ifelse(early.stringency.average>7.77,"SI>7.77","SI<7.77"),stringent=factor(stringent))
```

### Cross-country analysis on the peak mortality
```{r}
### - peak cum. mortality - 
cs.total.mortality<- lm(log(peak.cum.mortality) ~ log(early.mortality)+early.mortality.growth +  early.stringency.sum+stringency.delta+early.mobility.walking + prop65+propurban+popdensity+vul_emp+log(GNI)+EIU_Democracy+Latitude:Longitude,data=surv.dat_weekly,na.action = "na.exclude")
se.total.mortality<-coeftest(cs.total.mortality, vcov = vcovHC(cs.total.mortality, type = "HC1"))

### - peak new mortality - 
cs.new.mortality<- lm(log(peak.new.mortality) ~ log(early.mortality)+early.mortality.growth+early.stringency.sum+stringency.delta+early.mobility.walking+prop65+propurban+popdensity+vul_emp+log(GNI)+EIU_Democracy+Latitude:Longitude,data=surv.dat_weekly,na.action = "na.exclude")
se.new.mortality<-coeftest(cs.new.mortality, vcov = vcovHC(cs.new.mortality, type = "HC1"))

surv.dat_weekly$res.new.mortality = resid(cs.new.mortality)

### - peak new mortality to duration ratio - 
cs.peak.duration.ratio<- lm(log.peak.mortality.to.duration ~  log(early.mortality)+early.mortality.growth+ early.stringency.sum+stringency.delta+early.mobility.walking+ prop65+propurban+popdensity+vul_emp+log(GNI)+EIU_Democracy+Latitude:Longitude,data=surv.dat_weekly,na.action = "na.exclude")
se.peak.duration.ratio<-coeftest(cs.peak.duration.ratio, vcov = vcovHC(cs.peak.duration.ratio, type = "HC1"))

surv.dat_weekly$res.peak.duration.ratio = resid(cs.peak.duration.ratio)

```

### - Survival Analysis on pandemic duration to first peak
```{r}
cox.death<-coxph(Surv(days.to.peak.mortality,peak.or.no.mortality) ~ log(peak.new.mortality)+log(early.mortality)+early.mortality.growth+early.stringency.average+how.early.stringency+stringency.delta+early.mobility.walking+prop65+propurban+popdensity+vul_emp+log(GNI)+EIU_Democracy+Latitude:Longitude,data=surv.dat_weekly)

test.death<-cox.zph(cox.death)$table[nrow(cox.zph(cox.death)$table),ncol(cox.zph(cox.death)$table)]

```

### CROSS SECTION NOT MATCHING

### HTML output of the cross-country analysis
```{r,warning=FALSE, results='hide',message=FALSE}
stargazer(cs.new.mortality,cs.peak.duration.ratio,cox.death,se=list(se.new.mortality[,2],se.peak.duration.ratio[,2]),type="html",out=("Table_cs_reg_output_avgSI.htm"),intercept.bottom = FALSE,dep.var.labels=c("Log(Peak New Mortality Rate)","Log(Peak New Moratlity Rate)-to-PD Ratio","Survival Probability of Mortality Peaking at Time (t)"),covariate.labels=c("Intercept","Log(Peak Mortality)","Log(Early Mortality)","Early Mortality Growth","Early SI","Days between First SI and First Death","Stringency Delta","Early Mobility","Prop. 65+","Prop. Urban","Pop. Density","Vulnerable Emp.", "Log(GNI)","EIU Democracy","Latitude:Longitude"),df = FALSE,omit.stat =c("max.rsq","logrank"),notes = c("*,**,*** correspond to 10%, 5% and 1% significance, respectively.","PH Test refers to testing the proportional hazards assumption (Grambsch and Therneau (1994)).","Null hypothesis is the assumption is not violated.","Standard errors in linear models are Heteroscedastic-Robust standard errors."),notes.append=F,notes.align ="l",font.size = "tiny",title=("Cross-Country Regression: Explaining Differences in the Empirical Shape of First-Wave Mortality Rates"),add.lines = list(c("PH Test p-value",NA,NA,round(test.death,3))),table.layout = "-ldm#-t=sa-n")
```

### Plot K-M curves for confirmed cases
```{r}
km_fit <- survfit(Surv(days.to.peak.case,peak.or.no.case) ~1, data=surv.dat_weekly)

Plot_77A <-autoplot(km_fit)+theme_bw()+xlab("Number of Days")+ylab("Probability Case Peak is Yet to Come")
km_fit2<-survfit(Surv(days.to.peak.case,peak.or.no.case)~stringent, data=surv.dat_weekly)
Plot_78A <-autoplot(km_fit2)+theme_bw()+xlab("Number of Days")+ylab("Probability Case Peak is Yet to Come")+theme(legend.position = c(0.2, 0.2),legend.title=element_blank())
Plot_79A <-ggplot(data=surv.dat_weekly,aes(x=early.stringency.sum,fill=stringent))+geom_histogram(color="black",alpha=.5)+theme_bw()+xlab("Average SI in the Week Prior to First Death")+ylab("Frequency of Countries")+theme(legend.title = element_blank(),legend.position = c(0.7,0.6))
Plot_80A <- grid.arrange(Plot_77A, Plot_78A, Plot_79A, nrow=1)
# g <- arrangeGrob(p1,p2,p3,nrow=1)
```

### Plot K-M curves for mortality
```{r}
km_fit <- survfit(Surv(days.to.peak.mortality,peak.or.no.mortality) ~1, data=surv.dat_weekly)

Plot_77B <-autoplot(km_fit)+theme_bw()+xlab("Number of Days")+ylab("Probability Mortality Peak is Yet to Come")
km_fit2<-survfit(Surv(days.to.peak.mortality,peak.or.no.mortality)~stringent, data=surv.dat_weekly)
Plot_78B <-autoplot(km_fit2)+theme_bw()+xlab("Number of Days")+ylab("Probability Mortality Peak is Yet to Come")+theme(legend.position = c(0.2, 0.2),legend.title=element_blank())
Plot_79B <-ggplot(data=surv.dat_weekly,aes(x=early.stringency.sum,fill=stringent))+geom_histogram(color="black",alpha=.5)+theme_bw()+xlab("Average SI in the Week Prior to First Death")+ylab("Frequency of Countries")+theme(legend.title = element_blank(),legend.position = c(0.7,0.6))
Plot_80B <- grid.arrange(Plot_77B, Plot_78B, Plot_79B, nrow=1)
# g <- arrangeGrob(p1,p2,p3,nrow=1)
```

### ADDITIONAL VISUALIZATIONS

### Generate the Static Correlation Map
```{r}
### Correlation matrix of explanatory variables
cor.surv.dat <- surv.dat_weekly[,c("days.to.peak.mortality","early.mortality","early.mortality.growth","peak.new.mortality","log.peak.mortality.to.duration","early.stringency.average","how.early.stringency","stringency.delta","early.mobility.walking","prop65","propurban","popdensity","vul_emp","health_exp","GNI","pollution","Latitude","Longitude","EIU_Democracy")]

colnames(cor.surv.dat)<-c("PD to Peak Mortality", "Early Mortality", "Early Mortality Growth", "Peak New Mortality", "Logged Peak Mortality-to-PD", "Early SI","Days from First SI to First Death", "Stringency Delta", "Early Mobility", "Prop. 65+", "Prop. Urban", "Pop. Density", "Vulnerable Emp.","Health Exp.","GNI","Pollution","Latitude","Longitude","Democracy")
cormat<-round(cor(cor.surv.dat,use = "complete.obs"), 2)

# Here, I get the lower triangle of the correlation matrix
get_lower_tri<-function(cormat){
  cormat[upper.tri(cormat)] <- NA
  return(cormat)
}
# Now, I get the upper triangle of the correlation matrix
get_upper_tri <- function(cormat){
  cormat[lower.tri(cormat)]<- NA
  return(cormat)
}
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}
cormat <- reorder_cormat(cormat)
melted_cormat <- reshape2::melt(get_upper_tri(cormat), na.rm = TRUE)

ggheatmap <- ggplot(data = melted_cormat, aes(x=Var2, y=Var1, fill=value)) + geom_tile(color = "black") + scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0, limit = c(-1,1), space = "Lab", name="Pearson\nCorrelation") +theme_minimal()+theme(axis.text.x = element_text(angle = 45)) +theme(axis.text.x = element_text(margin = margin(t = 5, r = 0, b = 0, l = 0))) +theme(axis.text.x = element_text(hjust=1))+coord_fixed()

Plot_81 <- ggheatmap + 
geom_text(aes(Var2, Var1, label = value), color = "black", size = 1.75) + theme(axis.title.x = element_blank(),axis.title.y = element_blank(),axis.text=element_text(size=7),panel.grid.major = element_blank(),panel.border = element_blank(),panel.background = element_blank(),axis.ticks = element_blank(),legend.justification = c(1, 0),legend.position = c(0.4, 0.8),legend.direction = "horizontal",legend.title = element_text(size = 6),legend.text=element_text(size=6))+guides(fill = guide_colorbar(barwidth = 7, barheight = 1,title.position = "top", title.hjust = 0.5))

# Print the heatmap
print(Plot_81)

```

### Correlation matrix of government interventions
```{r}

cor.policy.dat <- datweekly_cs[,c("C1_School.closing", 
                      "C2_Workplace.closing",
                      "C3_Cancel.public.events",
                      "C4_Restrictions.on.gatherings",
                      "C5_Close.public.transport",            
                      "C6_Stay.at.home.requirements",         
                      "C7_Restrictions.on.internal.movement", 
                      "C8_International.travel.controls",
                      "H1_Public.information.campaigns",
                      "StringencyIndex")]
colnames(cor.policy.dat) <- c("School Closing", 
                      "Workplace Closing",
                      "Cancel Public Events",
                      "Gathering Restrictions",
                      "Close Public Transport",            
                      "Stay at Home",         
                      "Internal Movement Restrictions", 
                      "International Travel Controls",
                      "Public Information Campaigns",
                      "Stringency Index")
cormat<-round(cor(cor.policy.dat,use = "complete.obs"), 2)

# Here, I get the lower triangle of the correlation matrix
get_lower_tri<-function(cormat){
  cormat[upper.tri(cormat)] <- NA
  return(cormat)
}
# Now, I get the upper triangle of the correlation matrix
get_upper_tri <- function(cormat){
  cormat[lower.tri(cormat)]<- NA
  return(cormat)
}
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}
cormat <- reorder_cormat(cormat)
melted_cormat <- reshape2::melt(get_upper_tri(cormat), na.rm = TRUE)

### Generate the Static Correlation Map
ggheatmap <- ggplot(data = melted_cormat, aes(x=Var2, y=Var1, fill=value)) + 
  geom_tile(color = "black") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white",
    midpoint = 0, limit = c(-1,1), space = "Lab", 
    name="Pearson\nCorrelation") +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 45)) +
  theme(axis.text.x = element_text(margin = margin(t = 5, r = 0, b = 0, l = 0))) +
  theme(axis.text.x = element_text(hjust=1))+coord_fixed()

Plot_82 <- ggheatmap + 
geom_text(aes(Var2, Var1, label = value), color = "black", size = 1.75) +
theme(
  axis.title.x = element_blank(),
  axis.title.y = element_blank(),
  axis.text=element_text(size=7),
  panel.grid.major = element_blank(),
  panel.border = element_blank(),
  panel.background = element_blank(),
  axis.ticks = element_blank(),
  legend.justification = c(1, 0),
  legend.position = c(0.6, 0.7),
  legend.direction = "horizontal",
  legend.title = element_text(size = 7),
  legend.text=element_text(size=7),
  plot.caption = element_text(size = 7, hjust=0))+
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                title.position = "top", title.hjust = 0.5))

# Print the heatmap
print(Plot_82)

```

### Summary statistics of country characteristics
```{r}
cor.sum.dat <- surv.dat_weekly[,c("days.to.peak.mortality","early.mortality","early.mortality.growth","peak.new.mortality","log.peak.mortality.to.duration","early.stringency.average","how.early.stringency","stringency.delta", "early.mobility.walking", "prop65","propurban","popdensity","vul_emp","health_exp","GNI","pollution","Latitude","Longitude","EIU_Democracy")]
cor.sum.dat$early.mortality <- cor.sum.dat$early.mortality * 10000000
cor.sum.dat$peak.new.mortality <- cor.sum.dat$peak.new.mortality * 10000000
cor.sum.dat$GNI <- log(cor.sum.dat$GNI)
colnames(cor.sum.dat)<-c("PD to Peak Mortality", "Early Mortality", "Early Mortality Growth","Peak New Mortality", "Logged Peak Mortality-to-PD","Early SI","Days from First SI to First Death", "Stringency Delta", "Early Mobility","Prop. 65+", "Prop. Urban", "Pop. Density", "Vulnerable Employment","Health Expenditure","Log(GNI)","Pollution","Latitude","Longitude","Democracy")
sum.stats <- t(round(basicStats(cor.sum.dat),3))
sum.stats <- data.frame(sum.stats[,c("nobs", "NAs", "Minimum", "Maximum", "1. Quartile", "3. Quartile", "Mean", "Median", "Stdev")])
sum.stats$N <- sum.stats$nobs - sum.stats$NAs
sum.stats <- sum.stats[,-c(1,2)]
sum.stats <- sum.stats %>%
  select(c("N", "Minimum", "Maximum", "Mean", "Median", "Stdev"), everything())
colnames(sum.stats) <- c("N", "Minimum", "Maximum", "Mean", "Median", "S.D.", "25 Percentile", "75 Percentile")
peak.stringency.finite <- cor.sum.dat$`Peak Stringency`[which(is.finite(cor.sum.dat$`Peak Stringency`))]
stargazer(sum.stats,type="html",summary = FALSE, out=("Table_summary_country_char.htm"),title="Country Characteristics: Summary")
```

### Table of variable definitions and sources
```{r}

df.definition <- data.frame("Variable" = c("New Mortality Rate",
                                           "Early Mortality", "Early Mortality Growth","Peak New Mortality",
                                           "PD to Peak Mortality", "Logged Peak Mortality-to-PD",
                                           "Early SI", "Days from First SI to First Death", "Stringency Delta", 
                                           "Early Mobility",
                                           "Prop. 65+", "Prop. Urban", "Pop. Density", 
                                           "Vulnerable Employment","Health Expenditure","GNI","Pollution",
                                           "Tourist Arrivals", "Tourist Departures",
                                           "Latitude","Longitude","Democracy"),
                            "Definition" = c("7-day rolling average of daily new mortality rate out ot the total population",
                                             "Cumulative mortality rate in the week following the first death",
                                             "Growth rate of new mortality rate in the week following the first death",
                                             "New mortality rate at the peak of new mortality rate in the first quasi-bell curve",
                                             "Day-to-peak of new mortality rate in the first quasi-bell curve",
                                             "The ratio of the logged peak new mortality rate to the PD to peak mortality",
                                             "Average of SI from its first non-zero value to the first death",
                                             "Number of days from first non-zero SI to the first death",
                                             "Growth rate of SI from its first non-zero value to its maximum level",
                                             "Weekly average level of mobility in terms of walking in the week prior to the first death, reported by Apple",
                                             "Elderly population (people aged 65 and over) as a percentage of the total population",
                                             "Urban population as a percentage of the total population",
                                             "Midyear population divided by land area in square kilometers",
                                             "Employment in vulnerable sectors (i.e., family workers and own-account workers) as a percentage of the total employment",
                                             "Level of current health expenditure (including healthcare goods and services) as a percentage of GDP",
                                             "Gross national income per capita",
                                             "Population-weighted exposure to ambient PM2.5 pollution",
                                             "International inbound tourists to the country",
                                             "International outbound tourists from the country",
                                             "Latitude coordinate of the country",
                                             "Longitude coordinate of the country",
                                             "The Democracy index calculated by The Economist Intelligence Unit"
                                             ),
                            "Source" = c("Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on JHU COVID-19 Data",
                                         "Authors' calculation based on OxCGRT Data",
                                         "Authors' calculation based on OxCGRT Data",
                                         "Authors' calculation based on OxCGRT Data",
                                         "Authors' calculation based on Apple COVID-19 Mobility Trends Reports",
                                         "World Development Indicators",
                                         "World Development Indicators",
                                         "World Development Indicators",
                                         "World Development Indicators",
                                         "World Development Indicators",
                                         "World Development Indicators",
                                         "World Development Indicators",
                                         "World Development Indicators",
                                         "World Development Indicators",
                                         "Country-level coordinates from Google",
                                         "Country-level coordinates from Google",
                                         "The EIU Democracy Index 2019 Database"
                                         )
                              )
rownames(df.definition) <- NULL
stargazer(df.definition,type="html",rownames = FALSE, summary = FALSE, out=("Table_variable_definition.htm"))
```

### RESIDUAL PLOTS

### Residual map - peak new mortality
```{r}
require(maps)
require(viridis)
world_map <- map_data("world")
ggplot(world_map, aes(x = long, y = lat, group = group)) +
  geom_polygon(fill="lightgray", colour = "white")
colnames(world_map)[1] <- "Longitude"
colnames(world_map)[2] <- "Latitude"

world_map$region[world_map$region == "Czech Republic"] <- "Czechia"
world_map$region[world_map$region == "USA"] <- "US"
world_map$region[world_map$region == "UK"] <- "United Kingdom"
world_map$region[world_map$region == "South Korea"] <- "Korea, South"

colnames(world_map)[5] <- "country"

surv.dat.map <- left_join(world_map, surv.dat_weekly, by = "country")

colnames(surv.dat.map)[1] <- "Longitude"
colnames(surv.dat.map)[2] <- "Latitude"

# Finally, we can construct our initial marker map. First, I set different colors for each quantile.
surv.dat.map$abs.res.new.mortality <- abs(surv.dat.map$res.new.mortality)

p.res.new.mortality <- ggplot(surv.dat.map, aes(x = Longitude, y = Latitude)) +
  geom_polygon(aes(group = group, fill = round(res.new.mortality,2)), color = "white") +
  # geom_text(aes(label = round(cs.total.mortality.res,2)), data = surv.dat, size = 2)+
  # scale_fill_viridis(option="C", begin = min(surv.dat$cs.total.mortality.res[!is.na(surv.dat$cs.total.mortality.res)]), end = max(surv.dat$cs.total.mortality.res[!is.na(surv.dat$cs.total.mortality.res)]))+
  theme_void()+
  labs(fill = "Residuals")+
  theme(legend.text = element_text(size = 7),legend.title=element_text(size=8), legend.position = c(0.95,0.5))+
  scale_fill_gradient(low = "red", high = "blue", na.value = "lightgrey",guide = "colourbar")+
  guides(fill = guide_colourbar(barwidth = 1.1, barheight = 3.3))

p.res.new.mortality 

surv.dat.sorted.new.mortality <- surv.dat_weekly[order(-surv.dat_weekly$res.new.mortality),]

res.new.mortality.rank <- surv.dat.sorted.new.mortality[!is.na(surv.dat.sorted.new.mortality$res.new.mortality),c("country", "res.new.mortality")]
colnames(res.new.mortality.rank) <- c("Country", "Residual")
rownames(res.new.mortality.rank) <- NULL
under.predicted.new.mortality <- res.new.mortality.rank[c(1:5),]
over.predicted.new.mortality <- res.new.mortality.rank[c(seq(nrow(res.new.mortality.rank),nrow(res.new.mortality.rank)-4,-1)),]
stargazer(under.predicted.new.mortality,type="html",rownames = FALSE, summary = FALSE, out=("Table_res_new_mortality_under_predicted.htm"))
stargazer(over.predicted.new.mortality,type="html",rownames = FALSE, summary = FALSE, out=("Table_res_new_mortality_over_predicted.htm"))

```

### Residual map - peak new mortality-to-PD ratio
```{r}

require(maps)
require(viridis)
world_map <- map_data("world")
ggplot(world_map, aes(x = long, y = lat, group = group)) +
  geom_polygon(fill="lightgray", colour = "white")
colnames(world_map)[1] <- "Longitude"
colnames(world_map)[2] <- "Latitude"

world_map$region[world_map$region == "Czech Republic"] <- "Czechia"
world_map$region[world_map$region == "USA"] <- "US"
world_map$region[world_map$region == "UK"] <- "United Kingdom"
world_map$region[world_map$region == "South Korea"] <- "Korea, South"

colnames(world_map)[5] <- "country"

surv.dat.map <- left_join(world_map, surv.dat_weekly, by = "country")

colnames(surv.dat.map)[1] <- "Longitude"
colnames(surv.dat.map)[2] <- "Latitude"

surv.dat.map$abs.res.peak.duration.ratio <- abs(surv.dat.map$res.peak.duration.ratio)

p.res.peak.duration.ratio <- ggplot(surv.dat.map, aes(x = Longitude, y = Latitude)) +
  geom_polygon(aes(group = group, fill = round(res.peak.duration.ratio,2)), color = "white") +
  # geom_text(aes(label = round(cs.total.mortality.res,2)), data = surv.dat, size = 2)+
  # scale_fill_viridis(option="C", begin = min(surv.dat$cs.total.mortality.res[!is.na(surv.dat$cs.total.mortality.res)]), end = max(surv.dat$cs.total.mortality.res[!is.na(surv.dat$cs.total.mortality.res)]))+
  theme_void()+
  labs(fill = "Residuals")+
  theme(legend.text = element_text(size = 7),legend.title=element_text(size=8), legend.position = c(0.95,0.5))+
  scale_fill_gradient(low = "green", high = "blue", na.value = "lightgrey",guide = "colourbar")+
  guides(fill = guide_colourbar(barwidth = 1.1, barheight = 3.3))

p.res.peak.duration.ratio

surv.dat.sorted.peak.to.PD.ratio <- surv.dat_weekly[order(-surv.dat_weekly$res.peak.duration.ratio),]

res.ratio.rank <- surv.dat.sorted.peak.to.PD.ratio[!is.na(surv.dat.sorted.peak.to.PD.ratio$res.peak.duration.ratio),c("country", "res.peak.duration.ratio")]
colnames(res.ratio.rank) <- c("Country", "Residual")
rownames(res.ratio.rank) <- NULL
under.predicted.ratio <- res.ratio.rank[c(1:5),]
over.predicted.ratio <- res.ratio.rank[c(seq(nrow(res.ratio.rank),nrow(res.ratio.rank)-4,-1)),]
stargazer(under.predicted.ratio,type="html",rownames = FALSE, summary = FALSE, out=("Table_res_ratio_under_predicted.htm"))
stargazer(over.predicted.ratio,type="html",rownames = FALSE, summary = FALSE, out=("Table_res_ratio_over_predicted.htm"))

```
