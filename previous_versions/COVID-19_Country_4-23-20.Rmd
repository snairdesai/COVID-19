---
title: "COVID-19_Country"
author: "Sameer Nair-Desai"
date: "4/23/2020"
output: 
  html_document: default
  pdf_document: default
  word_document: default
---

## If you do not wish to run the code, please see the final output (graphs and datasets) provided in the COVID-19_Final Project folder. Make sure to check the README file for the contents of the folder.

# Installing the relevant packages.
install.packages("sf")
install.packages("readr")
install.packages("tmap") 
install.packages("leaflet") 
install.packages("mapview") 
install.packages("ggplot2")
install.packages("tidyverse")
install.packages("rlang")
install.packages("reshape")
install.packages("rgdal")
install.packages("lubridate")
install.packages("plotly")
install.packages("patchwork")
install.packages("ggforce")
install.packages("gridExtra")
install.packages("htmltools")
install.packages("data.table")
install.packages("webshot")
webshot::install_phantomjs()
install.packages("runner")
install.packages("zoo")
install.packages("devtools")
devtools::install_version("latticeExtra", version="0.6-28")
install.packages("Hmisc")
install.packages("DataCombine")
install.packages("fastDummies")
install.packages("heatmaply")
install.packages("glmnet")
install.packages("caret")
install.packages("summarytools")
install.packages("remote")
remotes::install_github('rapporter/pander')
install.packages("mlbench")
install.packages("psych")
install.packages("lmtest")
install.packages("quantmod")

##### Run all imports in the console. #####
```{r libraries}
# Setting our libraries.
library(sf)
library(readr)
library(mapview)
library(ggplot2)
library(tidyverse)
library(rlang)
library(reshape)
library(rgdal)
library(lubridate)
library(plotly)
library(patchwork)
library(ggforce)
library(gridExtra)
library(htmltools)
library(data.table)
library(webshot)
library(coronavirus)
library(runner)
library(zoo)
library(DataCombine)
library(fastDummies)
library(car)
library(heatmaply)
library(htmlwidgets)
library(summarytools)
library(glmnet)
library(caret)
library(mlbench)
library(psych)
library(plm)
library(lmtest)
library(quantmod)
library(leaflet)
# I don't want scientific notation for my values, so I specify this below.
options(scipen = 999)
```

## CLEANING - Note that confirmed cases and deaths are recorded as rolling sums in the Hopkins dataset.
```{r cleaning}
# Import and quickly cleaning our data. We will call the import our initial confirmed data (Wide). Run this in the console.
Initial_Confirmed_Wide <- read_csv("COVID-19_Final/data/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv")
```

# Creating our Temporary and World data files.
```{r creation}
# Our data is in wide format. Here, I translate it to long format.
Confirmed_Long <- pivot_longer(Initial_Confirmed_Wide, cols = c(5:90), names_to = "Dates", values_to = "Confirmed_Cases")

# Now, I rename my column for country in the long dataset.
Confirmed_Long$COUNTRY <- Confirmed_Long$`Country/Region`

# I can also convert the dates into a more usable string format with lubridate.
Confirmed_Long$Date <- mdy(Confirmed_Long$Dates, quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"),
  truncated = 0)
order(Confirmed_Long$Date)

# Now, I repeat these steps for the deceased data. Run this in the console.
Initial_Deceased_Wide <- read_csv("COVID-19_Final/data/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv")

# We continue with the reshape.
Deceased_Long <- pivot_longer(Initial_Deceased_Wide, cols = c(5:90), names_to = "Dates", values_to = "Deceased")
require(reshape)
Deceased_Long$COUNTRY <- Deceased_Long$`Country/Region`
Deceased_Long$Date <- mdy(Deceased_Long$Dates, quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"),
  truncated = 0)
order(Deceased_Long$Date)

# I then merge the cleaned deceased and confirmed datasets.
Merged_Data <- cbind(Confirmed_Long, Deceased_Long)
colnames(Merged_Data)

# I only keep the variables we are interested in.
myvars <- c("COUNTRY", "Province/State", "Lat", "Long", "Dates", "Confirmed_Cases", "Date", "Deceased")

# I rename this file as our temporary data.
Temporary_Data_Country <- Merged_Data[myvars]

# We might also want a dataset with the total number of global confirmed cases and deaths per day.
World_Data <- Temporary_Data_Country %>% group_by(Date) %>%
summarise(country='World', Global_Confirmed_Cases = sum(Confirmed_Cases, na.rm=T),
Global_Deceased = sum(Deceased, na.rm=T))
World_Data$Death_Rate <- ((World_Data$Global_Deceased/World_Data$Global_Confirmed_Cases) * 100)
```

# Collapsing and calculating relevant variables in the temporary data.
```{r calculations}
# Here, I subset the data so as to properly collapse by country.
myvarstemporary <- c("COUNTRY", "Date", "Confirmed_Cases", "Deceased")

Temporary_Data_Country <- Temporary_Data_Country[myvarstemporary]

Temporary_Data_Country <- Temporary_Data_Country %>%
  group_by(COUNTRY, Date) %>%
  summarise(Total_Cases_Country = sum(Confirmed_Cases), Total_Deceased_Country = sum(Deceased))

# I next want to calculate the increase in deaths and confirmed cases per day.

Temporary_Data_Country %>%
  arrange(COUNTRY, Date)

number <- nrow(Temporary_Data_Country)
First_Day <- min(Temporary_Data_Country$Date)

Temporary_Data_Country$New_Confirmed_Country <- ifelse(Temporary_Data_Country$Date == First_Day, NA, Temporary_Data_Country$Total_Cases_Country - dplyr::lag(Temporary_Data_Country$Total_Cases_Country, number=1))

Temporary_Data_Country$New_Total_Deceased_Country <- ifelse(Temporary_Data_Country$Date == First_Day, NA, Temporary_Data_Country$Total_Deceased_Country - dplyr::lag(Temporary_Data_Country$Total_Deceased_Country, number=1))

# There are a few values for which we have negative new deaths and new cases. Intuitively, this shouldn't make sense. This is actually a problem which steps from the COVID data. For example, Iceland has some weird values in the initial dataframe. Although deaths should represent cumulative sums, if we observe the data from 3/15 - 4/05, we note that the number of recorded deaths drops from 5 to 0, then increases back to six as the month progresses. This is a well-documented problem which stems from the original Github data: https://github.com/CSSEGISandData/COVID-19/issues/2379; https://github.com/CSSEGISandData/COVID-19/issues/2165. 
# We can either exclude data points which show a decrease in cumulative deaths (which I haven't done here); or wait for the data to be updated. Because we only drop a few observations from the analysis, I choose to exclude them, and proceed as normal.

Temporary_Data_Country[which(Temporary_Data_Country$New_Confirmed_Country >= 0),]
Temporary_Data_Country[which(Temporary_Data_Country$New_Total_Deceased_Country >= 0),]

# Now, I calculate the total mortality rate per capita, new mortality rate per capita, death rate per capita, and confirmed cases per capita (using data from the United Nations on global demographics for the merge). Run this in the console.

UN_Population <- read_csv("COVID-19_Final/data/UN_Population_Data.csv")

# Now, I rename the countries to align with the temporary data.
UN_Population$COUNTRY <- UN_Population$Location

UN_Population[25, "COUNTRY"] <- "Bolivia"
UN_Population[30, "COUNTRY"] <- "Brunei"
UN_Population[43, "COUNTRY"] <- "Taiwan*"
UN_Population[46, "COUNTRY"] <- "Congo (Brazzaville)"
UN_Population[54, "COUNTRY"] <-"Cote d'Ivoire"
UN_Population[56, "COUNTRY"] <- "Congo (Kinshasa)"
UN_Population[98, "COUNTRY"] <- "Iran"
UN_Population[112, "COUNTRY"] <- "Laos"
UN_Population[138, "COUNTRY"] <- "Burma"
UN_Population[162, "COUNTRY"] <- "Korea, South"
UN_Population[163, "COUNTRY"] <- "Moldova"
UN_Population[165, "COUNTRY"] <- "Russia"
UN_Population[196, "COUNTRY"] <- "Syria"
UN_Population[212, "COUNTRY"] <- "Tanzania"
UN_Population[213, "COUNTRY"] <- "US"
UN_Population[217, "COUNTRY"] <- "Venezuela"
UN_Population[218, "COUNTRY"] <- "Vietnam"

# I subset the file to only include the nations in our final data.
UN_Population <- subset(UN_Population, is.element(UN_Population$COUNTRY, Temporary_Data_Country$COUNTRY))

# Lastly, I join the two dataframes.
Temporary_Data_Country <- inner_join(Temporary_Data_Country, UN_Population)

# This allows me to calculate our variable of interest: the mortality rate per capita (for both total deaths, and new deaths).
Temporary_Data_Country$Total_Mortality_Rate_Per_Capita = (Temporary_Data_Country$Total_Deceased_Country / Temporary_Data_Country$Population)

Temporary_Data_Country$New_Mortality_Rate_Per_Capita = (Temporary_Data_Country$New_Total_Deceased_Country / Temporary_Data_Country$Population)

# We might also be interested in cases per capita.
Temporary_Data_Country$Total_Cases_Country_Per_Capita = (Temporary_Data_Country$Total_Cases_Country / Temporary_Data_Country$Population)

# Lastly, I want to create a rolling average of the total and new mortality rates per capita, new confirmed cases, and new deaths. This is a bit complicated, so bear with me.

# First, I order the data by country and date.
Temporary_Data_Country <- Temporary_Data_Country[order(Temporary_Data_Country$COUNTRY, Temporary_Data_Country$Date),]

# I then construct a seven-day rolling average of confirmed cases, deaths, and both types of mortality rates by country.
Temporary_Data_Country <- Temporary_Data_Country %>%
  group_by(COUNTRY) %>%
  mutate(rolling_average_confirmed = frollmean(New_Confirmed_Country, 7))
Temporary_Data_Country <- Temporary_Data_Country %>%
  group_by(COUNTRY) %>%
  mutate(rolling_average_deceased= frollmean(New_Total_Deceased_Country, 7))
Temporary_Data_Country <- Temporary_Data_Country %>%
  group_by(COUNTRY) %>%
  mutate(total_rolling_average_mortality = frollmean(Total_Mortality_Rate_Per_Capita, 7))
Temporary_Data_Country <- Temporary_Data_Country %>%
  group_by(COUNTRY) %>%
  mutate(new_rolling_average_mortality = frollmean(New_Mortality_Rate_Per_Capita, 7))

# The seven-day rolling average works well, but the algorithm only gives an output after the first week since a new confirmed case (as we need seven prior values to be non-missing for the sake of our calculation). Ideally, we would want these missing values to have their own rolling averages (i.e. a rolling average of two days for the second date in our dataset; or a rolling average of five days for the fifth date). To do this, I first create a new dataframe with our missing values from the initial seven-day rolling average.
Missing_Mean_Confirmed <- Temporary_Data_Country[which(is.na(Temporary_Data_Country$rolling_average_confirmed)), ]
Missing_Mean_Total_Deceased_Country <- Temporary_Data_Country[which(is.na(Temporary_Data_Country$rolling_average_deceased)), ]
Missing_Mean_Total_Mortality <- Temporary_Data_Country[which(is.na(Temporary_Data_Country$total_rolling_average_mortality)), ]
Missing_Mean_New_Mortality <- Temporary_Data_Country[which(is.na(Temporary_Data_Country$new_rolling_average_mortality)), ]

# Next, I calculate a "new" rolling average for each of our nations, using the roll apply function. The syntax is complicated; but essentially this command allows the user the freedom to vary rolling averages by different "windows" of dates (i.e. three-day average vs. six-day average).
Missing_Mean_Confirmed <- Missing_Mean_Confirmed %>% 
  group_by(COUNTRY) %>%
  mutate(rolling_average_confirmed2 = rollapply(New_Confirmed_Country, 6, mean, na.rm = TRUE, fill = NA, align = 'right', partial=TRUE))
Missing_Mean_Total_Deceased_Country <- Missing_Mean_Total_Deceased_Country %>% 
  group_by(COUNTRY) %>%
  mutate(rolling_average_deceased2 = rollapply(New_Total_Deceased_Country, 6, mean, na.rm = TRUE, fill = NA, align = 'right', partial=TRUE))
Missing_Mean_Total_Mortality <- Missing_Mean_Total_Mortality %>% 
  group_by(COUNTRY) %>%
  mutate(total_rolling_average_mortality2 = rollapply(Total_Mortality_Rate_Per_Capita, 6, mean, na.rm = TRUE, fill = NA, align = 'right', partial=TRUE))
Missing_Mean_New_Mortality <- Missing_Mean_New_Mortality %>% 
  group_by(COUNTRY) %>%
  mutate(new_rolling_average_mortality2 = rollapply(New_Mortality_Rate_Per_Capita, 6, mean, na.rm = TRUE, fill = NA, align = 'right', partial=TRUE))

# We now want to merge this data back to our temporary file.
Temporary_Data_Country <- merge(Temporary_Data_Country, Missing_Mean_Confirmed, by = c("COUNTRY", "Date"), all=TRUE)
Temporary_Data_Country <- merge(Temporary_Data_Country, Missing_Mean_Total_Deceased_Country, by = c("COUNTRY", "Date"), all=TRUE)
Temporary_Data_Country <- merge(Temporary_Data_Country, Missing_Mean_Total_Mortality, by = c("COUNTRY", "Date"), all=TRUE)
Temporary_Data_Country <- merge(Temporary_Data_Country, Missing_Mean_New_Mortality, by = c("COUNTRY", "Date"), all=TRUE)

# Lastly, we can replace the missing values in our temporary file (for the confirmed rolling averages prior to one week) with the newly calculated "partial" rolling averages. We then replace all missing values with zero (the only missing values which remain are for our first day, when naturally no new cases will be recorded, or, in the case of our rolling average for the mortality rate, for dates in which we don't yet have a recorded case).
Temporary_Data_Country$rolling_average_confirmed.x[is.na(Temporary_Data_Country$rolling_average_confirmed.x)] <- Temporary_Data_Country$rolling_average_confirmed2[is.na(Temporary_Data_Country$rolling_average_confirmed.x)]
Temporary_Data_Country$rolling_average_confirmed.x[is.na(Temporary_Data_Country$rolling_average_confirmed.x)] <- 0
Temporary_Data_Country$rolling_average_confirmed <- Temporary_Data_Country$rolling_average_confirmed.x
Temporary_Data_Country$rolling_average_deceased.x[is.na(Temporary_Data_Country$rolling_average_deceased.x)] <- Temporary_Data_Country$rolling_average_deceased2[is.na(Temporary_Data_Country$rolling_average_deceased.x)]
Temporary_Data_Country$rolling_average_deceased.x[is.na(Temporary_Data_Country$rolling_average_deceased.x)] <- 0
Temporary_Data_Country$rolling_average_deceased <- Temporary_Data_Country$rolling_average_deceased.x
Temporary_Data_Country$total_rolling_average_mortality.x[is.na(Temporary_Data_Country$total_rolling_average_mortality.x)] <- Temporary_Data_Country$total_rolling_average_mortality2[is.na(Temporary_Data_Country$total_rolling_average_mortality.x)]
Temporary_Data_Country$total_rolling_average_mortality.x[is.na(Temporary_Data_Country$total_rolling_average_mortality.x)] <- 0
Temporary_Data_Country$total_rolling_average_mortality <- Temporary_Data_Country$total_rolling_average_mortality.x
Temporary_Data_Country$new_rolling_average_mortality.x[is.na(Temporary_Data_Country$new_rolling_average_mortality.x)] <- Temporary_Data_Country$new_rolling_average_mortality2[is.na(Temporary_Data_Country$new_rolling_average_mortality.x)]
Temporary_Data_Country$new_rolling_average_mortality.x[is.na(Temporary_Data_Country$new_rolling_average_mortality.x)] <- 0
Temporary_Data_Country$new_rolling_average_mortality <- Temporary_Data_Country$new_rolling_average_mortality.x

# I only keep columns we care about (which are not repetitive).
Temporary_Data_Country$Total_Cases_Country <- Temporary_Data_Country$Total_Cases_Country.x
Temporary_Data_Country$Total_Deceased_Country <- Temporary_Data_Country$Total_Deceased_Country.x
Temporary_Data_Country$New_Confirmed_Country <- Temporary_Data_Country$New_Confirmed_Country.x
Temporary_Data_Country$New_Total_Deceased_Country <- Temporary_Data_Country$New_Total_Deceased_Country.x
Temporary_Data_Country$Death_Rate <- Temporary_Data_Country$Death_Rate.x
Temporary_Data_Country$Total_Mortality_Rate_Per_Capita <- Temporary_Data_Country$Total_Mortality_Rate_Per_Capita.x
Temporary_Data_Country$New_Mortality_Rate_Per_Capita <- Temporary_Data_Country$New_Mortality_Rate_Per_Capita.x
Temporary_Data_Country$Location <- Temporary_Data_Country$Location.x
Temporary_Data_Country$Population <- Temporary_Data_Country$Population.x
Temporary_Data_Country$Total_Cases_Country_Per_Capita <- Temporary_Data_Country$Total_Cases_Country_Per_Capita.x
Temporary_Data_Country$rolling_average_confirmed <- Temporary_Data_Country$rolling_average_confirmed.x
Temporary_Data_Country$rolling_average_deceased <- Temporary_Data_Country$rolling_average_deceased.x
Temporary_Data_Country$total_rolling_average_mortality <- Temporary_Data_Country$total_rolling_average_mortality.x
Temporary_Data_Country$new_rolling_average_mortality <- Temporary_Data_Country$new_rolling_average_mortality.x

colnames(Temporary_Data_Country)
myvarstemp <- c("COUNTRY", "Date", "Total_Cases_Country", "Total_Deceased_Country", "New_Confirmed_Country", "New_Total_Deceased_Country", "Population", "Total_Mortality_Rate_Per_Capita", "New_Mortality_Rate_Per_Capita", "Total_Cases_Country_Per_Capita", "rolling_average_confirmed", "rolling_average_deceased", "total_rolling_average_mortality", "new_rolling_average_mortality")
Temporary_Data_Country <- Temporary_Data_Country[myvarstemp]
```

```{r coordinates}
# When we collapse the COVID data to the country level, we lose our coordinate data. I now merge a dataset on global coordinates by country from: https://developers.google.com/public-data/docs/canonical/countries_csv. Note that I edited country names to match the data in the CSV itself. Run this in the console.
Country_Coordinates <- read_csv("COVID-19_Final/data/Country_Coordinates.csv")

Country_Coordinates$COUNTRY <- Country_Coordinates$Country

colnames(Country_Coordinates)
myvarscoords <- c("COUNTRY", "Latitude", "Longitude")
Country_Coordinates <- Country_Coordinates[myvarscoords]

# I subset the file to only include the nations in our final data.
Country_Coordinates <- subset(Country_Coordinates, is.element(Country_Coordinates$COUNTRY, Temporary_Data_Country$COUNTRY))

# Lastly, I merge the two dataframes.
Temporary_Data_Country <- merge(Temporary_Data_Country, Country_Coordinates, by = c("COUNTRY"), all=TRUE)

```

# Labelling and saving our temporary data.
```{r labelling}
library(lattice)
library(Hmisc)

label(Temporary_Data_Country$Total_Cases_Country) <- "Cumulative Sum of Confirmed Cases by Country (John Hopkins)"
label(Temporary_Data_Country$Total_Deceased_Country) <- "Cumulative Sum of Deaths by Country (John Hopkins)"
label(Temporary_Data_Country$New_Confirmed_Country) <- "Daily Increase in Confirmed Cases (John Hopkins)"
label(Temporary_Data_Country$New_Total_Deceased_Country) <- "Daily Increase in Deaths (John Hopkins)"
label(Temporary_Data_Country$Total_Mortality_Rate_Per_Capita) <- "Total Deaths by Population (Total_Deceased_Country/Population)"
label(Temporary_Data_Country$New_Mortality_Rate_Per_Capita) <- "New Deaths by Population (New_Total_Deceased_Country/Population)"
label(Temporary_Data_Country$Total_Cases_Country_Per_Capita) <- "Total Cases by Population (Total_Cases_Country/Population)"
label(Temporary_Data_Country$rolling_average_confirmed) <- "Seven Day Rolling Average of New Confirmed Cases by Country (with the exception of Days 1-7)"
label(Temporary_Data_Country$rolling_average_deceased) <- "Seven Day Rolling Average of New Deaths by Country (with the exception of Days 1-7)"
label(Temporary_Data_Country$total_rolling_average_mortality) <- "Seven Day Rolling Average of Case Mortality Rate by Country (with the exception of Days 1-7)"

# This represents the "Temporary_Data_Country.csv" file saved in the data folder. I recommend you load in the CSV directly to ensure there are no discrepancies between the edits made in the Cloud, as opposed to my own R Project.

# Removing the Cloud version of the Temporary Data.
remove(Temporary_Data_Country)

# Importing the Temporary Data from the data folder. Run this in the console.
Temporary_Data_Country <- read_csv("COVID-19_Final/data/Temporary_Data_Country.csv")

```

# Merging our government data and temporary data to create a final dataframe.
```{r final data}
# Now, I want to merge our data with the Oxford dataset on global policy responses. Please see a description of the variables here: https://www.bsg.ox.ac.uk/sites/default/files/2020-03/BSG-WP-2020-031-v3.0.pdf. 
# The source is: Hale, Thomas, Anna Petherick, Toby Phillips, Samuel Webster. “Variation in Government Responses to COVID-19” Version 3.0. Blavatnik School of Government Working Paper. March 31, 2020. Available: www.bsg.ox.ac.uk/covidtracker.
# See https://www.bsg.ox.ac.uk/sites/default/files/Calculation%20and%20presentation%20of%20the%20Stringency%20Index.pdf for information on how the stringency index was calculated.

# Run this in the console.
Government_Responses <- read_csv("COVID-19_Final/data/Government_Responses.csv")

# First, I convert the date to a proper format.
Government_Responses$Date <- ymd(Government_Responses$Date, quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"),
  truncated = 0)
order(Government_Responses$Date)

# Then, I correct country and variable names.

Government_Responses$COUNTRY <- Government_Responses$CountryName
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Cape Verde", "Cabo Verde", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Congo", "Congo (Brazzaville)", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Democratic Republic of Congo", "Congo (Kinshasa)", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Myanmar", "Burma", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Czech Republic", "Czechia", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Swaziland", "Eswatini", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Krygz Republic", "Kyrgyzstan", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "South Korea", "Korea, South", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Macedonia", "North Macedonia", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Slovak Republic", "Slovakia", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Macedonia", "North Macedonia", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Taiwan", "Taiwan*", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "Timor", "Timor-Leste", Government_Responses$COUNTRY)
Government_Responses$COUNTRY <- ifelse(Government_Responses$COUNTRY == "United States", "US", Government_Responses$COUNTRY)

colnames(Government_Responses)

Government_Responses$S1_School.closing <- Government_Responses$`S1_School closing`
Government_Responses$S2_Workplace.closing <- Government_Responses$`S2_Workplace closing`
Government_Responses$S3_Cancel.public.events <- Government_Responses$`S3_Cancel public events`
Government_Responses$S4_Close.public.transport <- Government_Responses$`S4_Close public transport`
Government_Responses$S5_Public.information.campaigns <- Government_Responses$`S5_Public information campaigns`
Government_Responses$S6_Restrictions.on.internal.movement <- Government_Responses$`S6_Restrictions on internal movement`
Government_Responses$S7_International.travel.controls <- Government_Responses$`S7_International travel controls`
Government_Responses$S8_Fiscal.measures <- Government_Responses$`S8_Fiscal measures`
Government_Responses$S9_Monetary.measures <- Government_Responses$`S9_Monetary measures`
Government_Responses$S10_Emergency.investment.in.health.care <- Government_Responses$`S10_Emergency investment in health care`
Government_Responses$S11_Investment.in.Vaccines <- Government_Responses$`S11_Investment in Vaccines`
Government_Responses$S12_Testing.framework <- Government_Responses$`S12_Testing framework`
Government_Responses$S13_Contact.tracing <- Government_Responses$`S13_Contact tracing`

# I now subset the data. PLEASE NOTE the observations change in this merge. Oxford began collecting data before Hopkins started tracking cases and deaths. For simplicity, I use the merged data from before to visualize the confirmed cases and deaths (as these dates are filtered correctly).
Government_Responses <- subset(Government_Responses, is.element(Government_Responses$COUNTRY, Temporary_Data_Country$COUNTRY))

# Note that we have two sets of variables for confirmed cases and deaths. The first, I label "Oxford_Cases" and "Oxford_Deaths". The second (from John Hopkins) I label "Total_Cases_Country" and "Total_Deceased_Country". At a later date, we might want to cross-reference these values. Note that Oxford does not provide calculations for province/state; however it is highly likely they used the (same) John Hopkins data.
Government_Responses$Oxford_Cases <- Government_Responses$ConfirmedCases
Government_Responses$Oxford_Deaths <- Government_Responses$ConfirmedDeaths

# Once more, I only keep the variables we are interested in. I elect not to keep the notes... these can be re-added if preferred. 

colnames(Government_Responses)
myvarsgovernment <- c("COUNTRY", "Date", "S1_School.closing", "S1_IsGeneral", "S2_Workplace.closing", "S2_IsGeneral", "S3_Cancel.public.events", "S3_IsGeneral", "S4_Close.public.transport", "S4_IsGeneral", "S5_Public.information.campaigns", "S5_IsGeneral", "S6_Restrictions.on.internal.movement", "S6_IsGeneral", "S7_International.travel.controls", "S8_Fiscal.measures", "S9_Monetary.measures", "S10_Emergency.investment.in.health.care", "S11_Investment.in.Vaccines", "S12_Testing.framework", "S13_Contact.tracing", "StringencyIndex", "Oxford_Cases", "Oxford_Deaths")

Government_Responses <- Government_Responses[myvarsgovernment]

# I then merge our data.
Final_Data_Country <- merge(Temporary_Data_Country, Government_Responses, by = c("COUNTRY", "Date"), all=TRUE)

# Next, I specify a set of lagged government response variables for use in our regression later (one-week, two-week, and three-week lags). First, I filter the data and create a lag function for each week (these functions are also used for generating the lags in our testing data).

Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

# This can be done in a for loop, but I don't know how to properly code that yet. I also convert each variable to factors.

# One Week
Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S1_School.closing", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_School_Closing_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_School_Closing_One_Week <- as.factor(Final_Data_Country$Lagged_School_Closing_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S1_IsGeneral", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_School_Closing_General_One_Week", keepInvalid = TRUE, reminder = FALSE)
  
Final_Data_Country$Lagged_School_Closing_General_One_Week <- as.factor(Final_Data_Country$Lagged_School_Closing_General_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S2_Workplace.closing", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Workplace_Closing_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Workplace_Closing_One_Week <- as.factor(Final_Data_Country$Lagged_Workplace_Closing_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S2_IsGeneral", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Workplace_Closing_General_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Workplace_Closing_General_One_Week <- as.factor(Final_Data_Country$Lagged_Workplace_Closing_General_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S3_Cancel.public.events", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Events_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Public_Events_One_Week <- as.factor(Final_Data_Country$Lagged_Public_Events_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S3_IsGeneral", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Events_General_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Public_Events_General_One_Week <- as.factor(Final_Data_Country$Lagged_Public_Events_General_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S4_Close.public.transport", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Transport_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Public_Transport_One_Week <- as.factor(Final_Data_Country$Lagged_Public_Transport_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S4_IsGeneral", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Transport_General_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Public_Transport_General_One_Week <- as.factor(Final_Data_Country$Lagged_Public_Transport_General_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S5_Public.information.campaigns", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Campaign_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Campaign_One_Week <- as.factor(Final_Data_Country$Lagged_Campaign_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S5_IsGeneral", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Campaign_General_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Campaign_General_One_Week <- as.factor(Final_Data_Country$Lagged_Campaign_General_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S6_Restrictions.on.internal.movement", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Internal_Movement_One_Week", keepInvalid =   
  TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Internal_Movement_One_Week <- as.factor(Final_Data_Country$Lagged_Internal_Movement_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S6_IsGeneral",slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Internal_Movement_General_One_Week", keepInvalid = TRUE, reminder =  FALSE)

Final_Data_Country$Lagged_Internal_Movement_General_One_Week <- as.factor(Final_Data_Country$Lagged_Internal_Movement_General_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S7_International.travel.controls", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_International_Travel_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_International_Travel_One_Week <- as.factor(Final_Data_Country$Lagged_International_Travel_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S8_Fiscal.measures", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Fiscal_Measures_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S9_Monetary.measures", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Monetary_Measures_One_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S10_Emergency.investment.in.health.care", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Health_Care_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S11_Investment.in.Vaccines", TimeVar = "Date", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Vaccine_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S12_Testing.framework", TimeVar = "Date", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Testing_Framework_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Testing_Framework_One_Week <- as.factor(Final_Data_Country$Lagged_Testing_Framework_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S13_Contact.tracing", TimeVar = "Date", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Contact_Tracing_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Contact_Tracing_One_Week <- as.factor(Final_Data_Country$Lagged_Contact_Tracing_One_Week)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "StringencyIndex", TimeVar = "Date", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Stringency_Index_One_Week", keepInvalid 
  = TRUE, reminder = FALSE)
  
# Two Weeks
Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S1_School.closing", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_School_Closing_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)
  
Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S1_IsGeneral", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_School_Closing_General_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S2_Workplace.closing", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Workplace_Closing_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S2_IsGeneral", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Workplace_Closing_General_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S3_Cancel.public.events", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Events_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S3_IsGeneral", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Events_General_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S4_Close.public.transport", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Transport_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S4_IsGeneral", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Transport_General_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S5_Public.information.campaigns", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Campaign_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S5_IsGeneral", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Campaign_General_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S6_Restrictions.on.internal.movement", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Internal_Movement_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S6_IsGeneral",slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Internal_Movement_General_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)
  
Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S7_International.travel.controls", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_International_Travel_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S8_Fiscal.measures", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Fiscal_Measures_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S9_Monetary.measures", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Monetary_Measures_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S10_Emergency.investment.in.health.care", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Health_Care_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)
  
Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S11_Investment.in.Vaccines", TimeVar = "Date", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Vaccine_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S12_Testing.framework", TimeVar = "Date", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Testing_Framework_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Testing_Framework_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Testing_Framework_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S13_Contact.tracing", TimeVar = "Date", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Contact_Tracing_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Contact_Tracing_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Contact_Tracing_Two_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "StringencyIndex", TimeVar = "Date", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Stringency_Index_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

# Three Weeks
Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S1_School.closing", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_School_Closing_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S1_IsGeneral", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_School_Closing_General_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S2_Workplace.closing", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Workplace_Closing_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S2_IsGeneral", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Workplace_Closing_General_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S3_Cancel.public.events", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Events_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S3_IsGeneral", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Events_General_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S4_Close.public.transport", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Transport_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S4_IsGeneral", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Public_Transport_General_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S5_Public.information.campaigns", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Campaign_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S5_IsGeneral", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Campaign_General_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S6_Restrictions.on.internal.movement", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Internal_Movement_Three_Weeks", keepInvalid =   TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S6_IsGeneral",slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Internal_Movement_General_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S7_International.travel.controls", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_International_Travel_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S8_Fiscal.measures", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Fiscal_Measures_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S9_Monetary.measures", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Monetary_Measures_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S10_Emergency.investment.in.health.care", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Health_Care_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S11_Investment.in.Vaccines", TimeVar = "Date", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Vaccine_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S12_Testing.framework", TimeVar = "Date", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Testing_Framework_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Testing_Framework_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Testing_Framework_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "S13_Contact.tracing", TimeVar = "Date", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Contact_Tracing_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_Contact_Tracing_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Contact_Tracing_Three_Weeks)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "StringencyIndex", TimeVar = "Date", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Stringency_Index_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country$Lagged_School_Closing_Two_Weeks <- as.factor(Final_Data_Country$Lagged_School_Closing_Two_Weeks)
Final_Data_Country$Lagged_School_Closing_General_Two_Weeks <- as.factor(Final_Data_Country$Lagged_School_Closing_General_Two_Weeks)
Final_Data_Country$Lagged_Workplace_Closing_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Workplace_Closing_Two_Weeks)
Final_Data_Country$Lagged_Workplace_Closing_General_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Workplace_Closing_General_Two_Weeks)
Final_Data_Country$Lagged_Public_Events_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Public_Events_Two_Weeks)
Final_Data_Country$Lagged_Public_Events_General_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Public_Events_General_Two_Weeks)
Final_Data_Country$Lagged_Public_Transport_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Public_Transport_Two_Weeks)
Final_Data_Country$Lagged_Public_Transport_General_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Public_Transport_General_Two_Weeks)
Final_Data_Country$Lagged_Campaign_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Campaign_Two_Weeks)
Final_Data_Country$Lagged_Campaign_General_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Campaign_General_Two_Weeks)
Final_Data_Country$Lagged_Internal_Movement_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Internal_Movement_Two_Weeks)
Final_Data_Country$Lagged_Internal_Movement_General_Two_Weeks <- as.factor(Final_Data_Country$Lagged_Internal_Movement_General_Two_Weeks)
Final_Data_Country$Lagged_International_Travel_Two_Weeks <- as.factor(Final_Data_Country$Lagged_International_Travel_Two_Weeks)

Final_Data_Country$Lagged_School_Closing_Three_Weeks <- as.factor(Final_Data_Country$Lagged_School_Closing_Three_Weeks)
Final_Data_Country$Lagged_School_Closing_General_Three_Weeks <- as.factor(Final_Data_Country$Lagged_School_Closing_General_Three_Weeks)
Final_Data_Country$Lagged_Workplace_Closing_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Workplace_Closing_Three_Weeks)
Final_Data_Country$Lagged_Workplace_Closing_General_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Workplace_Closing_General_Three_Weeks)
Final_Data_Country$Lagged_Public_Events_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Public_Events_Three_Weeks)
Final_Data_Country$Lagged_Public_Events_General_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Public_Events_General_Three_Weeks)
Final_Data_Country$Lagged_Public_Transport_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Public_Transport_Three_Weeks)
Final_Data_Country$Lagged_Public_Transport_General_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Public_Transport_General_Three_Weeks)
Final_Data_Country$Lagged_Campaign_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Campaign_Three_Weeks)
Final_Data_Country$Lagged_Campaign_General_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Campaign_General_Three_Weeks)
Final_Data_Country$Lagged_Internal_Movement_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Internal_Movement_Three_Weeks)
Final_Data_Country$Lagged_Internal_Movement_General_Three_Weeks <- as.factor(Final_Data_Country$Lagged_Internal_Movement_General_Three_Weeks)
Final_Data_Country$Lagged_International_Travel_Three_Weeks <- as.factor(Final_Data_Country$Lagged_International_Travel_Three_Weeks)
```

# Now, I add socioeconomic controls from the World Development Indicators.

```{r controls}

# First, I add the proportion of the national population above 65. Run this in the console.
pop65yo <- read_csv("COVID-19_Final/data/pop65yo.csv")

pop65yo$COUNTRY <- pop65yo$country
pop65yo$prop65 <- pop65yo$value

# Next, I correct the country names.
pop65yo[19, "COUNTRY"] <- "Bahamas"
pop65yo[26, "COUNTRY"] <- "Brunei"
pop65yo[37, "COUNTRY"] <- "Congo (Kinshasa)"
pop65yo[38, "COUNTRY"] <- "Congo (Brazzaville)"
pop65yo[46, "COUNTRY"] <- "Czechia"
pop65yo[53, "COUNTRY"] <- "Egypt"
pop65yo[66, "COUNTRY"] <- "Gambia"
pop65yo[82, "COUNTRY"] <- "Iran"
pop65yo[95, "COUNTRY"] <- "Korea, South"
pop65yo[92, "COUNTRY"] <- "Kyrgyzstan"
pop65yo[97, "COUNTRY"] <- "Laos"
pop65yo[101, "COUNTRY"] <- "Saint Lucia"
pop65yo[116, "COUNTRY"] <- "Burma"
pop65yo[148, "COUNTRY"] <- "Russia"
pop65yo[162, "COUNTRY"] <- "Slovakia"
pop65yo[167, "COUNTRY"] <- "Syria"
pop65yo[182, "COUNTRY"] <- "US"
pop65yo[184, "COUNTRY"] <- "Saint Vincent and the Grenadines"
pop65yo[185, "COUNTRY"] <- "Venezuela"
pop65yo[186, "COUNTRY"] <- "Virgin Islands"
pop65yo[190, "COUNTRY"] <- "Yemen"
pop65yo[5, "COUNTRY"] <- "United Arab Emirates"
pop65yo[62, "COUNTRY"] <- "United Kingdom"
pop65yo[132, "COUNTRY"] <- "New Zealand"
pop65yo[150, "COUNTRY"] <- "Saudi Arabia"
pop65yo[191, "COUNTRY"] <- "South Africa"

pop65yo <- subset(pop65yo, is.element(pop65yo$COUNTRY, Final_Data_Country$COUNTRY))

# I only keep the columns I care about.
colnames(pop65yo)
myvarspop65yo <- c("prop65", "COUNTRY")

pop65yo <- pop65yo[myvarspop65yo]

pop65yo <- pop65yo[order(pop65yo$COUNTRY, pop65yo$prop65),]

Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

Final_Data_Country <- merge(Final_Data_Country, pop65yo, by = c("COUNTRY"), all=TRUE)

Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]

# Now, I add another world development indicator for the proportion of the population which is urban. Run this in the console.
urbanpp <- read_csv("COVID-19_Final/data/urbanpp.csv")

# Next, I correct the country names.
urbanpp[21, "COUNTRY"] <- "Bahamas"
urbanpp[29, "COUNTRY"] <- "Brunei"
urbanpp[40, "COUNTRY"] <- "Congo (Kinshasa)"
urbanpp[41, "COUNTRY"] <- "Congo (Brazzaville)"
urbanpp[50, "COUNTRY"] <- "Czechia"
urbanpp[58, "COUNTRY"] <- "Egypt"
urbanpp[73, "COUNTRY"] <- "Gambia"
urbanpp[91, "COUNTRY"] <- "Iran"
urbanpp[105, "COUNTRY"] <- "Korea, South"
urbanpp[101, "COUNTRY"] <- "Kyrgyzstan"
urbanpp[107, "COUNTRY"] <- "Laos"
urbanpp[111, "COUNTRY"] <- "Saint Lucia"
urbanpp[129, "COUNTRY"] <- "Burma"
urbanpp[164, "COUNTRY"] <- "Russia"
urbanpp[179, "COUNTRY"] <- "Slovakia"
urbanpp[185, "COUNTRY"] <- "Syria"
urbanpp[202, "COUNTRY"] <- "US"
urbanpp[204, "COUNTRY"] <- "Saint Vincent and the Grenadines"
urbanpp[205, "COUNTRY"] <- "Venezuela"
urbanpp[206, "COUNTRY"] <- "Virgin Islands"
urbanpp[211, "COUNTRY"] <- "Yemen"
urbanpp[6, "COUNTRY"] <- "United Arab Emirates"
urbanpp[68, "COUNTRY"] <- "United Kingdom"
urbanpp[147, "COUNTRY"] <- "New Zealand"
urbanpp[166, "COUNTRY"] <- "Saudi Arabia"
urbanpp[212, "COUNTRY"] <- "South Africa"

urbanpp <- subset(urbanpp, is.element(urbanpp$COUNTRY, Final_Data_Country$COUNTRY))

# I only keep the columns I care about.
colnames(urbanpp)
myvarsurbanpp <- c("propurban", "COUNTRY")

urbanpp <- urbanpp[myvarsurbanpp]

Final_Data_Country <- merge(Final_Data_Country, urbanpp, by = c("COUNTRY"), all=TRUE)

Final_Data_Country <- Final_Data_Country[order(Final_Data_Country$COUNTRY, Final_Data_Country$Date),]
```

# Merging the testing data.
```{r testing}

# Next, I add our testing data.
owurl = "https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/testing/covid-testing-all-observations.csv"
testcap <- read_csv(url(owurl))
testcap <- separate(testcap, Entity, into=c("Country", "Unit type"), sep = " - ")

testcap$COUNTRY <- testcap$Country
testcap$COUNTRY <- ifelse(testcap$COUNTRY == "Czech Republic", "Czechia", testcap$COUNTRY)
testcap$COUNTRY <- ifelse(testcap$COUNTRY == "South Korea", "Korea, South", testcap$COUNTRY)
testcap$COUNTRY <- ifelse(testcap$COUNTRY == "Taiwan", "Taiwan*", testcap$COUNTRY)
testcap$COUNTRY <- ifelse(testcap$COUNTRY == "United States", "US", testcap$COUNTRY)

testcap <- subset(testcap, is.element(testcap$COUNTRY, Final_Data_Country$COUNTRY))

# I don't like some of the variable names in the original data, so I change them below.
testcap$Test_Type <- testcap$`Unit type`
testcap$Cumulative_Tests <- testcap$`Cumulative total`
testcap$Daily_Change_Cumulative_Tests <- testcap$`Daily change in cumulative total`
testcap$Cumulative_Tests_Per_Thousand <- testcap$`Cumulative total per thousand`
testcap$Daily_Change_Cumulative_Tests_Per_Thousand <- testcap$`Daily change in cumulative total per thousand`
testcap$Three_Day_Rolling_Mean_Tests <- testcap$`3-day rolling mean daily change`
testcap$Three_Day_Rolling_Mean_Tests_Per_Thousand <- testcap$`3-day rolling mean daily change per thousand`

# Here, I keep the variables I care about.
colnames(testcap)
myvarstest <- c("COUNTRY", "Date", "Test_Type", "Cumulative_Tests", "Daily_Change_Cumulative_Tests", "Cumulative_Tests_Per_Thousand", "Daily_Change_Cumulative_Tests_Per_Thousand", "Three_Day_Rolling_Mean_Tests", "Three_Day_Rolling_Mean_Tests_Per_Thousand")

testcap <- testcap[myvarstest]

# Now, I convert from long to wide format.
testcap <- pivot_wider(testcap, id_cols = c("COUNTRY", "Date", "Test_Type"), names_from = "Test_Type", values_from = c("Cumulative_Tests", "Daily_Change_Cumulative_Tests", "Cumulative_Tests_Per_Thousand", "Daily_Change_Cumulative_Tests_Per_Thousand", "Three_Day_Rolling_Mean_Tests", "Three_Day_Rolling_Mean_Tests_Per_Thousand"))

# Now, I merge the data to our final file.
Final_Data_Country <- merge(Final_Data_Country, testcap, by = c("COUNTRY", "Date"), all=TRUE)
```

# Merging the mobility data.

```{r mobility}

# Here, I integrate the Apple Mobility data. Run this in the console.
mobility <- read_csv("COVID-19_Final/data/applemobilitytrends-2020-04-12.csv")

# First, we convert from wide to long format.
mobility <- pivot_longer(mobility, cols = c(4:94), names_to = "Dates")

# Next, we reformat the dates.
mobility$Date <- mdy(mobility$Dates, quiet = FALSE, tz = NULL, locale = Sys.getlocale("LC_TIME"),
  truncated = 0)

# I only keep the variables we care about. I also filter for only countries (we can re-add cities at a later period).

mobility <- mobility %>%
  filter(mobility$geo_type == "country/region")

colnames(mobility)
myvarsmobility <- c("region", "transportation_type", "Date", "value")

mobility <- mobility[myvarsmobility]

mobility$COUNTRY <- mobility$region

# Now, I re-convert from long to wide format.
mobility <- pivot_wider(mobility, id_cols = c("COUNTRY", "Date", "transportation_type"), names_from = "transportation_type", values_from = c("value"))

# Next, we ensure the countries from the mobility file and our data align.

mobility$COUNTRY <- ifelse(mobility$COUNTRY == "Czech Republic", "Czechia", mobility$COUNTRY)
mobility$COUNTRY <- ifelse(mobility$COUNTRY == "Republic of Korea", "Korea, South", mobility$COUNTRY)
mobility$COUNTRY <- ifelse(mobility$COUNTRY == "Taiwan", "Taiwan*", mobility$COUNTRY)
mobility$COUNTRY <- ifelse(mobility$COUNTRY == "UK", "United Kingdom", mobility$COUNTRY)
mobility$COUNTRY <- ifelse(mobility$COUNTRY == "United States", "US", mobility$COUNTRY)

mobility <- subset(mobility, is.element(mobility$COUNTRY, Final_Data_Country$COUNTRY))

Final_Data_Country <- merge(Final_Data_Country, mobility, by = c("COUNTRY", "Date"), all=TRUE)

```

# Lastly, I perform our last edits and save the final dataframe.
```{r editing}

# Labelling our variables.
label(Final_Data_Country$S1_School.closing) <- "Record Closings of Schools and Universities (0 - No Measures; 1 - Recommended Closing; 2 - Required Closing)"
label(Final_Data_Country$S1_IsGeneral) <- "Targeted vs. General School Closings (0 - Targeted; 1 - General)"
label(Final_Data_Country$S2_Workplace.closing) <- "Record Closings of Workplaces (0 - No Measures; 1 - Recommended Closing; 2 - Required Closing)"
label(Final_Data_Country$S2_IsGeneral) <- "Targeted vs. General Workplace Closings (0 - Targeted; 1 - General)"
label(Final_Data_Country$S3_Cancel.public.events) <- "Record Closings of Public Events (0 - No Measures; 1 - Recommended Cancelling; 2 - Required Cancelling)"
label(Final_Data_Country$S3_IsGeneral) <- "Targeted vs. General Public Event Closings (0 - Targeted; 1 - General)"
label(Final_Data_Country$S4_Close.public.transport) <- "Record Closings of Public Transport (0 - No Measures; 1 - Recommended Closing; 2 - Required Closing)"
label(Final_Data_Country$S4_IsGeneral) <- "Targeted vs. General Public Transport Closings (0 - Targeted; 1 - General)"
label(Final_Data_Country$S5_Public.information.campaigns) <- "Record Presence of Public Information Campaigns (0 - No; 1 - Yes)"
label(Final_Data_Country$S5_IsGeneral) <- "Targeted vs. General Public Information Campaigns (0 - Targeted; 1 - General)"
label(Final_Data_Country$S6_Restrictions.on.internal.movement) <- "Record Restrictions on Internal Movement (0 - No Measures; 1 - Recommend Movement Restriction; 2 - Restrict Movement)"
label(Final_Data_Country$S6_IsGeneral) <- "Targeted vs. General Restrictions on Internal Movement (0 - Targeted; 1 - General)"
label(Final_Data_Country$S7_International.travel.controls) <- "Record Restrictions on International Travel (0 - No Measures; 1 - Screening; 2 - Quarantine on High-Risk Regions; 3 - Ban on High-Risk Regions)"
label(Final_Data_Country$S8_Fiscal.measures) <- "Value of Fiscal Stimuli, Including Spending or Tax Cuts (in USD)"
label(Final_Data_Country$S9_Monetary.measures) <- "Value of the Interest Rate (Percent)"
label(Final_Data_Country$S10_Emergency.investment.in.health.care) <- "Value of New Short-Term Spending on Health (in USD)"
label(Final_Data_Country$S11_Investment.in.Vaccines) <- "Value of Investment (in USD)"
label(Final_Data_Country$S12_Testing.framework) <- "Who Can Get Tested (0 - No Testing Policy; 1 - Testing for those with a) Symptoms AND b) Meet Given Criteria (key workers; admitted to hospital; came into contact with known patient; returned from overseas); 2 - Testing of anyone showing symptoms; 3 - Open Public Testing ('drive-through testing')"
label(Final_Data_Country$S13_Contact.tracing) <- "Contact Tracing (0 - No Contact Tracing; 1 - Limited Contact Tracing; 2 - Comprehensive Contact Tracing)"
label(Final_Data_Country$StringencyIndex) <- "Index for Government Stringency (calculated using S1-S7)"
label(Final_Data_Country$Oxford_Cases) <- "Cumulative Sum of Confirmed Cases by Country (Oxford)"
label(Final_Data_Country$Oxford_Deaths) <- "Cumulative Sum of Deaths by Country (Oxford)"
label(Final_Data_Country$prop65) <- "Proportion of the Population Above Age 65 (Oxford)"
label(Final_Data_Country$propurban) <- "Proportion of Population in Urban Areas (Oxford)"

# For now, we are restricting our analysis to OECD/EM markets. I do so below, using a loose definition of EMs from: https://www.msci.com/documents/10199/c0db0a48-01f2-4ba9-ad01-226fd5678111

Final_Data_Country <- subset(Final_Data_Country, (COUNTRY == "Australia" |COUNTRY == "Austria" |COUNTRY == "Belgium" | COUNTRY == "Canada" | COUNTRY == "Chile" |COUNTRY == "Czechia" |COUNTRY == "Denmark" | COUNTRY == "Estonia" | COUNTRY == "Finland" |COUNTRY == "France" |COUNTRY == "Germany" | COUNTRY == "Greece" | COUNTRY == "Hungary" |COUNTRY == "Iceland" |COUNTRY == "Ireland" | COUNTRY == "Israel" | COUNTRY == "Italy" |COUNTRY == "Japan" |COUNTRY == "Korea, South" | COUNTRY == "Latvia" | COUNTRY == "Lithuania" |COUNTRY == "Luxembourg" |COUNTRY == "Mexico" | COUNTRY == "Netherlands" | COUNTRY == "New Zealand" |COUNTRY == "Norway" |COUNTRY == "Poland" | COUNTRY == "Portugal" | COUNTRY == "Slovakia" |COUNTRY == "Slovenia" |COUNTRY == "Spain" | COUNTRY == "Sweden" | COUNTRY == "Switzerland" |COUNTRY == "Turkey" |COUNTRY == "United Kingdom" | COUNTRY == "US" | COUNTRY == "Russia" |COUNTRY == "India" |COUNTRY == "China" | COUNTRY == "Brazil"| COUNTRY == "South Africa" |COUNTRY == "Austria" | COUNTRY == "Canada" | COUNTRY == "Colombia" |COUNTRY == "Egypt" |COUNTRY == "Indonesia" | COUNTRY == "Malaysia" | COUNTRY == "Pakistan" |COUNTRY == "Peru" |COUNTRY == "Philippines" | COUNTRY == "Qatar" | COUNTRY == "Thailand" | COUNTRY == "United Arab Emirates" | COUNTRY == "Argentina" | COUNTRY == "Saudi Arabia"))

# Next, I label and perform final cleaning on the final dataset. This is excluded for brevity.
```

# We now have a final panel dataset. I remove the Cloud file and import the saved CSV, to ensure there are no discrepancies.
```{r saving}
remove(Final_Data_Country)

# Run this in the console. Note that I change the column types so reader can properly parse the data.

Final_Data_Country <- read_csv(("COVID-19_Final/data/Final_Data_Country.csv"), 
  col_types = cols(`Cumulative_Tests_samples tested` = col_number(),
    `Cumulative_Tests_cases tested` = col_number(), 
    `Cumulative_Tests_tests sampled` = col_number(), 
    `Cumulative_Tests_samples analyzed` = col_number(), 
    `Cumulative_Tests_swabs tested` = col_number(), 
    `Cumulative_Tests_samples analysed` = col_number(),
    `Cumulative_Tests_inconsistent units (COVID Tracking Project)` =  col_number(), 
    `Cumulative_Tests_specimens tested (CDC)` = col_number(), 
    `Daily_Change_Cumulative_Tests_samples tested` = col_number(), 
    `Daily_Change_Cumulative_Tests_cases tested` = col_number(), 
    `Daily_Change_Cumulative_Tests_tests sampled` = col_number(), 
    `Daily_Change_Cumulative_Tests_samples analyzed` = col_number(), 
    `Daily_Change_Cumulative_Tests_swabs tested` = col_number(), 
    `Daily_Change_Cumulative_Tests_samples analysed`= col_number(), 
    `Daily_Change_Cumulative_Tests_inconsistent units (COVID Tracking Project)`  = col_number(), 
    `Daily_Change_Cumulative_Tests_specimens tested (CDC)` = col_number(), 
    `Cumulative_Tests_Per_Thousand_samples tested` = col_number(), 
    `Cumulative_Tests_Per_Thousand_cases tested` = col_number(),
    `Cumulative_Tests_Per_Thousand_tests sampled` = col_number(),
    `Cumulative_Tests_Per_Thousand_samples processed` = col_number(),
    `Cumulative_Tests_Per_Thousand_tests sampled` = col_number(),
    `Cumulative_Tests_Per_Thousand_samples analyzed` = col_number(),
    `Cumulative_Tests_Per_Thousand_swabs tested` = col_number(),
    `Cumulative_Tests_Per_Thousand_samples analysed` = col_number(),
    `Cumulative_Tests_Per_Thousand_inconsistent units (COVID Tracking Project)` = col_number(),
    `Cumulative_Tests_Per_Thousand_specimens tested (CDC)` = col_number(),
    `Daily_Change_Cumulative_Tests_Per_Thousand_tests performed` = col_number(),
    `Daily_Change_Cumulative_Tests_Per_Thousand_units unclear` = col_number(),
    `Daily_Change_Cumulative_Tests_Per_Thousand_samples tested` = col_number(),
    `Daily_Change_Cumulative_Tests_Per_Thousand_cases tested` = col_number(),
    `Daily_Change_Cumulative_Tests_Per_Thousand_people tested` = col_number(),
    `Daily_Change_Cumulative_Tests_Per_Thousand_samples processed` = col_number(),
    `Daily_Change_Cumulative_Tests_Per_Thousand_tests sampled` = col_number(),
    `Daily_Change_Cumulative_Tests_Per_Thousand_samples analyzed` = col_number(),
    `Daily_Change_Cumulative_Tests_Per_Thousand_swabs tested` = col_number(),
    `Daily_Change_Cumulative_Tests_Per_Thousand_samples analysed` = col_number(),
    `Daily_Change_Cumulative_Tests_Per_Thousand_inconsistent units (COVID Tracking Project)` = col_number(),
    `Daily_Change_Cumulative_Tests_Per_Thousand_specimens tested (CDC)` = col_number(),
    `Three_Day_Rolling_Mean_Tests_tests performed` = col_number(),
    `Three_Day_Rolling_Mean_Tests_units unclear` = col_number(),
    `Three_Day_Rolling_Mean_Tests_samples tested` = col_number(),
    `Three_Day_Rolling_Mean_Tests_cases tested` = col_number(),
    `Three_Day_Rolling_Mean_Tests_people tested` = col_number(),
    `Three_Day_Rolling_Mean_Tests_samples processed` = col_number(),
    `Three_Day_Rolling_Mean_Tests_tests sampled` = col_number(),
    `Three_Day_Rolling_Mean_Tests_samples analyzed` = col_number(),
    `Three_Day_Rolling_Mean_Tests_swabs tested` = col_number(),
    `Three_Day_Rolling_Mean_Tests_samples analysed` = col_number(),
    `Three_Day_Rolling_Mean_Tests_inconsistent units (COVID Tracking Project)` = col_number(),
    `Three_Day_Rolling_Mean_Tests_specimens tested (CDC)` = col_number(),
    `Three_Day_Rolling_Mean_Tests_Per_Thousand_tests performed` = col_number(),
    `Three_Day_Rolling_Mean_Tests_Per_Thousand_units unclear` = col_number(),
    `Three_Day_Rolling_Mean_Tests_Per_Thousand_samples tested` = col_number(),
    `Three_Day_Rolling_Mean_Tests_Per_Thousand_cases tested` = col_number(),
    `Three_Day_Rolling_Mean_Tests_Per_Thousand_people tested` = col_number(),
    `Three_Day_Rolling_Mean_Tests_Per_Thousand_samples processed` = col_number(),
    `Three_Day_Rolling_Mean_Tests_Per_Thousand_tests sampled` = col_number(),
    `Three_Day_Rolling_Mean_Tests_Per_Thousand_samples analyzed` = col_number(),
    `Three_Day_Rolling_Mean_Tests_Per_Thousand_swabs tested` = col_number(),
    `Three_Day_Rolling_Mean_Tests_Per_Thousand_samples analysed` = col_number(),
    `Three_Day_Rolling_Mean_Tests_Per_Thousand_inconsistent units (COVID Tracking Project)` = col_number(),
    `Three_Day_Rolling_Mean_Tests_Per_Thousand_specimens tested (CDC)` = col_number()))

```

# Next, I want to merge the spatial data. We do this after the final dataset has been filtered, to ensure a smaller dataset size.
```{r spatial}
# Now, we want to integrate our spatial datasets from Landscan. Run this in the console.

geo_cepii <- read_csv("COVID-19_Final/data/spatial_data/geo_cepii.csv")

# We only have country-level information for our COVID data. So, we want to collapse the geo_cepii data to the country level, without losing the local variation provided by our coordinates and distances for city indicators. However, in the case where we have multiple cities per country, we must make a decision on how to collapse. I choose to only keep the capital cities, and collapse by countries in this way.

geo_cepii_final <- geo_cepii %>%
  filter(geo_cepii$cap == 1)

geo_cepii_final$COUNTRY <- geo_cepii_final$country
geo_cepii_final$City <- geo_cepii_final$city_en
geo_cepii_final$City_Latitude <- geo_cepii_final$lat
geo_cepii_final$City_Longitude <- geo_cepii_final$lon
geo_cepii_final$Capital <- geo_cepii_final$cap

# Below, I create a new dataframe for merging the geo_cepii data with the distance_cepii data.
geo_cepii_merge <- geo_cepii_final[c(2,35)]

# Now, I read in the distance_cepii data. Run this in the console.
distance_cepii <- read_csv("COVID-19_Final/data/spatial_data/distance_cepii.csv")

# We want to merge by both ISO values, and match the ISOs to country names. I do this below.
geo_cepii_merge$iso_d <- geo_cepii_merge$iso3

merge_1 <- merge(geo_cepii_merge, distance_cepii, by = c("iso_d"), all=TRUE)

geo_cepii_merge$iso_o <- geo_cepii_merge$iso_d

merge_2 <- merge(geo_cepii_merge, merge_1, by = c("iso_o"), all=TRUE)

merge_2$COUNTRY <- merge_2$COUNTRY.x
merge_2$COUNTRY_Dyad <- merge_2$COUNTRY.y

colnames(merge_2)

Cepii_Data_Final <- merge(geo_cepii_final, merge_2, by = c("COUNTRY"), all=TRUE)

# I keep only the relevant variables.

myvarscepiifinal <- c("COUNTRY", "COUNTRY_Dyad", "dist", "distcap", "distw", "distwces", "area", "dis_int", "landlocked", "continent", "City", "City_Latitude", "City_Longitude", "Capital", "maincity", "langoff_1", "langoff_2", "langoff_3", "lang20_1", "lang20_2", "lang20_3", "lang20_4", "lang9_1", "lang9_2", "lang9_3", "lang9_4", "colonizer1", "colonizer2", "colonizer3", "colonizer4", "short_colonizer1", "short_colonizer2", "short_colonizer3", "contig", "comlang_off", "comlang_ethno", "colony", "comcol", "curcol", "col45", "smctry")

Cepii_Data_Final <- Cepii_Data_Final[myvarscepiifinal]

label(Cepii_Data_Final$landlocked) <- "Dummy Variable for Landlocked (0 = No; 1 = Yes)"
label(Cepii_Data_Final$Capital) <- "Dummy Variable for City being Capital City (0 = No; 1 = Yes)"
label(Cepii_Data_Final$maincity) <- "Dummy Variable for City being Main City (0 = No; 1 = Yes)"

# Next, we want to merge our spatial data from CEPII to our COVID dataset. We don't use this for our preliminary estimations (simply due to the sheer size of the dataset, but we may do so later). If you wish to view the merged file, see "Spatial_Merged.csv" in the spatial_data folder.

```

## INTERACTIVE VISUALIZATIONS
## First, I generate an initial interactive marker map. I am initially only mapping a static moment in time. The most interesting trend would be a global, country-by-country comparison between the number of cases at our FIRST recorded date, compared to those at our LAST recorded date. This is just as interesting as an animated panel map because it gives us a blunt picture of the severity of COVID's spread, from the latest data. ALL of these plots are available in the output folders.
```{r initial marker (confirmed) - January 22nd, 2020}
# I start by making a marker map which captures the number of confirmed cases on the first date of recorded data. To isolate these values, we must filter the dataframe to include observations for this date.

X1.22.20 <- Temporary_Data_Country %>%
  filter(Date == "2020-01-22")

# First, I want to visualize the "relative intensity" of cases across the world (using a consistent scale). To do this, I cut my variable into six quantiles, based on the values of confirmed cases from the LAST available date (3-31-20).
X1.22.20$magrangeconfirmed = cut(X1.22.20$Total_Cases_Country,
                          breaks = c(0, 100, 1000, 5000, 25000, 85000, 700000),
                          right=FALSE, labels = c("Very Low [0-100)", "Low     
                          [100-1000)", "Moderate [1000-5000)", "High [5000-25000)",
                          "Very High [2500-85000)", "Extreme [85000-700000]"))

# I also want to jitter the latitude and longitude of my data points, in case our observations are clustered. We want to introduce a jitter which is large enough to differentiate markers, but not so large as to affect our spatial accuracy. I use a factor of 1.
X1.22.20$Lat <- jitter(X1.22.20$Latitude, factor = 1)
X1.22.20$Long <- jitter(X1.22.20$Longitude, factor = 1)

# To ease the user's interpretation of our data, we want to create an interactive label which provides information on each data point when the user hovers over the markers.
X1.22.20$labelconfirmed <- paste ("<Country: >", X1.22.20$COUNTRY, "<p>",
                         "<Confirmed Cases: >", X1.22.20$Total_Cases_Country, "<p>")

# Finally, we can construct our initial marker map. First, I set different colors for each quantile.
pal = colorFactor(palette = c("#CCCCCC", "#999999", "#99FF33", "#FFCC33", "#FF6600", "#990000"), domain=X1.22.20$magrangeconfirmed)

# Now, I pass the data through leaflet and generate the map.
Plot_1 <- leaflet(data=X1.22.20) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addCircleMarkers(data=X1.22.20, lng = ~Longitude, lat = ~Latitude,
                 # Here, I add the color pallete to shade the markers by intensity.
                 color = ~ pal(magrangeconfirmed),
                 weight = 5,
                 radius = 10,
                 label = lapply(X1.22.20$labelconfirmed, HTML),
                 clusterOptions = markerClusterOptions()) %>%
addLegend("bottomright", pal = pal, values = ~magrangeconfirmed,
    title = "Total Confirmed Cases - COVID19 (January 22nd, 2020)",
    opacity = 1)
Plot_1
```

```{r initial marker (deceased) - January 22nd, 2020}
# Now, I repeat the process for deaths. Note that in both of these maps, we see low values (which makes sense, given this was the start of the pandemic).

X1.22.20$magrangedeceased = cut(X1.22.20$Total_Deceased_Country,
                          breaks = c(0, 25, 100, 500, 1000, 10000, 35000), right=FALSE,
                          labels = c("Very Low [0-25)", "Low [25-100)", "Moderate [100-500)", "High [500-1000)", "Very High   
                                     [1000-10000)", "Extreme [10000-35000]"))
X1.22.20$Lat <- jitter(X1.22.20$Latitude, factor = 1)
X1.22.20$Long <- jitter(X1.22.20$Longitude, factor = 1)
X1.22.20$labeldeceased <- paste ("<Country: >", X1.22.20$COUNTRY, "<p>",
                         "<Deceased: >", X1.22.20$Total_Deceased_Country, "<p>")
pal = colorFactor(palette = c("#CCCCCC", "#999999", "#99FF33", "#FFCC33", "#FF6600", "#990000"), domain=X1.22.20$magrangedeceased)
Plot_2 <- leaflet(data=X1.22.20) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addCircleMarkers(data=X1.22.20, lng = ~Longitude, lat = ~Latitude,
                 color = ~ pal(magrangedeceased),
                 weight = 5,
                 radius = 10,
                 label = lapply(X1.22.20$labeldeceased, HTML),
                 clusterOptions = markerClusterOptions()) %>%
addLegend("bottomright", pal = pal, values = ~magrangedeceased,
    title = "Total Deaths - COVID19 (January 22nd, 2020)",
    opacity = 1)
Plot_2
```

```{r last marker (confirmed) - April 16th, 2020}
# Now, I repeat the same procedure for the last date in our dataset.
X4.16.20 <- Temporary_Data_Country %>%
  filter(Date == "2020-04-16")

X4.16.20$magrangeconfirmed2 = cut(X4.16.20$Total_Cases_Country, 
                          breaks = c(0, 100, 1000, 5000, 25000, 85000, 700000),
                          right=FALSE, labels = c("Very Low [0-100)", "Low     
                          [100-1000)", "Moderate [1000-5000)", "High [5000-25000)",
                          "Very High [2500-85000)", "Extreme [85000-700000]"))
X4.16.20$Lat <- jitter(X4.16.20$Latitude, factor = 1)
X4.16.20$Long <- jitter(X4.16.20$Longitude, factor = 1)
X4.16.20$labelconfirmed <- paste ("<Country: >", X4.16.20$COUNTRY, "<p>",
                         "<Confirmed Cases: >", X4.16.20$Total_Cases_Country, "<p>")

# Finally, we can construct our initial marker map. First, I set different colors for each quantile.
pal = colorFactor(palette = c("#CCCCCC", "#999999", "#99FF33", "#FFCC33", "#FF6600", "#990000"), domain=X4.16.20$magrangeconfirmed2)
# Now, I pass the data through leaflet and generate the map.
Plot_3 <- leaflet(data=X4.16.20) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addCircleMarkers(data=X4.16.20, lng = ~Longitude, lat = ~Latitude,
                 # Here, I add the color pallete to shade the markers by intensity.
                 color = ~ pal(magrangeconfirmed2),
                 weight = 5,
                 radius = 10,
                 label = lapply(X4.16.20$labelconfirmed, HTML),
                 clusterOptions = markerClusterOptions()) %>%
addLegend("bottomright", pal = pal, values = ~magrangeconfirmed2,
    title = "Total Confirmed Cases - COVID19 (April 16th, 2020)",
    opacity = 1)
Plot_3
```

```{r last marker (deceased) - March 31st, 2020}
X4.16.20$magrangedeceased2 = cut(X4.16.20$Total_Deceased_Country,
                          breaks = c(0, 25, 100, 500, 1000, 10000, 35000), right=FALSE,
                          labels = c("Very Low [0-25)", "Low [25-100)", "Moderate [100-500)", "High [500-1000)", "Very High   
                                     [1000-10000)", "Extreme [10000-35000]"))
X4.16.20$Lat <- jitter(X4.16.20$Latitude, factor = 1)
X4.16.20$Long <- jitter(X4.16.20$Longitude, factor = 1)
X4.16.20$labeldeceased <- paste ("<Country: >", X4.16.20$COUNTRY, "<p>",
                         "<Deceased: >", X4.16.20$Total_Deceased_Country, "<p>")
pal = colorFactor(palette = c("#CCCCCC", "#999999", "#99FF33", "#FFCC33", "#FF6600", "#990000"), domain=X4.16.20$magrangedeceased2)
Plot_4 <- leaflet(data=X4.16.20) %>%
addProviderTiles(providers$CartoDB.Positron) %>%
addCircleMarkers(data=X4.16.20, lng = ~Longitude, lat = ~Latitude,
                 color = ~ pal(magrangedeceased2),
                 weight = 5,
                 radius = 10,
                 label = lapply(X4.16.20$labeldeceased, HTML),
                 clusterOptions = markerClusterOptions()) %>%
addLegend("bottomright", pal = pal, values = ~magrangedeceased2,
    title = "Total Deaths - COVID19 (April 16th, 2020)",
    opacity = 1)
Plot_4

```

```{r bubbles}
# Now we create bubble maps for confirmed and deceased. Credit for some of these visualizations goes to: Yanchang Zhao, COVID-19 Data Analysis with R – Worldwide. RDataMining.com, 2020. URL: http://www.rdatamining.com/docs/Coronavirus-data-analysis-world.pdf. 
Plot_5 <- leaflet(data = X4.16.20) %>% 
  addProviderTiles(providers$CartoDB.Positron) %>%
  addCircleMarkers(X4.16.20$Longitude, X4.16.20$Latitude,
  radius=2+log2(X4.16.20$Total_Cases_Country), stroke=F,
  color='red', fillOpacity=0.3, label = lapply(X4.16.20$labelconfirmed, HTML))
Plot_5

Plot_6 <- leaflet(data = X4.16.20) %>% 
  addProviderTiles(providers$CartoDB.Positron) %>%
  addCircleMarkers(X4.16.20$Longitude, X4.16.20$Latitude,
  radius=2+log2(X4.16.20$Total_Deceased_Country), stroke=F,
  color='black', fillOpacity=0.3, label = lapply(X4.16.20$labeldeceased, HTML))
Plot_6
```

## Creating an interactive choropleth map for overall confirmed cases and deaths (Bloomberg Plot 2). I use the temporary data, which includes the complete set of nations. NOTE I do not include the choropleth below because R Cloud cannot properly read in the shape file. However, the code is available if needed, and the completed maps are in the output.

## TIME SERIES ANALYSIS

```{r Bloomberg Plot 1 (confirmed)}
# Here, I recreate a version of the first Bloomberg graph from below: https://www.bloomberg.com/graphics/2020-coronavirus-cases-world-map/. To isolate a nation of interest, simply click on it in the legend at right. You can isolate multiple nations at once. I use the final data here, which is only our developed/emerging markets of interest.
Days_Since_100_Confirmed <- Final_Data_Country %>%
  filter(Total_Cases_Country >= 100)

Days_Since_100_Confirmed <- Days_Since_100_Confirmed %>%
  group_by(COUNTRY) %>%
  mutate(Days = row_number(COUNTRY))

Plot_9 <- plot_ly(Days_Since_100_Confirmed, x=~Days, y=~Total_Cases_Country) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Days Since 100 Cases - COVID19", yaxis = list(type = "log"))
Plot_9
```

```{r Bloomberg Plot 1 (deceased)}
# Now, I repeat the process for deaths.
Days_Since_100_Deceased <- Final_Data_Country %>%
  filter(Total_Deceased_Country >= 100)

Days_Since_100_Deceased <- Days_Since_100_Deceased %>%
  group_by(COUNTRY) %>%
  mutate(Days = row_number(COUNTRY))

Plot_10 <- plot_ly(Days_Since_100_Deceased, x=~Days, y=~Total_Deceased_Country) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Days Since 100 Deaths - COVID19")
Plot_10
```

```{r Bloomberg Plot 3 (confirmed)}
# Here, I recreate a version the third Bloomberg graph, plotting new global cases per day: https://www.bloomberg.com/graphics/2020-coronavirus-cases-world-map/.
New_Global_Cases <- Temporary_Data_Country %>%
  group_by(Date) %>%
  summarise(New_Cases = sum(New_Confirmed_Country))

New_Confirmed <- ggplot(data = New_Global_Cases, aes(x = Date, y = New_Cases)) +
      geom_bar(stat = "identity", fill = "dodgerblue") +
      labs(title = "New Confirmed Cases - COVID19",
           subtitle = "January 23rd, 2020 - April 16th, 2020",
           x = "Date", y = "New Confirmed Cases")
Plot_11 <- ggplotly(New_Confirmed)
Plot_11
```

```{r Bloomberg Plot 3 (deceased)}
# Now, I do the same thing for deaths.
New_Global_Deaths <- Temporary_Data_Country %>%
  group_by(Date) %>%
  summarise(New_Deaths = sum(New_Total_Deceased_Country))

New_Deaths <- ggplot(data = New_Global_Deaths, aes(x = Date, y = New_Deaths)) +
      geom_bar(stat = "identity", fill = "sandybrown") +
      labs(title = "New Deaths - COVID19",
           subtitle = "January 23rd, 2020 - April 16th, 2020",
           x = "Date", y = "New Deaths")
Plot_12 <- ggplotly(New_Deaths)
Plot_12
```

# Next, I construct a graph illustrating the seven-day rolling average of new deaths, new cases, and the mortality rate per capita. This is a version of the fourth Bloomberg plot from the above link.

```{r Bloomberg Plot 4}
Plot_13 <- plot_ly(Temporary_Data_Country, x=~Date, y=~rolling_average_confirmed) %>% add_lines(linetype = ~COUNTRY) %>% layout(title="Rolling Average of Confirmed Cases")
Plot_13

Plot_14 <- plot_ly(Temporary_Data_Country, x=~Date, y=~rolling_average_deceased) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Rolling Average of Deaths")
Plot_14

Plot_15 <- plot_ly(Temporary_Data_Country, x=~Date, y=~total_rolling_average_mortality) %>% add_lines(linetype = ~COUNTRY) %>% layout(title="Total Rolling Average of Mortality Rate per Capita")
Plot_15

Plot_16 <- plot_ly(Temporary_Data_Country, x=~Date, y=~new_rolling_average_mortality) %>% add_lines(linetype = ~COUNTRY) %>% layout(title="New Rolling Average of Mortality Rate per Capita")
Plot_16

```

```{r time series 1}
# Here, I plot the global confirmed cases over our time period.
exponential <- function(x) exp(x)
exponential_function <- ggplot(data = data.frame(x=c(0,10)), mapping=aes(x=x)) + stat_function(fun = exponential)
exponential_function

Global_Cases <- Temporary_Data_Country %>%
  group_by(Date) %>%
  summarise(Cases = sum(Total_Cases_Country))

Confirmed <- ggplot(data = Global_Cases, aes(x = Date, y = Cases)) +
      geom_bar(stat = "identity", fill = "red") +
      labs(title = "Global Confirmed Cases - COVID19",
           subtitle = "January 22nd, 2020 - April 16th, 2020",
           x = "Date", y = "Confirmed Cases")
Plot_17 <- ggplotly(Confirmed)
Plot_17

# Now, I plot the global deaths over our time period.
Global_Deaths <- Temporary_Data_Country %>%
  group_by(Date) %>%
  summarise(Deaths = sum(Total_Deceased_Country))

Deaths <- ggplot(data = Global_Deaths, aes(x = Date, y = Deaths)) +
      geom_bar(stat = "identity", fill = "darkred") +
      labs(title = "Global Deaths - COVID19",
           subtitle = "January 22nd, 2020 - April 16th, 2020",
           x = "Date", y = "Deaths")
Plot_18 <- ggplotly(Deaths)
Plot_18

# Now, I plot the mortality rate per capita over our time period, for our total and new mortality rates.
Total_Global_Mortality <- Temporary_Data_Country %>%
  group_by(Date) %>%
  summarise(Total_Mortality = sum(Total_Mortality_Rate_Per_Capita))

Total_Mortality <- ggplot(data = Total_Global_Mortality, aes(x = Date, y = Total_Mortality)) +
      geom_bar(stat = "identity", fill = "darkblue") +
      labs(title = "Total Global Mortality Rate - COVID19",
           subtitle = "January 22nd, 2020 - April 16th, 2020",
           x = "Date", y = "Total Mortality Rate Per Capita")
Plot_19 <- ggplotly(Total_Mortality)
Plot_19

New_Global_Mortality <- Temporary_Data_Country %>%
  group_by(Date) %>%
  summarise(New_Mortality = sum(New_Mortality_Rate_Per_Capita))

New_Mortality <- ggplot(data = New_Global_Mortality, aes(x = Date, y = New_Mortality)) +
      geom_bar(stat = "identity", fill = "purple") +
      labs(title = "New Global Mortality Rate - COVID19",
           subtitle = "January 22nd, 2020 - April 16th, 2020",
           x = "Date", y = "New Mortality Rate Per Capita")
Plot_20 <- ggplotly(New_Mortality)
Plot_20

```

```{r time series 2}
# Now, I plot the change in the global death rate across the time period.
Death_Rate <- ggplot(World_Data, aes(x=Date)) +
geom_line(aes(y=Death_Rate, colour='Daily')) +
xlab('') + ylab('Death Rate (%)') + labs(title='Change in Death Rate (%)') +
theme(legend.position='bottom', legend.title=element_blank(),
legend.text=element_text(size=8),
legend.key.size=unit(0.5, 'cm'),
axis.text.x=element_text(angle=45, hjust=1))
Plot_21 <- ggplotly(Death_Rate)
Plot_21
```

```{r time series 3}
# This plot compares the number of deaths to the number of confirmed cases across the time period.
Plots <- Temporary_Data_Country %>%
  group_by(Date) %>%
  summarise(Confirmed_Total = sum(Total_Cases_Country), Deceased_Total = sum(Total_Deceased_Country))

plot1 <- ggplot(data = Plots, aes(x = Date, y = Confirmed_Total)) +
      geom_line(color = "royalblue1")
plot2 <- ggplot(data = Plots, aes(x = Date, y = Deceased_Total)) +
      geom_line(color = "orangered2")

overlay2 <- ggplot(data = Plots, aes(x = Date)) +
      geom_line(aes(y = Confirmed_Total), color = "royalblue1") + geom_line(aes(y = Deceased_Total), color = "orangered2") + scale_y_continuous(name = "Total Confirmed Cases", sec.axis = sec_axis(trans = ~.*1, name = "Total Deaths"))
Plot_22 <- ggplotly(overlay2)
Plot_22
```

```{r time series 4}
# Now, I extend this analysis to generate the number of confirmed cases and deaths by country.
Plot_23 <- plot_ly(Temporary_Data_Country, x=~Date, y=~Total_Cases_Country) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Confirmed Cases Across Countries")
Plot_23

Plot_24 <- plot_ly(Temporary_Data_Country, x=~Date, y=~Total_Deceased_Country) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Deaths Across Countries")
Plot_24

Plot_25 <- plot_ly(Temporary_Data_Country, x=~Date, y=~Total_Mortality_Rate_Per_Capita) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Total Mortality Rate Across Countries")
Plot_25

Plot_26 <- plot_ly(Temporary_Data_Country, x=~Date, y=~New_Mortality_Rate_Per_Capita) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="New Mortality Rate Across Countries")
Plot_26

```

# Next, I filter the data to be only observations past the first death (per nation); and then calculate and visualize the week-by-week growth rate in the rolling average of the mortality rate.
``` {r growth rates}
# Here, I filter by first deaths per country.
First_Death <- Final_Data_Country %>%
  group_by(COUNTRY) %>%
  filter(Total_Deceased_Country > 0)

# Now, I calculate the week-by-week growth rate in the rolling average of the mortality rate. This is equivalent to the log[total_total_rolling_average_mortality_(t) – total_total_rolling_average_mortality_(t-7)]. First, I create a variable for weeks by country. This tells us in what week of the year each nation had their first death.
First_Death$week_num = lubridate::week(ymd(First_Death$Date))

# Next, I generate week-over-week mortality growth rates. I use two distinct formulas for this calculation.

First_Death <- First_Death %>%
  group_by(COUNTRY) %>%
  mutate(total_mortality_growth = log((total_rolling_average_mortality/Lag(total_rolling_average_mortality,7))))

First_Death <- First_Death %>%
  group_by(COUNTRY) %>%
  mutate(total_mortality_growth_b <- (total_rolling_average_mortality-Lag(total_rolling_average_mortality,7))/Lag(total_rolling_average_mortality,7))

First_Death$total_mortality_growth_b  <- log(First_Death$`... <- NULL`,10)

First_Death <- First_Death %>%
  group_by(COUNTRY) %>%
  mutate(new_mortality_growth <- log((new_rolling_average_mortality/Lag(new_rolling_average_mortality,7)))) 

First_Death$new_mortality_growth  <- First_Death$`... <- NULL`

First_Death <- First_Death %>%
  group_by(COUNTRY) %>%
  mutate(new_mortality_growth_b <- (new_rolling_average_mortality-Lag(new_rolling_average_mortality,7))/Lag(new_rolling_average_mortality,7))

First_Death$new_mortality_growth_b  <- log(First_Death$`... <- NULL`,10)

# Please see the First Death dataset in the data folder.

# The following code allows us to visualize the rolling average of the mortality rate by country.
Plot_27 <- plot_ly(First_Death, x=~Date, y=~total_rolling_average_mortality) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Total Rolling Average of Mortality Rate Over Time - COVID19")
Plot_27

# Here, I implement a log axis.
Plot_28 <- Plot_27 %>% layout(yaxis = list(type = "log"))
Plot_28

# Next, I create initial visualizations of the mortality growth rates by country. I still need to normalize the value at t=0 (first death) to be 1 for each country.
Plot_29 <- plot_ly(First_Death, x=~Date, y=~total_mortality_growth) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Weekly Growth Rate in Total Rolling Average Mortality per Capita - COVID19")
Plot_29

Plot_30 <- plot_ly(First_Death, x=~Date, y=~total_mortality_growth_b) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Alternate Weekly Growth Rate in Total Rolling Average Mortality per Capita - COVID19")
Plot_30

Plot_31 <- plot_ly(First_Death, x=~Date, y=~new_mortality_growth) %>%
  add_lines(linetype = ~COUNTRY) %>%
  layout(title="Weekly Growth Rate in New Rolling Average Mortality per Capita - COVID19")
Plot_31

```

# Now, I want to conduct some pre-estimation visualizations. The first is a set of summary statistics for our main covariates of interest. I am most interested in knowing the number of missing values for each regressor.
```{r summaries}
# First, we generate extensive summary statistics for each variable with describe in the Hmisc function.
Hmisc::describe(Final_Data_Country)
# n, nmiss, unique, mean, 5, 10, 25, 50, 75, 90, 95th percentiles

# Next, I generate shareable outputs, using the summarytools package. Set st_options(use.x11 = FALSE).
saved_x11_option <- st_options("use.x11")
st_options(use.x11 = TRUE)
dfSummary(Final_Data_Country, plain.ascii = FALSE, style = "grid", 
          graph.magnif = 0.75, valid.col = FALSE, tmp.img.dir = "/tmp")
view(dfSummary(Final_Data_Country))
# For the complete output, please open the summary in the html link.
```

# Next, I create a correlation matrix and generate a heatmap to visualize relationships of interest.
```{r correlations}

# Now, I generate a correlation heat map, using a subset of variables from the final dataset.
corrmapvarlist <- c("total_rolling_average_mortality", "Total_Cases_Country", "Total_Deceased_Country", "New_Confirmed_Country", "New_Total_Deceased_Country", "Population", "rolling_average_confirmed", "rolling_average_deceased", "S1_School.closing", "S1_IsGeneral", "S2_Workplace.closing", "S2_IsGeneral", "S3_Cancel.public.events", "S3_IsGeneral", "S4_Close.public.transport", "S4_IsGeneral", "S5_Public.information.campaigns", "S5_IsGeneral", "S6_Restrictions.on.internal.movement", "S6_IsGeneral", "S7_International.travel.controls", "S8_Fiscal.measures", "S9_Monetary.measures", "S10_Emergency.investment.in.health.care", "S11_Investment.in.Vaccines", "S12_Testing.framework", "S13_Contact.tracing", "StringencyIndex", "prop65", "propurban", "driving", "walking", "transit")
corrmapvars <- Final_Data_Country[corrmapvarlist]

# Here, I rename the variables to make them easier to read on the map.
corrmapvars <- corrmapvars %>% dplyr::rename(mortality_ra = total_rolling_average_mortality)
corrmapvars <- corrmapvars %>% dplyr::rename(confirmed_ra = rolling_average_confirmed)
corrmapvars <- corrmapvars %>% dplyr::rename(deceased_ra = rolling_average_deceased)
corrmapvars <- corrmapvars %>% dplyr::rename(cases = Total_Cases_Country)
corrmapvars <- corrmapvars %>% dplyr::rename(deaths = Total_Deceased_Country)
corrmapvars <- corrmapvars %>% dplyr::rename(new_cases = New_Confirmed_Country)
corrmapvars <- corrmapvars %>% dplyr::rename(new_deaths = New_Total_Deceased_Country)
corrmapvars <- corrmapvars %>% dplyr::rename(school_closing = S1_School.closing)
corrmapvars <- corrmapvars %>% dplyr::rename(school_general = S1_IsGeneral)
corrmapvars <- corrmapvars %>% dplyr::rename(work_closing = S2_Workplace.closing)
corrmapvars <- corrmapvars %>% dplyr::rename(work_general = S2_IsGeneral)
corrmapvars <- corrmapvars %>% dplyr::rename(public_event_closing = S3_Cancel.public.events)
corrmapvars <- corrmapvars %>% dplyr::rename(public_event_general = S3_IsGeneral)
corrmapvars <- corrmapvars %>% dplyr::rename(transport_closing = S4_Close.public.transport)
corrmapvars <- corrmapvars %>% dplyr::rename(transport_general = S4_IsGeneral)
corrmapvars <- corrmapvars %>% dplyr::rename(campaigns = S5_Public.information.campaigns)
corrmapvars <- corrmapvars %>% dplyr::rename(campaigns_general = S5_IsGeneral)
corrmapvars <- corrmapvars %>% dplyr::rename(internal_restrictions = S6_Restrictions.on.internal.movement)
corrmapvars <- corrmapvars %>% dplyr::rename(internal_general = S6_IsGeneral)
corrmapvars <- corrmapvars %>% dplyr::rename(travel_restrictions = S7_International.travel.controls)
corrmapvars <- corrmapvars %>% dplyr::rename(fiscal = S8_Fiscal.measures)
corrmapvars <- corrmapvars %>% dplyr::rename(monetary = S9_Monetary.measures)
corrmapvars <- corrmapvars %>% dplyr::rename(health_care = S10_Emergency.investment.in.health.care)
corrmapvars <- corrmapvars %>% dplyr::rename(vaccine = S11_Investment.in.Vaccines)
corrmapvars <- corrmapvars %>% dplyr::rename(testing = S12_Testing.framework)
corrmapvars <- corrmapvars %>% dplyr::rename(contract_tracing = S13_Contact.tracing)
corrmapvars <- corrmapvars %>% dplyr::rename(stringency_index = StringencyIndex)
corrmapvalues <- round(cor(corrmapvars, use = "complete.obs"), 2)

# Here, I get the lower triangle of the correlation matrix
get_lower_tri<-function(cormat){
  cormat[upper.tri(cormat)] <- NA
  return(cormat)
}
# Now, I get the upper triangle of the correlation matrix
get_upper_tri <- function(cormat){
  cormat[lower.tri(cormat)]<- NA
  return(cormat)
}
reorder_cormat <- function(cormat){
### Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}
### Reorder the correlation matrix
corrmapvalues <- reorder_cormat(corrmapvalues)
### Get the Upper Triangle
upper_tri <- get_upper_tri(corrmapvalues) 
### Melt the Correlation Map
melted_corrmap <- reshape2::melt(upper_tri, na.rm = TRUE)

### Generate the Static Correlation Map
ggheatmap <- ggplot(data = melted_corrmap, aes(x=Var2, y=Var1, fill=value)) + 
  geom_tile(color = "black") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white",
    midpoint = 0, limit = c(-1,1), space = "Lab", 
    name="Pearson\nCorrelation") +
  theme(axis.text.x = element_text(angle = 45)) +
  theme(axis.text.x = element_text(margin = margin(t = 5, r = 0, b = 0, l = 0))) +
  theme(axis.text.x = element_text(hjust=1))
print(ggheatmap)
ggsave("Correlation_Heat_Map_Static.png", plot = ggheatmap)

### Generate an Interactive Correlation Map (you are able to zoom to specific correlates).
interactive_heatmap <- heatmaply_cor(
  cor(corrmapvalues),
  row_text_angle = 0,
  column_text_angle = 45,
  na.value = "grey50",
  na.rm = TRUE,
  xlab = "Features",
  ylab = "Features",
  k_col = 0,
  k_row = 0,
  fontsize_row = 5,
  fontsize_col = 5,
  plot_method = c("ggplot", "plotly"),
  show_dendrogram = c(FALSE, FALSE),
  key.title = "Pearson Correlations")
interactive_heatmap

```

# Based on the heatmaps, we might want to explore the relationships of interest in the data more closely (checking for collinearity).
```{r relationships}

str(Final_Data_Country)
# The following code gives us every set of possible relationships between our numeric independent variables. Factor variables and lags have been excluded.

# First, government responses linked to the seven-day rolling average of mortality rates per capita.
pairs.panels(Final_Data_Country[c("total_rolling_average_mortality", "StringencyIndex",  "S9_Monetary.measures", "S10_Emergency.investment.in.health.care", "S11_Investment.in.Vaccines")])

# Next, government responses linked to the total and new mortality rates per capita.
pairs.panels(Final_Data_Country[c("Total_Mortality_Rate_Per_Capita", "StringencyIndex",  "S9_Monetary.measures", "S10_Emergency.investment.in.health.care", "S11_Investment.in.Vaccines")])

pairs.panels(Final_Data_Country[c("New_Mortality_Rate_Per_Capita", "StringencyIndex",  "S9_Monetary.measures", "S10_Emergency.investment.in.health.care", "S11_Investment.in.Vaccines")])

# Lastly, the other covariates of interest linked to both potential dependent variables.
pairs.panels(Final_Data_Country[c("total_rolling_average_mortality", "Total_Cases_Country", "Total_Deceased_Country", "New_Confirmed_Country", "New_Total_Deceased_Country", "Population", "driving", "walking", "transit", "prop65", "propurban")])

pairs.panels(Final_Data_Country[c("new_rolling_average_mortality", "Total_Cases_Country", "Total_Deceased_Country", "New_Confirmed_Country", "New_Total_Deceased_Country", "Population", "driving", "walking", "transit", "prop65", "propurban")])

# We observe clear collinearity between our independent variables. 
```

# Next, I run our preliminary regression analyses.
```{r analysis}
# First, I set our data as a panel.
Final_Data_Country <- pdata.frame(Final_Data_Country, index = c("COUNTRY", "Date"))

# First, I run the preliminary regression examining stringency index as related to mortality rate. Note that half our observations are missing. Note the stringency index includes the first through seventh categories from the Oxford Data (S1-S7). Note also that CSVs do not save the factor variable format; so if you choose to run just the regressions, ensure the relevant variables are converted to factors (see the code above for this).
reg_1 = lm(total_rolling_average_mortality~Lagged_Stringency_Index_One_Week + Lagged_Stringency_Index_Two_Weeks + Lagged_Stringency_Index_Three_Weeks + Lagged_Monetary_Measures_One_Weeks + Lagged_Monetary_Measures_Two_Weeks + Lagged_Monetary_Measures_Three_Weeks + Lagged_Health_Care_One_Week + Lagged_Health_Care_Two_Weeks + Lagged_Health_Care_Three_Weeks + Lagged_Vaccine_One_Week + Lagged_Vaccine_Two_Weeks + Lagged_Vaccine_Three_Weeks + Lagged_Testing_Framework_One_Week + Lagged_Testing_Framework_Two_Weeks + Lagged_Testing_Framework_Three_Weeks + Lagged_Contact_Tracing_One_Week + Lagged_Contact_Tracing_Two_Weeks + Lagged_Contact_Tracing_Three_Weeks + prop65 + propurban, data = Final_Data_Country)
summary(reg_1)

# I want to check this regression against the lag function.
reg_1check = lm(total_rolling_average_mortality~Lag(StringencyIndex,7) + Lag(StringencyIndex,14) + Lag(StringencyIndex,21) +  Lag(S9_Monetary.measures,7) + Lag(S9_Monetary.measures,14) + Lag(S9_Monetary.measures,21) + Lag(S10_Emergency.investment.in.health.care,7) + Lag(S10_Emergency.investment.in.health.care,14) + Lag(S10_Emergency.investment.in.health.care,21) + Lag(S11_Investment.in.Vaccines,7) + Lag(S11_Investment.in.Vaccines,14) + Lag(S11_Investment.in.Vaccines,21) + Lag(S12_Testing.framework,7) + Lag(S12_Testing.framework,14) + Lag(S12_Testing.framework,21) + Lag(S13_Contact.tracing,7) + Lag(S13_Contact.tracing,14) + Lag(S13_Contact.tracing,21) + prop65 + propurban, data = Final_Data_Country)
summary(reg_1check)

# Next, I run the regressions by type of intervention.

# School Closings
reg_2 = lm(total_rolling_average_mortality~Lagged_School_Closing_One_Week + Lagged_School_Closing_General_One_Week + Lagged_School_Closing_Two_Weeks + Lagged_School_Closing_General_Two_Weeks + Lagged_School_Closing_Three_Weeks + Lagged_School_Closing_General_Three_Weeks + prop65 + propurban, data = Final_Data_Country)
summary(reg_2)

# Workplace Closings
reg_3 = lm(total_rolling_average_mortality~Lagged_Workplace_Closing_One_Week + Lagged_Workplace_Closing_General_One_Week + Lagged_Workplace_Closing_Two_Weeks + Lagged_Workplace_Closing_General_Two_Weeks + Lagged_Workplace_Closing_Three_Weeks + Lagged_Workplace_Closing_General_Three_Weeks + prop65 + propurban, data = Final_Data_Country)
summary(reg_3)

# Public Event Closings
reg_4 = lm(total_rolling_average_mortality~Lagged_Public_Events_One_Week + Lagged_Public_Events_General_One_Week + Lagged_Public_Events_Two_Weeks + Lagged_Public_Events_General_Two_Weeks + Lagged_Public_Events_Three_Weeks + Lagged_Public_Events_General_Three_Weeks + prop65 + propurban, data = Final_Data_Country)
summary(reg_4)

# Public Transport Closings
reg_5 = lm(total_rolling_average_mortality~Lagged_Public_Transport_One_Week + Lagged_Public_Transport_General_One_Week + Lagged_Public_Transport_Two_Weeks + Lagged_Public_Transport_General_Two_Weeks + Lagged_Public_Transport_Three_Weeks + Lagged_Public_Transport_General_Three_Weeks + prop65 + propurban, data = Final_Data_Country)
summary(reg_5)

# Public Information Campaigns
reg_6 = lm(total_rolling_average_mortality~Lagged_Campaign_One_Week + Lagged_Campaign_General_One_Week + Lagged_Campaign_Two_Weeks + Lagged_Campaign_General_Two_Weeks + Lagged_Campaign_Three_Weeks + Lagged_Campaign_General_Three_Weeks + prop65 + propurban, data = Final_Data_Country)
summary(reg_6)

# Restricted Internal Movements
reg_7 = lm(total_rolling_average_mortality~Lagged_Internal_Movement_One_Week + Lagged_Internal_Movement_Two_Weeks + Lagged_Internal_Movement_Three_Weeks + prop65 + propurban, data = Final_Data_Country)
summary(reg_7)

# Fiscal Measures
reg_8 = lm(total_rolling_average_mortality~Lagged_Monetary_Measures_One_Weeks + Lagged_Monetary_Measures_Two_Weeks + Lagged_Monetary_Measures_Three_Weeks + prop65 + propurban, data = Final_Data_Country)
summary(reg_8)

# Monetary Measures
reg_9 = lm(total_rolling_average_mortality~Lagged_Fiscal_Measures_One_Week + Lagged_Fiscal_Measures_Two_Weeks + Lagged_Fiscal_Measures_Three_Weeks + prop65 + propurban, data = Final_Data_Country)
summary(reg_9)

# International Travel Measures
reg_10 = lm(total_rolling_average_mortality~Lagged_International_Travel_One_Week + Lagged_International_Travel_Two_Weeks + Lagged_International_Travel_Three_Weeks + prop65 + propurban, data = Final_Data_Country)
summary(reg_10)

# Health Care
reg_11 = lm(total_rolling_average_mortality~Lagged_Health_Care_One_Week + Lagged_Health_Care_Two_Weeks + Lagged_Health_Care_Three_Weeks + prop65 + propurban, data = Final_Data_Country)
summary(reg_11)

# Vaccine
reg_12 = lm(total_rolling_average_mortality~Lagged_Vaccine_One_Week + Lagged_Vaccine_Two_Weeks + Lagged_Vaccine_Three_Weeks + prop65 + propurban, data = Final_Data_Country)
summary(reg_12)

# Testing Frameworks
reg_13 = lm(total_rolling_average_mortality~Lagged_Testing_Framework_One_Week + Lagged_Testing_Framework_Two_Weeks + Lagged_Testing_Framework_Three_Weeks + prop65 + propurban, data = Final_Data_Country)
summary(reg_13)

# Contact Tracing
reg_14 = lm(total_rolling_average_mortality~Lagged_Contact_Tracing_One_Week + Lagged_Contact_Tracing_Two_Weeks + Lagged_Contact_Tracing_Three_Weeks + prop65 + propurban, data = Final_Data_Country)
summary(reg_14)

# Overall Regression - VERY HIGH Collinearity (only 700 observations)

reg_Final_1 = lm(total_rolling_average_mortality~Lagged_School_Closing_One_Week + Lagged_School_Closing_General_One_Week + Lagged_Workplace_Closing_One_Week + Lagged_Workplace_Closing_General_One_Week + Lagged_Public_Events_One_Week + Lagged_Public_Events_General_One_Week + Lagged_Public_Transport_One_Week + Lagged_Public_Transport_General_One_Week + Lagged_Campaign_One_Week + Lagged_Campaign_General_One_Week + Lagged_Internal_Movement_One_Week + Lagged_Health_Care_One_Week + Lagged_Vaccine_One_Week + Lagged_Testing_Framework_One_Week + Lagged_School_Closing_Two_Weeks + Lagged_School_Closing_General_Two_Weeks + Lagged_Workplace_Closing_Two_Weeks + Lagged_Workplace_Closing_General_Two_Weeks + Lagged_Public_Events_Two_Weeks + Lagged_Public_Events_General_Two_Weeks + Lagged_Public_Transport_Two_Weeks + Lagged_Public_Transport_General_Two_Weeks + Lagged_Campaign_Two_Weeks + Lagged_Campaign_General_Two_Weeks + Lagged_Internal_Movement_Two_Weeks + Lagged_Internal_Movement_General_Two_Weeks + Lagged_International_Travel_Two_Weeks + Lagged_Fiscal_Measures_Two_Weeks + Lagged_Monetary_Measures_Two_Weeks + Lagged_Health_Care_Two_Weeks + Lagged_Vaccine_Two_Weeks + Lagged_Testing_Framework_Two_Weeks + Lagged_School_Closing_Three_Weeks + Lagged_Workplace_Closing_Three_Weeks + Lagged_Public_Events_Three_Weeks + Lagged_Public_Events_General_Three_Weeks + Lagged_Campaign_Three_Weeks + Lagged_Campaign_General_Three_Weeks + Lagged_Internal_Movement_Three_Weeks + Lagged_International_Travel_Three_Weeks + Lagged_Fiscal_Measures_Three_Weeks + Lagged_Monetary_Measures_Three_Weeks + Lagged_Health_Care_Three_Weeks + Lagged_Vaccine_Three_Weeks + Lagged_Testing_Framework_Three_Weeks + prop65 + propurban, data = Final_Data_Country)
summary(reg_Final_1)

# Check for multicollinearity.
alias(reg_Final_1)

# Now, I do the same thing, but in a log-level model (the coefficients are now weekly percentage changes).
reg_Final_2 = lm(log(total_rolling_average_mortality+1)~Lagged_School_Closing_One_Week + Lagged_School_Closing_General_One_Week + Lagged_Workplace_Closing_One_Week + Lagged_Workplace_Closing_General_One_Week + Lagged_Public_Events_One_Week + Lagged_Public_Events_General_One_Week + Lagged_Public_Transport_One_Week + Lagged_Public_Transport_General_One_Week + Lagged_Campaign_One_Week + Lagged_Campaign_General_One_Week + Lagged_Internal_Movement_One_Week + Lagged_Health_Care_One_Week + Lagged_Vaccine_One_Week + Lagged_Testing_Framework_One_Week + Lagged_School_Closing_Two_Weeks + Lagged_School_Closing_General_Two_Weeks + Lagged_Workplace_Closing_Two_Weeks + Lagged_Workplace_Closing_General_Two_Weeks + Lagged_Public_Events_Two_Weeks + Lagged_Public_Events_General_Two_Weeks + Lagged_Public_Transport_Two_Weeks + Lagged_Public_Transport_General_Two_Weeks + Lagged_Campaign_Two_Weeks + Lagged_Campaign_General_Two_Weeks + Lagged_Internal_Movement_Two_Weeks + Lagged_Internal_Movement_General_Two_Weeks + Lagged_International_Travel_Two_Weeks + Lagged_Fiscal_Measures_Two_Weeks + Lagged_Monetary_Measures_Two_Weeks + Lagged_Health_Care_Two_Weeks + Lagged_Vaccine_Two_Weeks + Lagged_Testing_Framework_Two_Weeks + Lagged_School_Closing_Three_Weeks + Lagged_Workplace_Closing_Three_Weeks + Lagged_Public_Events_Three_Weeks + Lagged_Public_Events_General_Three_Weeks + Lagged_Campaign_Three_Weeks + Lagged_Campaign_General_Three_Weeks + Lagged_Internal_Movement_Three_Weeks + Lagged_International_Travel_Three_Weeks + Lagged_Fiscal_Measures_Three_Weeks + Lagged_Monetary_Measures_Three_Weeks + Lagged_Health_Care_Three_Weeks + Lagged_Vaccine_Three_Weeks + Lagged_Testing_Framework_Three_Weeks + prop65 + propurban, data = Final_Data_Country)
summary(reg_Final_2)

# I now add lagged mortality rates from the previous periods.

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "total_rolling_average_mortality", slideBy = -7, GroupVar = "COUNTRY", NewVar = "Lagged_Mortality_One_Week", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "total_rolling_average_mortality", slideBy = -14, GroupVar = "COUNTRY", NewVar = "Lagged_Mortality_Two_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "total_rolling_average_mortality", slideBy = -21, GroupVar = "COUNTRY", NewVar = "Lagged_Mortality_Three_Weeks", keepInvalid = TRUE, reminder = FALSE)

Final_Data_Country <- Final_Data_Country %>%
  dplyr::group_by(COUNTRY) %>%
  slide(Var = "total_rolling_average_mortality", slideBy = -28, GroupVar = "COUNTRY", NewVar = "Lagged_Mortality_Four_Weeks", keepInvalid = TRUE, reminder = FALSE)

reg_Final_3 = lm(log(total_rolling_average_mortality+1)~Lagged_School_Closing_One_Week + Lagged_School_Closing_General_One_Week + Lagged_Workplace_Closing_One_Week + Lagged_Workplace_Closing_General_One_Week + Lagged_Public_Events_One_Week + Lagged_Public_Events_General_One_Week + Lagged_Public_Transport_One_Week + Lagged_Public_Transport_General_One_Week + Lagged_Campaign_One_Week + Lagged_Campaign_General_One_Week + Lagged_Internal_Movement_One_Week + Lagged_Health_Care_One_Week + Lagged_Vaccine_One_Week + Lagged_Testing_Framework_One_Week + Lagged_School_Closing_Two_Weeks + Lagged_School_Closing_General_Two_Weeks + Lagged_Workplace_Closing_Two_Weeks + Lagged_Workplace_Closing_General_Two_Weeks + Lagged_Public_Events_Two_Weeks + Lagged_Public_Events_General_Two_Weeks + Lagged_Public_Transport_Two_Weeks + Lagged_Public_Transport_General_Two_Weeks + Lagged_Campaign_Two_Weeks + Lagged_Campaign_General_Two_Weeks + Lagged_Internal_Movement_Two_Weeks + Lagged_Internal_Movement_General_Two_Weeks + Lagged_International_Travel_Two_Weeks + Lagged_Fiscal_Measures_Two_Weeks + Lagged_Monetary_Measures_Two_Weeks + Lagged_Health_Care_Two_Weeks + Lagged_Vaccine_Two_Weeks + Lagged_Testing_Framework_Two_Weeks + Lagged_School_Closing_Three_Weeks + Lagged_Workplace_Closing_Three_Weeks + Lagged_Public_Events_Three_Weeks + Lagged_Public_Events_General_Three_Weeks + Lagged_Campaign_Three_Weeks + Lagged_Campaign_General_Three_Weeks + Lagged_Internal_Movement_Three_Weeks + Lagged_International_Travel_Three_Weeks + Lagged_Fiscal_Measures_Three_Weeks + Lagged_Monetary_Measures_Three_Weeks + Lagged_Health_Care_Three_Weeks + Lagged_Vaccine_Three_Weeks + Lagged_Testing_Framework_Three_Weeks + Lagged_Mortality_One_Week + Lagged_Mortality_Two_Weeks + Lagged_Mortality_Three_Weeks + Lagged_Mortality_Four_Weeks + prop65 + propurban, data = Final_Data_Country)
summary(reg_Final_3)

# Here, I integrate fixed effects into the regression, and incorporate the mobility data. First, I add the plm package for fixed effects. 
library(plm)
Fixed_Effects <- pdata.frame(Final_Data_Country, index=c("COUNTRY","Date"), drop.index=TRUE, row.names=TRUE)
head(Fixed_Effects)
table(index(Fixed_Effects), useNA = "ifany")

Fixed_Effects_One <- plm(total_rolling_average_mortality~Lagged_School_Closing_One_Week + Lagged_School_Closing_General_One_Week + Lagged_Workplace_Closing_One_Week + Lagged_Workplace_Closing_General_One_Week + Lagged_Public_Events_One_Week + Lagged_Public_Events_General_One_Week + Lagged_Public_Transport_One_Week + Lagged_Public_Transport_General_One_Week + Lagged_Campaign_One_Week + Lagged_Campaign_General_One_Week + Lagged_Internal_Movement_One_Week + Lagged_Health_Care_One_Week + Lagged_Vaccine_One_Week + Lagged_Testing_Framework_One_Week + Lagged_School_Closing_Two_Weeks + Lagged_School_Closing_General_Two_Weeks + Lagged_Workplace_Closing_Two_Weeks + Lagged_Workplace_Closing_General_Two_Weeks + Lagged_Public_Events_Two_Weeks + Lagged_Public_Events_General_Two_Weeks + Lagged_Public_Transport_Two_Weeks + Lagged_Public_Transport_General_Two_Weeks + Lagged_Campaign_Two_Weeks + Lagged_Campaign_General_Two_Weeks + Lagged_Internal_Movement_Two_Weeks + Lagged_Internal_Movement_General_Two_Weeks + Lagged_International_Travel_Two_Weeks + Lagged_Fiscal_Measures_Two_Weeks + Lagged_Monetary_Measures_Two_Weeks + Lagged_Health_Care_Two_Weeks + Lagged_Vaccine_Two_Weeks + Lagged_Testing_Framework_Two_Weeks + Lagged_School_Closing_Three_Weeks + Lagged_Workplace_Closing_Three_Weeks + Lagged_Public_Events_Three_Weeks + Lagged_Public_Events_General_Three_Weeks + Lagged_Campaign_Three_Weeks + Lagged_Campaign_General_Three_Weeks + Lagged_Internal_Movement_Three_Weeks + Lagged_International_Travel_Three_Weeks + Lagged_Fiscal_Measures_Three_Weeks + Lagged_Monetary_Measures_Three_Weeks + Lagged_Health_Care_Three_Weeks + Lagged_Vaccine_Three_Weeks + Lagged_Testing_Framework_Three_Weeks + + driving + walking + transit, data = Fixed_Effects, model = "within")
summary(Fixed_Effects_One)

# Now, I include time-fixed effects as well.
Fixed_Effects_Two <- plm(total_rolling_average_mortality~Lagged_School_Closing_One_Week + Lagged_School_Closing_General_One_Week + Lagged_Workplace_Closing_One_Week + Lagged_Workplace_Closing_General_One_Week + Lagged_Public_Events_One_Week + Lagged_Public_Events_General_One_Week + Lagged_Public_Transport_One_Week + Lagged_Public_Transport_General_One_Week + Lagged_Campaign_One_Week + Lagged_Campaign_General_One_Week + Lagged_Internal_Movement_One_Week + Lagged_Health_Care_One_Week + Lagged_Vaccine_One_Week + Lagged_Testing_Framework_One_Week + Lagged_School_Closing_Two_Weeks + Lagged_School_Closing_General_Two_Weeks + Lagged_Workplace_Closing_Two_Weeks + Lagged_Workplace_Closing_General_Two_Weeks + Lagged_Public_Events_Two_Weeks + Lagged_Public_Events_General_Two_Weeks + Lagged_Public_Transport_Two_Weeks + Lagged_Public_Transport_General_Two_Weeks + Lagged_Campaign_Two_Weeks + Lagged_Campaign_General_Two_Weeks + Lagged_Internal_Movement_Two_Weeks + Lagged_Internal_Movement_General_Two_Weeks + Lagged_International_Travel_Two_Weeks + Lagged_Fiscal_Measures_Two_Weeks + Lagged_Monetary_Measures_Two_Weeks + Lagged_Health_Care_Two_Weeks + Lagged_Vaccine_Two_Weeks + Lagged_Testing_Framework_Two_Weeks + Lagged_School_Closing_Three_Weeks + Lagged_Workplace_Closing_Three_Weeks + Lagged_Public_Events_Three_Weeks + Lagged_Public_Events_General_Three_Weeks + Lagged_Campaign_Three_Weeks + Lagged_Campaign_General_Three_Weeks + Lagged_Internal_Movement_Three_Weeks + Lagged_International_Travel_Three_Weeks + Lagged_Fiscal_Measures_Three_Weeks + Lagged_Monetary_Measures_Three_Weeks + Lagged_Health_Care_Three_Weeks + Lagged_Vaccine_Three_Weeks + Lagged_Testing_Framework_Three_Weeks + driving + walking + transit, data = Fixed_Effects, model = "within", effect = "twoways")
summary(Fixed_Effects_Two)

# Here, I do the same regressions with lagged mortality.

Fixed_Effects_Three <- plm(total_rolling_average_mortality~Lagged_School_Closing_One_Week + Lagged_School_Closing_General_One_Week + Lagged_Workplace_Closing_One_Week + Lagged_Workplace_Closing_General_One_Week + Lagged_Public_Events_One_Week + Lagged_Public_Events_General_One_Week + Lagged_Public_Transport_One_Week + Lagged_Public_Transport_General_One_Week + Lagged_Campaign_One_Week + Lagged_Campaign_General_One_Week + Lagged_Internal_Movement_One_Week + Lagged_Health_Care_One_Week + Lagged_Vaccine_One_Week + Lagged_Testing_Framework_One_Week + Lagged_School_Closing_Two_Weeks + Lagged_School_Closing_General_Two_Weeks + Lagged_Workplace_Closing_Two_Weeks + Lagged_Workplace_Closing_General_Two_Weeks + Lagged_Public_Events_Two_Weeks + Lagged_Public_Events_General_Two_Weeks + Lagged_Public_Transport_Two_Weeks + Lagged_Public_Transport_General_Two_Weeks + Lagged_Campaign_Two_Weeks + Lagged_Campaign_General_Two_Weeks + Lagged_Internal_Movement_Two_Weeks + Lagged_Internal_Movement_General_Two_Weeks + Lagged_International_Travel_Two_Weeks + Lagged_Fiscal_Measures_Two_Weeks + Lagged_Monetary_Measures_Two_Weeks + Lagged_Health_Care_Two_Weeks + Lagged_Vaccine_Two_Weeks + Lagged_Testing_Framework_Two_Weeks + Lagged_School_Closing_Three_Weeks + Lagged_Workplace_Closing_Three_Weeks + Lagged_Public_Events_Three_Weeks + Lagged_Public_Events_General_Three_Weeks + Lagged_Campaign_Three_Weeks + Lagged_Campaign_General_Three_Weeks + Lagged_Internal_Movement_Three_Weeks + Lagged_International_Travel_Three_Weeks + Lagged_Fiscal_Measures_Three_Weeks + Lagged_Monetary_Measures_Three_Weeks + Lagged_Health_Care_Three_Weeks + Lagged_Vaccine_Three_Weeks + Lagged_Testing_Framework_Three_Weeks + Lagged_Mortality_One_Week + Lagged_Mortality_Two_Weeks + Lagged_Mortality_Three_Weeks + Lagged_Mortality_Four_Weeks + driving + walking + transit, data = Fixed_Effects, model = "within")
summary(Fixed_Effects_Three)

Fixed_Effects_Four <- plm(total_rolling_average_mortality~Lagged_School_Closing_One_Week + Lagged_School_Closing_General_One_Week + Lagged_Workplace_Closing_One_Week + Lagged_Workplace_Closing_General_One_Week + Lagged_Public_Events_One_Week + Lagged_Public_Events_General_One_Week + Lagged_Public_Transport_One_Week + Lagged_Public_Transport_General_One_Week + Lagged_Campaign_One_Week + Lagged_Campaign_General_One_Week + Lagged_Internal_Movement_One_Week + Lagged_Health_Care_One_Week + Lagged_Vaccine_One_Week + Lagged_Testing_Framework_One_Week + Lagged_School_Closing_Two_Weeks + Lagged_School_Closing_General_Two_Weeks + Lagged_Workplace_Closing_Two_Weeks + Lagged_Workplace_Closing_General_Two_Weeks + Lagged_Public_Events_Two_Weeks + Lagged_Public_Events_General_Two_Weeks + Lagged_Public_Transport_Two_Weeks + Lagged_Public_Transport_General_Two_Weeks + Lagged_Campaign_Two_Weeks + Lagged_Campaign_General_Two_Weeks + Lagged_Internal_Movement_Two_Weeks + Lagged_Internal_Movement_General_Two_Weeks + Lagged_International_Travel_Two_Weeks + Lagged_Fiscal_Measures_Two_Weeks + Lagged_Monetary_Measures_Two_Weeks + Lagged_Health_Care_Two_Weeks + Lagged_Vaccine_Two_Weeks + Lagged_Testing_Framework_Two_Weeks + Lagged_School_Closing_Three_Weeks + Lagged_Workplace_Closing_Three_Weeks + Lagged_Public_Events_Three_Weeks + Lagged_Public_Events_General_Three_Weeks + Lagged_Campaign_Three_Weeks + Lagged_Campaign_General_Three_Weeks + Lagged_Internal_Movement_Three_Weeks + Lagged_International_Travel_Three_Weeks + Lagged_Fiscal_Measures_Three_Weeks + Lagged_Monetary_Measures_Three_Weeks + Lagged_Health_Care_Three_Weeks + Lagged_Vaccine_Three_Weeks + Lagged_Testing_Framework_Three_Weeks + Lagged_Mortality_One_Week + Lagged_Mortality_Two_Weeks + Lagged_Mortality_Three_Weeks + driving + walking + transit, data = Final_Data_Country, model = "within", effect = "twoways")
summary(Fixed_Effects_Four)

alias(Fixed_Effects_Four)

detach("package:Hmisc", unload=TRUE)

```

# Finally, I add Rashad's additional analysis. Please feel to make any edits as necessary below, or above (comment the changes),

```{r Weining - Apr 25th 2020}
First_Death_temp <- First_Death %>%
  group_by(COUNTRY) %>%
  mutate(StringencyIndex_deviation = StringencyIndex - (Lag(StringencyIndex,1)+Lag(StringencyIndex,2)+Lag(StringencyIndex,3)+Lag(StringencyIndex,4)+Lag(StringencyIndex,5)+Lag(StringencyIndex,6)+Lag(StringencyIndex,7))/7)

First_Death_temp <- First_Death_temp %>%
  group_by(COUNTRY) %>%
  mutate(total_mortality_growth_lagged7 =  Lag(total_mortality_growth,7))

First_Death_temp[which(First_Death_temp$StringencyIndex_deviation == Inf),"StringencyIndex_deviation"] <- NA

First_Death_temp <- First_Death_temp %>% ungroup()
regmod_temp<-plm(total_mortality_growth~Lag(StringencyIndex_deviation,c(7,14,21,28,35)),method="pooling",effect="twoways",data=First_Death_temp,na.action="na.exclude")
summary(regmod_temp)
coeftest(regmod_temp, vcov = vcovHC(regmod_temp, type = "HC1", cluster="group"))

# Plot_temp <- plot_ly(First_Death_temp, x=~Date, y=~total_mortality_growth, z = ~StringencyIndex) %>%
#   add_lines(linetype = ~COUNTRY) %>%
#   layout(title="Total Mortality Growth against Its Lag - COVID19")
# for(country in levels(First_Death_temp$COUNTRY)){
#   print(country)
#   Plot_temp <- Plot_temp %>% add_lines(x=First_Death_temp[which(First_Death_temp$COUNTRY == country &  !is.na(First_Death_temp$StringencyIndex)),'Date'], y=First_Death_temp[which(First_Death_temp$COUNTRY == country & !is.na(First_Death_temp$StringencyIndex)),'StringencyIndex'], type = 'scatter', mode = 'lines',name = paste("S",country), inherit=TRUE)
# }

# Plot_temp
```

```{r Sameer - Apr 25th 2020}
# New Regression Estimations from Prof. Jinjarak.

# Estimation A with time and country fixed effects.
Fixed_Effects_Five <- plm(log(total_rolling_average_mortality+1)~log(Lagged_Mortality_One_Week+1) + log(Lagged_Mortality_Two_Weeks+1) + log(Lagged_Mortality_Three_Weeks+1) + log(Lagged_Mortality_Four_Weeks+1) + Lagged_Stringency_Index_One_Week + Lagged_Stringency_Index_Two_Weeks + Lagged_Stringency_Index_Three_Weeks, data = Final_Data_Country, model = "within", effect = "twoways")
summary(Fixed_Effects_Five)

# Estimation B with interaction terms. When we observe the results for the interactions between prop65 and stringency index, we can see that perhaps implementing longer lags (one month or more) might be more fruitful for estimation.
reg_Final_3 <- plm(log(total_rolling_average_mortality+1)~log(Lagged_Mortality_One_Week+1) + log(Lagged_Mortality_Two_Weeks+1) + log(Lagged_Mortality_Three_Weeks+1) + log(Lagged_Mortality_Four_Weeks+1) + Lagged_Stringency_Index_One_Week + Lagged_Stringency_Index_Two_Weeks + Lagged_Stringency_Index_Three_Weeks + propurban + prop65 + (Lagged_Stringency_Index_One_Week*propurban) + (Lagged_Stringency_Index_One_Week*prop65) + (Lagged_Stringency_Index_Two_Weeks*propurban) + (Lagged_Stringency_Index_Two_Weeks*prop65) + (Lagged_Stringency_Index_Three_Weeks*propurban) + (Lagged_Stringency_Index_Three_Weeks*prop65), data = Final_Data_Country)
summary(reg_Final_3)

## Estimation C with interaction terms.

reg_Final_4 <- plm(log(total_rolling_average_mortality+1)~log(Lagged_Mortality_One_Week+1) + log(Lagged_Mortality_Two_Weeks+1) + log(Lagged_Mortality_Three_Weeks+1) + log(Lagged_Mortality_Four_Weeks+1) + Lagged_Stringency_Index_One_Week + Lagged_Stringency_Index_Two_Weeks + Lagged_Stringency_Index_Three_Weeks + propurban + prop65 + (Lagged_Stringency_Index_One_Week*propurban) + (Lagged_Stringency_Index_One_Week*prop65) + (Lagged_Stringency_Index_Two_Weeks*propurban) + (Lagged_Stringency_Index_Two_Weeks*prop65) + (Lagged_Stringency_Index_Three_Weeks*propurban) + (Lagged_Stringency_Index_Three_Weeks*prop65) + walking + driving + transit, data = Final_Data_Country)
summary(reg_Final_4)

```

### Rashad Analysis Updated
```{r Rashad - April 28th 2020 P1}
# Creating the dataframe.
Rashad_Data<-Final_Data_Country[-which(Final_Data_Country$Total_Deceased_Country<1),]
Rashad_Data$Date<-as.Date(Rashad_Data$Date,"%Y-%m-%d")

a<-Rashad_Data
a<-pdata.frame(Rashad_Data, index = c("COUNTRY", "Date"))
a$Date<-as.Date(a$Date,"%m/%d/%y")

#reorder
a<-a[order(a$Date),]
a<-a[order(a$COUNTRY),]

cum_mort_growth<-log(subset(a,COUNTRY==unique(COUNTRY)[1])$total_rolling_average_mortality)-Lag(log(subset(a,COUNTRY==unique(COUNTRY)[1])$total_rolling_average_mortality),7)
for(i in 2:length(unique(a$COUNTRY))){
  cum_mort_growth<-c(cum_mort_growth,log(subset(a,COUNTRY==unique(COUNTRY)[i])$total_rolling_average_mortality)-Lag(log(subset(a,COUNTRY==unique(COUNTRY)[i])$total_rolling_average_mortality),7))
}
a$cum_mort_growth<-cum_mort_growth
```

```{r Rashad - April 28th 2020 P2}

###baseline projection regressions, remove 'infinite' values. two-way FE, HAC robust SEs, clustered on country
regmoda<-plm(cum_mort_growth~Lag(cum_mort_growth,7)+Lag(StringencyIndex,c(14)),method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))
summary(regmoda)

regmodb<-plm(cum_mort_growth~Lag(cum_mort_growth,14)+Lag(StringencyIndex,c(21)),method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))
summary(regmodb)

regmodc<-plm(cum_mort_growth~Lag(cum_mort_growth,21)+Lag(StringencyIndex,c(28)),method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))
summary(regmodc)

regmodd<-plm(cum_mort_growth~Lag(cum_mort_growth,28)+Lag(StringencyIndex,c(35)),method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))
summary(regmodd)

### plot of 10-unit increase in Stringency effects over time on future mortality growth
p.dat<-c(coef(regmoda)[2],coef(regmodb)[2],coef(regmodc)[2],coef(regmodd)[2])
p.dat<-cbind(p.dat,p.dat+1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
p.dat<-cbind(p.dat,p.dat[,1]-1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
colnames(p.dat)<-c("mean","upper","lower")
p.dat<-data.frame(p.dat)*10*100

Plot_32 <-ggplot(data=p.dat,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean))+geom_point(size=4,shape=21,fill="grey")+geom_hline(yintercept=0,linetype=2)+xlab("Increase in Stringency Index of 10 units, (x) Weeks Prior")+theme_bw()+ylab("Effect on Week 0 Mortality Growth (%)")+geom_errorbar(aes(ymin=lower,ymax=upper))
Plot_32                                                                                                       

```

#### heterogeneity: Proportion Elderly
```{r Rashad - April 28th 2020 P3}
###baseline projection regressions, remove 'infinite' values. two-way FE, HAC robust SEs, clustered on country

regmoda<-plm(cum_mort_growth~Lag(cum_mort_growth,7)+Lag(StringencyIndex,c(14)):prop65,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))
summary(regmoda)

regmodb<-plm(cum_mort_growth~Lag(cum_mort_growth,14)+Lag(StringencyIndex,c(21)):prop65,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))
summary(regmodb)

regmodc<-plm(cum_mort_growth~Lag(cum_mort_growth,21)+Lag(StringencyIndex,c(28)):prop65,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))
summary(regmodc)

regmodd<-plm(cum_mort_growth~Lag(cum_mort_growth,28)+Lag(StringencyIndex,c(35)):prop65,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))
summary(regmodd)

### plot of 10-unit increase in Stringency effects over time on future mortality growth
 p.dat<-c(coef(regmoda)[2],coef(regmodb)[2],coef(regmodc)[2],coef(regmodd)[2])
 p.dat<-cbind(p.dat,p.dat+1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 p.dat<-cbind(p.dat,p.dat[,1]-1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 colnames(p.dat)<-c("mean","upper","lower")
 p.dat<-data.frame(p.dat)*10*100
 
###figure out the 25% percentile  and 75% percentile of elderly population rate across countries, to compare effects of a 10-unit rise in stringency level
 summary(unique(a$prop65)) #roughly 8.5% and 20%, respectively
 
 #plot
Plot_33 <-ggplot(data=p.dat,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*20))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*20),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("Increase in Stringency Index of 10 units, (x) Weeks Prior")+theme_bw()+ylab("Effect on Week 0 Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*8.5),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*8.5)),linetype=2)+annotate(geom="text", x=2, y=-6, label="20% 65+ (75th pct)",color="red")+annotate(geom="text", x=2, y=-2, label="8.5% 65+ (25th pct)",
              color="blue")
Plot_33
summary(unique(na.omit(a$propurban)))

### plot of 10-unit increase in Stringency effects over time on future mortality growth
 p.dat<-c(coef(regmoda)[2],coef(regmodb)[2],coef(regmodc)[2],coef(regmodd)[2])
 p.dat<-cbind(p.dat,p.dat+1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 p.dat<-cbind(p.dat,p.dat[,1]-1.96*c(se.a[2,2],se.b[2,2],se.c[2,2],se.d[2,2]))
 colnames(p.dat)<-c("mean","upper","lower")
 p.dat<-data.frame(p.dat)*10*100
 
###figure out the 25% percentile  and 75% percentile of proportion urban across countries, to compare effects of a 10-unit rise in stringency level
 summary(unique(a$prop65)) #roughly 66% and 86%, respectively
 
 #plot
Plot_34 <-ggplot(data=p.dat,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*86))+geom_line(group=1,aes(x=c("2 weeks","3 weeks","4 weeks","5 weeks"),y=mean*86),linetype=2)+geom_point(size=4,shape=22,fill="red")+geom_hline(yintercept=0,linetype=2)+xlab("Increase in Stringency Index of 10 units, (x) Weeks Prior")+theme_bw()+ylab("Effect on Week 0 Mortality Growth (%)")+
   geom_point(size=4,aes(y=mean*66),shape=21,fill="blue")+geom_line(group=1,aes(y=c(mean*66)),linetype=2)+annotate(geom="text", x=2, y=-6, label="86% 65+ (75th pct)",color="red")+annotate(geom="text", x=2, y=-2, label="66% 65+ (25th pct)",
              color="blue")
Plot_34

```

# Test
``` {r Rashad - 28th 2020 P3}
regmoda<-plm(cum_mort_growth~Lag(cum_mort_growth,7)+Lag(StringencyIndex,c(14)):propurban,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.a<-coeftest(regmoda, vcov = vcovHC(regmoda, type = "HC1", cluster="group"))
summary(regmoda)

regmodb<-plm(cum_mort_growth~Lag(cum_mort_growth,14)+Lag(StringencyIndex,c(21)):propurban,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.b<-coeftest(regmodb, vcov = vcovHC(regmodb, type = "HC1", cluster="group"))
summary(regmodb)

regmodc<-plm(cum_mort_growth~Lag(cum_mort_growth,21)+Lag(StringencyIndex,c(28)):propurban,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.c<-coeftest(regmodc, vcov = vcovHC(regmodc, type = "HC1", cluster="group"))
summary(regmodc)

regmodd<-plm(cum_mort_growth~Lag(cum_mort_growth,28)+Lag(StringencyIndex,c(35)):propurban,method="pooling",effect="twoways",data=a[which(!is.infinite(a$cum_mort_growth)),],na.action="na.exclude")
se.d<-coeftest(regmodd, vcov = vcovHC(regmodd, type = "HC1", cluster="group"))
summary(regmodd)
```

